# HTTP Caching

> 原文 [https://www.rfc-editor.org/rfc/rfc9111](https://www.rfc-editor.org/rfc/rfc9111)

## 摘要

超文本传输​​协议 (HTTP) 是用于分布式协作超文本信息系统的无状态应用程序级协议。本文档定义了 HTTP 缓存以及控制缓存行为或指示可缓存响应消息的相关标头字段。

## 1. Introduction

超文本传输​​协议 (HTTP) 是一种无状态应用程序级请求/响应协议，它使用可扩展语义和自描述消息与基于网络的超文本信息系统进行灵活交互。它通常用于分布式信息系统，其中使用响应缓存可以提高性能。本文档定义了与缓存和重用响应消息相关的 HTTP 方面。

HTTP “缓存” 是响应消息的本地存储和控制其中消息的存储、检索和删除的子系统。缓存存储可缓存的响应，以减少未来等效请求的响应时间和网络带宽消耗。任何客户端或服务器都可以使用缓存，但在充当隧道时不能使用（ [ HTTP ] 第 3.7 节）。

“共享缓存”是一种存储响应以供多个用户重用的缓存；共享缓存通常（但不总是）部署为中介的一部分。相比之下，“私有缓存” 专供单个用户使用；通常，它们被部署为用户代理的一个组件。

HTTP 缓存的目标是通过重用先前的响应消息来满足当前请求，从而显着提高性能。缓存认为存储的响应是 “新鲜的”，如 第 4.2 节中所定义的，如果它可以在没有“验证”的情况下被重用（检查原始服务器以查看缓存的响应是否对该请求仍然有效）。因此，每次缓存重新使用新响应时，都可以减少延迟和网络开销。当缓存的响应不新鲜时，如果验证可以更新它（第 4.3 节）或者如果源不可用（第 4.2.4 节），它可能仍然是可重用的。

本文档废弃了 [RFC7234] ，附录 B 中总结了更改。

### 1.1. Requirements Notation

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.

Section 2 of [HTTP] defines conformance criteria and contains considerations regarding error handling.

### 1.2. Syntax Notation

本规范使用[ RFC5234 ] 的增强巴科斯范式 (ABNF) 表示法 ，扩展了[ RFC7405 ]中定义的字符串中区分大小写的表示法。

它还使用[ HTTP ]的第 5.6.1 节中定义的列表扩展，允许使用 "#" 运算符（类似于 "*" 运算符表示重复的方式）来紧凑定义逗号分隔的列表。附录 A 显示了收集到的语法，其中所有列表运算符都扩展为标准 ABNF 表示法。

#### 1.2.1. Imported Rules

以下核心规则通过引用包含在[ RFC5234 ]附录 B.1中定义：DIGIT（十进制 0-9）。

[ HTTP ]定义了以下规则：

```
  HTTP-date     = <HTTP-date, see [HTTP], Section 5.6.7>
  OWS           = <OWS, see [HTTP], Section 5.6.3>
  field-name    = <field-name, see [HTTP], Section 5.1>
  quoted-string = <quoted-string, see [HTTP], Section 5.6.4>
  token         = <token, see [HTTP], Section 5.6.2>
```

#### 1.2.2. Delta Seconds

delta-seconds 规则指定一个非负整数，以秒为单位表示时间。

```
  delta-seconds  = 1*DIGIT
```

解析 delta-seconds 并将其转换为二进制形式的接收者应该使用至少 31 位非负整数范围的算术类型。如果缓存接收到的 delta-seconds 值大于它可以表示的最大整数，或者如果它的任何后续计算溢出，则缓存必须将该值视为 2147483648 (2^31) 或它可以方便地表示的最大正整数。

> 注意：这里的值 2147483648 是历史原因，代表无穷大（超过 68 年），不需要以二进制形式存储；如果发生任何溢出，实现可以将其生成为字符串，即使计算是使用无法直接表示该数字的算术类型执行的。这里重要的是检测到溢出，而不是在以后的计算中将其视为负值。

## 2. Overview of Cache Operation

正确的缓存操作可保留 HTTP 传输的语义，同时减少已保存在缓存中的信息的传输。 有关 HTTP 的一般术语和核心概念，请参阅[ HTTP ]的第 3 节。

虽然缓存是 HTTP 的一个完全可选的特性，但可以假设重用缓存的响应是可取的，并且当没有要求或本地配置阻止它时，这种重用是默认行为。因此，HTTP 缓存要求侧重于防止缓存存储不可重用的响应或不适当地重用已存储的响应，而不是强制缓存始终存储和重用特定响应。

“缓存键”是缓存用来选择响应的信息，至少由用于检索存储响应的请求方法和目标 URI 组成；该方法确定在什么情况下可以使用该响应来满足后续请求。然而，如今许多常用的 HTTP 缓存仅缓存 GET 响应，因此仅使用 URI 作为缓存键。

缓存可能会为受内容协商约束的请求目标存储多个响应。缓存通过将一些原始请求的标头字段也合并到缓存键中来区分这些响应，使用 Vary 响应标头字段中的信息，如第 4.1 节所述。

缓存可能会将其他材料合并到缓存键中。例如，用户代理缓存可能包括引用站点的身份，从而“双键”缓存以避免一些隐私风险（参见第 7.2 节）。

最常见的是，缓存存储检索请求的成功结果：即对 GET 请求的 200（OK）响应，其中包含目标资源的表示（[HTTP] 的第9.3.1节）。然而，如果方法的定义允许此类缓存并定义适合用作缓存键的东西。

当缓存无法联系原始服务器或以其他方式找到请求的转发路径时，缓存将“断开连接”。在某些情况下，断开连接的缓存可以提供陈旧的响应（第 4.2.4 节）。

## 3. Storing Responses in Caches

缓存不得存储对请求的响应，除非：

- 缓存理解请求方法；
- 响应状态代码是最终的（参见 [ HTTP ]的第 15 节）；
- 如果响应状态代码是 206 或 304，或者存在必须理解的缓存指令（参见第 5.2.2.3 节）：缓存理解响应状态代码；
- 响应中不存在 no-store 缓存指令（参见第 5.2.2.5 节）；
- 如果缓存是共享的：私有响应指令不存在或允许共享缓存存储修改后的响应；参见第 5.2.2.7 节）；
- 如果缓存是共享的：请求中不存在 Authorization 标头字段（请参阅[ HTTP ]的第 11.6.2 节）或存在明确允许共享缓存的响应指令（请参阅第 3.5 节）；和
- 响应至少包含以下内容之一：
    - 公众回应指令（参见第 5.2.2.9 节）；
    - 私有响应指令，如果缓存未共享（参见第 5.2.2.7 节）；
    - 一个 Expires 头字段（见第 5.3 节）；
    - 最大年龄响应指令（参见第 5.2.2.1 节）；
    - 如果缓存是共享的：s-maxage 响应指令（参见第 5.2.2.10 节）；
    - 允许它被缓存的缓存扩展（参见第 5.2.3 节）；或
    - 定义为可启发式缓存的状态代码（请参阅第 4.2.2 节）。

请注意，缓存扩展可以覆盖列出的任何要求；参见第 5.2.3 节。

在这种情况下，缓存已经“理解”了请求方法或响应状态代码，如果它识别并实现所有指定的缓存相关行为。

请注意，在正常操作中，一些缓存不会存储既没有缓存验证器也没有显式过期时间的响应，因为这样的响应通常对存储没有用。但是，不禁止缓存存储此类响应。

### 3.1. Storing Header and Trailer Fields

在存储响应时，缓存必须包含所有接收到的响应头字段——包括无法识别的头字段；这确保可以成功部署新的 HTTP 标头字段。但是，有以下例外情况：

- [ HTTP ]的第 7.6.1 节要求在转发消息之前删除Connection 标头字段及其名称中列出的字段。这可以通过在存储之前这样做来实现。
- 同样，一些字段的语义要求它们在转发消息之前被删除，这可以通过在存储之前这样做来实现；有关示例，请参阅[ HTTP ]的第 7.6.1 节。
- no-cache（第 5.2.2.4 节）和 private（第 5.2.2.7 节）缓存指令可以具有分别防止所有缓存和共享缓存存储标头字段的参数。
- 缓存在转发请求时使用的特定于代理的标头字段 不得存储，除非缓存将代理的身份合并到缓存键中。实际上，这仅限于 Proxy-Authenticate（[ HTTP ]的第 11.7.1 节）、Proxy-Authentication-Info（[ HTTP ]的第 11.7.3 节）和 Proxy-Authorization（[ HTTP ]的第 11.7.2 节） .

缓存可以将尾部字段与头字段分开存储或丢弃它们。缓存不得将尾部字段与标头字段组合在一起。

### 3.2. Updating Stored Header Fields

在几种情况下，需要缓存从另一个（通常是较新的）响应更新存储的响应的标头字段；例如，参见第 3.4、4.3.4 和 4.3.5 节。

这样做时，缓存必须将提供的响应中的每个头字段添加到存储的响应中，替换已经存在的字段值，但有以下例外：

- 第 3.1 节中存储的标头字段除外，
- 缓存的存储响应所依赖的标头字段，如下所述，
- 收件人自动处理和删除的标头字段，如下所述，以及
- Content-Length 标头字段。

在某些情况下，缓存（尤其是在用户代理中）存储处理接收到的响应的结果，而不是响应本身，并且更新影响该处理的标头字段可能会导致不一致的行为和安全问题。在这种情况下，缓存可以 在例外情况下从更新存储的响应中省略这些头字段，但应该将这种省略限制在确保存储响应的完整性所必需的那些字段中。

例如，浏览器可能会在接收响应时解码响应的内容编码，从而在其存储的数据与响应的原始元数据之间创建断开连接。使用不同的 Content-Encoding 标头字段更新存储的元数据会有问题。同样，浏览器可能会存储解析后的 H​​TML 树，而不是响应中收到的内容；在这种情况下，更新 Content-Type 标头字段是行不通的，因为在解析过程中对格式所做的任何假设现在都将无效。

此外，一些字段会被 HTTP 实现自动处理和删除，例如 Content-Range 标头字段。实现可以自动从更新中忽略此类头字段，即使实际上没有进行处理。

请注意，Content-* 前缀并不是更新中省略了标头字段的信号；这是 MIME 标头字段的约定，而不是 HTTP。

### 3.3. Storing Incomplete Responses

如果请求方法是 GET，响应状态代码是 200（OK），并且已经收到整个响应头部分，缓存可以存储一个不完整的响应（[ HTTP ]的第 6.1 节），前提是存储的响应被记录为不完整。同样，206（部分内容）响应可以像不完整的 200（OK）响应一样存储。但是，如果缓存不支持 Range 和 Content-Range 标头字段，或者如果它不理解这些字段中使用的范围单位，则缓存不得存储不完整或部分内容的响应。

缓存可以通过发出后续范围请求（[ HTTP ]的第 14.2 节）并将成功的响应与存储的响应组合来完成存储的不完整响应，如第 3.4 节中所定义。缓存 不得使用不完整的响应来回答请求，除非响应已经完成，或者请求是部分的并且指定了完全在不完整响应内的范围。缓存不得 在未使用 206（部分内容）状态代码明确标记的情况下向客户端发送部分响应。

### 3.4. Combining Partial Content

如果连接过早关闭或者请求使用一个或多个范围说明符（[ HTTP ]的第 14.2 节）， 则响应可能仅传输部分表示。在几次这样的传输之后，缓存可能已经接收到相同表示的几个范围。缓存可以将这些范围组合成一个存储的响应，并重用该响应以满足以后的请求，如果它们都共享相同的强验证器并且缓存符合 [HTTP] 的第 15.3.7.3 节中的客户端要求。

当将新响应与一个或多个存储的响应组合时，缓存 必须根据第 3.2 节使用新响应中提供的标头字段更新存储的响应标头字段。

### 3.5. Storing Responses from Caches

共享缓存不得使用对带有授权标头字段（ [ HTTP ]的第 11.6.2 节）的请求的缓存响应来满足任何后续请求，除非响应包含 带有响应指令的缓存控制字段（第 5.2.2 节） ) 允许它由共享缓存存储，并且缓存符合该指令对该响应的要求。

在本规范中，以下响应指令具有这样的效果：must-revalidate（第 5.2.2.2 节）、public（第 5.2.2.9 节）和 s-maxage（第 5.2.2.10 节）。

## 4. Constructing Responses from Caches

当出现请求时，缓存不得重用存储的响应，除非：

- 呈现的目标 URI（[ HTTP ]的第 7.1 节）和存储的响应匹配，以及
- 与存储的响应关联的请求方法允许它用于呈现的请求，以及
- 由存储的响应指定的请求头字段（如果有的话）与呈现的匹配（参见第 4.1 节），以及
- 存储的响应不包含 no-cache 指令（第 5.2.2.4 节），除非它被成功验证（第 4.3 节），并且
- 存储的响应是以下之一：
    - 新鲜的（见第 4.2 节），或
    - 允许提供陈旧的服务（参见第 4.2.4 节），或者
    - 成功验证（参见第 4.3 节）。

请注意，缓存扩展可以覆盖列出的任何要求；参见第 5.2.3 节。

当使用存储的响应来满足未经验证的请求时，缓存必须生成一个 Age 标头字段（第 5.1 节），用等于存储响应的 current_age 的值替换响应中的任何内容；参见第 4.2.3 节。

缓存必须通过使用不安全方法（[ HTTP ]的第 9.2.1 节）的请求写入源服务器；即，在转发请求并接收到相应的响应之前，不允许缓存生成对此类请求的回复。

另外请注意，不安全的请求可能会使已存储的响应无效；参见第 4.4 节。

缓存可以使用已存储或可存储的响应来满足多个请求，前提是允许它为相关请求重用该响应。这使缓存能够“折叠请求”——或者在缓存未命中时将多个传入请求组合成一个转发请求——从而减少源服务器和网络上的负载。但是请注意，如果缓存无法对部分或所有折叠请求使用返回的响应，则它将需要转发请求以满足它们，这可能会引入额外的延迟。

当存储了多个合适的响应时，缓存必须使用最近的一个（由日期头字段确定）。它还可以转发带有“Cache-Control: max-age=0”或“Cache-Control: no-cache”的请求，以消除使用哪个响应的歧义。

没有时钟的缓存（[ HTTP ]的第 5.6.7 节）必须在每次使用时重新验证存储的响应。

### 4.1. Calculating Cache Keys with the Vary Header Field

当缓存接收到一个可以被存储的响应满足的请求并且存储的响应包含一个 Vary 头字段（[ HTTP ]的第 12.5.5 节）时，缓存不得在没有重新验证的情况下使用存储的响应，除非所有呈现的请求头由该 Vary 字段值指定的字段与原始请求中的那些字段匹配（即导致缓存响应被存储的请求）。

当且仅当第一个请求中的头字段可以通过应用以下任何一项转换为第二个请求中的头字段时，两个请求的头字段被定义为匹配：

- 在标头字段语法允许的地方添加或删除空格
- 将多个标题字段行与相同的字段名称组合在一起（参见[ HTTP ]的第 5.2 节）
- 根据标头字段的规范，以已知具有相同语义的方式规范化两个标头字段值（例如，当顺序不重要时重新排序字段值；大小写规范化，其中值被定义为不区分大小写）

如果（在可能发生的任何规范化之后）请求中缺少标头字段，则它只能匹配另一个请求，如果它也不存在。

具有包含成员“*”的 Vary 标头字段值的存储响应始终无法匹配。

如果多个存储的响应匹配，缓存将需要选择一个来使用。当一个指定的请求头字段有一个已知的优先排序机制（例如，接受和类似的请求头字段上的 qvalues），该机制可以用来选择一个首选响应。如果这样的机制不可用，或导致同样优选的响应，则根据第 4 节选择最近的响应（由 Date 标头字段确定）。

一些资源错误地从它们的默认响应中省略了 Vary 标头字段（即，当请求未表达任何偏好时发送的那个），即使有更优选的响应可用，也会为对该资源的后续请求选择它。当缓存有多个针对目标 URI 的存储响应并且一个或多个省略 Vary 头字段时，缓存应该选择最近（参见第 4.2.3 节）存储的具有有效 Vary 字段值的响应。

如果没有存储的响应匹配，则缓存不能满足呈现的请求。通常，请求被转发到源服务器，可能会添加前提条件来描述缓存已经存储了哪些响应（第 4.3 节）。

### 4.2. Freshness

“fresh” 响应是其年龄尚未超过其新鲜度寿命的响应。相反，“stale” 的响应是它已经存在的响应。

响应的“新鲜度生命周期”是源服务器生成它和它的过期时间之间的时间长度。“显式过期时间”是源服务器打算在没有进一步验证的情况下缓存不再使用存储的响应的时间，而“启发式过期时间”是在没有显式过期时间可用时由缓存分配的.

响应的 “age” 是自它由源服务器生成或成功验证以来经过的时间。

当一个响应是新鲜的时，它可以用来满足后续的请求，而无需联系源服务器，从而提高效率。

确定新鲜度的主要机制是源服务器使用Expires标头字段（第 5.3 节）或 max-age 响应指令（第 5.2.2.1 节） 在未来提供明确的过期时间 。通常，源服务器会为响应分配未来的显式过期时间，因为相信在达到过期时间之前，表示不太可能以语义上重要的方式发生变化。

如果源服务器希望强制缓存验证每个请求，它可以分配一个明确的过期时间以指示响应已经过时。合规缓存通常会在为后续请求重新使用之前验证陈旧的缓存响应（请参阅第 4.2.4 节）。

由于原始服务器并不总是提供明确的过期时间，因此还允许缓存在某些情况下使用试探法来确定过期时间（请参阅第4.2.2 节）。

确定响应是否新鲜的计算是：

```
   response_is_fresh = (freshness_lifetime > current_age)
```

freshness_lifetime 在第 4.2.1 节 中定义；current_age 在第 4.2.3 节中定义 。

客户端可以发送 max-age 或 min-fresh 请求指令（第 5.2.1 节）以建议限制相应响应的新鲜度计算。但是，不需要缓存来兑现它们。

计算新鲜度时，避免日期解析中的常见问题：

- 尽管所有日期格式都指定为区分大小写，但缓存接收者应该不区分大小写地匹配字段值。
- 如果缓存接收者的内部时间实现比 HTTP 日期的值分辨率低，则接收者必须在内部将解析过期日期 表示为等于或早于接收值的最近时间。
- 缓存接收者不得允许本地时区影响年龄或过期时间的计算或比较。
- 缓存接收者应该将带有“GMT”以外的时区缩写的日期视为无效计算过期时间。

请注意，新鲜度仅适用于缓存操作；它不能用于强制用户代理刷新其显示或重新加载资源。请参阅第 6 节以了解缓存和历史机制之间的区别。

#### 4.2.1. Calculating Freshness Lifetime

缓存可以通过评估以下规则并使用第一个匹配项来计算响应的新鲜度生命周期（表示为 freshness_lifetime）：

- 如果缓存是共享的并且存在s-maxage 响应指令（第 5.2.2.10 节），则使用它的值，或者
- 如果最大年龄响应指令（第 5.2.2.1 节）存在，则使用它的值，或者
- 如果存在Expires响应标头字段（第 5.3 节），则使用其值减去 Date 响应标头字段的值（如果不存在，则使用收到消息的时间，根据 [HTTP]的第6.6.1节） , 或
- 否则，响应中不存在明确的过期时间。启发式新鲜度生命周期可能适用；参见第 4.2.2 节。

请注意，此计算旨在通过尽可能使用源服务器提供的时钟信息来减少时钟偏差。

当给定指令存在多个值时（例如，两个 Expires标头字段行或多个 Cache-Control：max-age 指令），应使用第一个出现的值或应将响应视为陈旧。如果指令发生冲突（例如，同时存在 max-age 和 no-cache），则应遵循最严格的指令。鼓励缓存将具有无效新鲜度信息（例如，具有非整数内容的 max-age 指令）的响应视为过时的。

#### 4.2.2. Calculating Heuristic Freshness

由于源服务器并不总是提供明确的过期时间，缓存可以在未指定明确时间时分配启发式过期时间，采用使用其他字段值（例如上次修改时间）的算法来估计合理的过期时间。本规范不提供具体算法，但确实对其结果施加了最坏情况约束。

当存储的响应中存在明确的过期时间时， 缓存不得使用启发式方法来确定新鲜度。由于第 3 节中的要求，启发式只能用于没有明确新鲜度的响应，其状态代码被定义为“启发式缓存”（例如，参见 [ HTTP ]的第 15.1 节）以及没有明确新鲜度的响应被标记为显式可缓存（例如，使用公共响应指令）。

请注意，在以前的规范中，启发式可缓存响应状态代码称为“默认可缓存”。

如果响应具有 Last-Modified 标头字段（[ HTTP ]的第 8.8.2 节），则鼓励缓存使用不超过自该时间以来间隔的某个分数的启发式过期值。此分数的典型设置可能是 10%。

> 注意： 以前版本的 HTTP 规范（[ RFC2616 ]的第 13.9 节）禁止缓存计算具有查询组件（即包含“?”的 URI）的启发式新鲜度。在实践中，这并没有得到广泛实施。因此，如果原始服务器希望阻止缓存，则鼓励它们发送显式指令（例如，Cache-Control：no-cache）。

#### 4.2.3. Calculating Age

Age 报头字段用于传达从缓存中获取的响应消息的估计年龄。Age 字段值是缓存对自源服务器生成或验证响应以来的秒数的估计。因此，Age 值是响应从原始服务器沿路径驻留在每个缓存中的时间加上它沿网络路径传输的时间的总和。

年龄计算使用以下数据：

- "age_value": 术语“age_value”以适合算术运算的形式表示年龄 头字段（第 5.1 节） 的值；或 0，如果不可用。
- "date_value": 术语“date_value”以适合算术运算的形式表示日期头字段的值。请参阅[ HTTP ]的第 6.6.1 节以了解 Date 标头字段的定义以及有关没有它的响应的要求。
- "now": 术语“now”表示此实现时钟的当前值（[ HTTP ]的第 5.6.7 节）。
- "request_time": 导致存储响应的请求时的时钟值。
- "response_time": 收到响应时的时钟值。

响应的年龄可以通过两种完全独立的方式计算：

1. “apparent_age”：response_time 减去 date_value，如果实现的时钟与源服务器的时钟同步得相当好。如果结果为负，则将结果替换为零。
2. “corrected_age_value”，如果响应路径上的所有缓存都实现 HTTP/1.1 或更高版本。缓存必须相对于发起请求的时间来解释此值，而不是接收响应的时间。

```
  apparent_age = max(0, response_time - date_value);

  response_delay = response_time - request_time;
  corrected_age_value = age_value + response_delay;
```

corrected_age_value可以用作 corrected_initial_age。在存在可能无法正确插入Age 的非常旧的缓存实现的情况下，可以更保守地计算 corrected_initial_age 为

```
  corrected_initial_age = max(apparent_age, corrected_age_value);
```

存储响应的 current_age 然后可以通过将自存储响应上次由源服务器验证以来的时间（以秒为单位）与 corrected_initial_age 相加来计算。

```
  resident_time = now - response_time;
  current_age = corrected_initial_age + resident_time;
```

#### 4.2.4. Serving Stale Responses

“stale” 响应是具有明确的到期信息或允许计算启发式到期但根据第 4.2 节 中的计算不是新鲜的响应。

如果缓存被明确的协议内指令禁止（例如，通过无缓存响应指令、必须重新验证响应指令或适用的 s-maxage 或代理重新验证响应指令；参见第 5.2.2 节）。

缓存不得生成陈旧的响应，除非它断开连接或客户端或源服务器明确允许这样做（例如，通过第 5.2.1 节中的 max-stale 请求指令，扩展指令如[ RFC5861 ]中定义的那些） ，或根据带外合同进行配置）。

### 4.3. Validation

当缓存存储了一个或多个针对请求的 URI 的响应，但不能提供其中任何一个（例如，因为它们不新鲜，或者无法选择一个；参见第 4.1 节），它可以使用条件请求机制（第13节） [ HTTP ] ) 在转发的请求中给下一个入站服务器一个机会来选择一个有效的存储响应来使用，更新过程中存储的元数据，或者用新的响应替换存储的响应。此过程称为“验证”或“重新验证”存储的响应。

#### 4.3.1. Sending a Validating Request

当生成条件验证请求时，缓存要么从它试图满足的请求开始，要么——如果它独立发起请求——通过复制方法、目标 URI 和请求标头使用存储的响应合成请求由 Vary 标头字段（第 4.1 节）标识的字段。

然后它使用一个或多个前提条件标头字段更新该请求。它们包含来自具有相同 URI 的存储响应的验证器元数据。通常，这将仅包括具有相同缓存键的存储响应，尽管允许缓存验证它无法使用其发送的请求标头字段选择的响应（请参阅第 4.1 节）。

然后接收者比较前置条件报头字段以确定任何存储的响应是否等同于资源的当前表示。

一个这样的验证器是 Last-Modified 标头字段（ [ HTTP ]的第 8.8.2 节） 中给出的时间戳，它可以在 If-Modified-Since 标头字段中用于响应验证，或在 If-Unmodified-Since 中使用或用于表示选择的 If-Range 标头字段（即，客户端专门指代具有该时间戳的先前获得的表示）。

另一个验证器是 ETag 字段中给出的实体标签（[ HTTP ]的第 8.8.3 节）。一个或多个实体标签，指示一个或多个存储的响应，可以在 If-None-Match 头字段中用于响应验证，或在 If-Match 或 If-Range 头字段中用于表示选择（即，客户端是具体指一个或多个先前获得的具有所列实体标签的表示）。

当生成条件验证请求时，缓存：

- 如果在正在验证的存储响应中提供了实体标签，则必须发送相关的实体标签（使用 If-Match、If-None-Match 或 If-Range）。
- 如果请求不是针对子范围的，应该发送 Last-Modified 值（使用 If-Modified-Since），正在验证单个存储的响应，并且该响应包含 Last-Modified 值。
- 如果请求是针对子范围的，则可以发送 Last-Modified 值（使用 If-Unmodified-Since 或 If-Range），正在验证单个存储的响应，并且该响应仅包含 Last-Modified 值（不是实体标签） ).

在大多数情况下，两个验证器都是在缓存验证请求中生成的，即使实体标签明显更优越，以允许不了解实体标签前提条件的旧中介做出适当的响应。

#### 4.3.2. Handling a Received Validation Request

请求链中的每个客户端都可能有自己的缓存，因此中介的缓存通常会从其他（出站）缓存接收条件请求。同样，一些用户代理使用条件请求来限制数据传输到最近修改的表示或完成部分检索表示的传输。

如果缓存收到的请求可以通过重用存储的 200（OK）或 206（部分内容）响应来满足，根据第 4 节，缓存应该评估在该请求中接收到的任何适用的条件头字段先决条件相对于相应的存储响应中包含的验证器。

缓存不得评估仅适用于源服务器的条件标头字段，出现在具有缓存响应无法满足的语义的请求中，或者出现在目标资源没有存储响应的请求中；此类先决条件可能适用于某些其他（入站）服务器。

缓存对条件请求的正确评估取决于接收到的前提条件头字段及其优先级。总之，If-Match 和 If-Unmodified-Since 条件头字段不适用于缓存，If-None-Match 优先于 If-Modified-Since。有关先决条件优先级的完整规范，请参阅[ HTTP ]的第 13.2.2 节。

包含 If-None-Match 标头字段（ [ HTTP ]的第 13.1.2 节） 的请求表明客户端想要验证一个或多个自己存储的响应与缓存选择的存储响应（根据第4 ).

如果不存在 If-None-Match 标头字段，则包含 If-Modified-Since 标头字段的请求（[ HTTP ]的第 13.1.3 节）表明客户端想要通过以下方式验证一个或多个自己存储的响应修改日期。

如果一个请求包含一个 If-Modified-Since 头字段并且 Last-Modified 头字段不存在于存储的响应中，缓存应该使用存储的响应的 Date 字段值（或者，如果没有 Date 字段存在，则时间收到存储的响应）来评估条件。

实现对范围请求的部分响应的缓存，如 [ HTTP ]的第 14.2 节中所定义，还需要根据缓存的选择响应评估接收到的 If-Range 标头字段（[ HTTP ]的第 13.1.5 节）。

当一个缓存决定转发一个请求来重新验证它自己存储的包含实体标签 If-None-Match 列表的请求的响应时，缓存可以将接收到的列表与它自己存储的响应集中的实体标签列表组合起来（新鲜的或陈旧的）并发送两个列表的联合作为转发请求中的替换 If-None-Match 标头字段值。如果存储的响应仅包含部分内容，则缓存不得在联合中包含其实体标记，除非请求的范围可以被该部分存储的响应完全满足。如果对转发请求的响应是 304（Not Modified）并且有一个 ETag 字段值带有不在客户端列表中的实体标签，缓存必须 通过重用其相应的存储响应为客户端生成 200 (OK) 响应，由 304 响应元数据更新（第 4.3.4 节）。

#### 4.3.3. Handling a Validation Response

对条件请求的响应的缓存处理取决于其状态代码：

- 304（未修改）响应状态代码表示存储的响应可以更新和重用；参见第 4.3.4 节。
- 完整响应（即包含内容的响应）表示条件请求中指定的存储响应均不合适。相反，缓存必须使用完整的响应来满足请求。缓存可以存储这样一个完整的响应，受其约束（见第 3 节）。
- 但是，如果缓存在尝试验证响应时收到 5xx（服务器错误）响应，它可以将此响应转发给请求客户端，或者就好像服务器未能响应一样。在后一种情况下，缓存可以发送先前存储的响应，但要遵守这样做的限制（参见第 4.2.4 节），或者重试验证请求。

#### 4.3.4. Freshening Stored Responseds upon Validation

当缓存收到 304（未修改）响应时，它需要识别适合使用提供的新信息更新的存储响应，然后执行此操作。

要更新的初始存储响应集是那些可以为该请求选择的响应——即满足第 4节中要求的响应，除了最后一个要求是新鲜的、能够提供陈旧的或只是经过验证的。

然后，最初的一组存储响应被第一个匹配项进一步过滤：

- 如果新响应包含一个或多个“强验证器”（请参阅​​ [ HTTP ]的第 8.8.1 节），那么这些强验证器中的每一个都会标识一个选定的表示以进行更新。初始集中所有存储的响应都被识别为更新。如果初始集合中没有一个包含至少一个相同的强验证器，则缓存不得使用新响应来更新任何存储的响应。
- 如果新响应不包含强验证器但确实包含一个或多个“弱验证器”，并且这些验证器对应于初始集合的存储响应之一，则识别那些匹配的存储响应中的最新响应以进行更新。
- 如果新响应不包含任何形式的验证器（例如客户端从 Last-Modified 响应标头字段以外的来源生成 If-Modified-Since 请求），并且初始集中只有一个存储的响应，并且存储的响应也缺少验证器，然后识别存储的响应以进行更新。

对于每个已识别的存储响应，缓存必须按照第 3.2 节使用 304（未修改）响应中提供的标头字段更新其标头字段。

#### 4.3.5. Freshening Responses with HEAD

对 HEAD 方法的响应与使用 GET 发出的等效请求相同，但不发送内容。如果更有效的条件 GET 请求机制不可用（由于存储的响应中不存在验证器）或者如果不希望传输内容，则 HEAD 响应的此属性可用于使缓存的 GET 响应无效或更新它已经改变了。

当缓存为目标 URI 发出入站 HEAD 请求并收到 200（OK）响应时，缓存应该更新或使它存储的每个可能为该请求选择的 GET 响应无效（参见第 4.1 节）。

对于每个可能已被选择的存储响应，如果存储响应和 HEAD 响应对于任何接收到的验证器字段（ETag 和 Last-Modified）具有匹配值，并且如果 HEAD 响应具有 Content-Length 标头字段，则该值Content-Length 与存储的响应相匹配，缓存应该更新存储的响应，如下所述；否则，缓存应该认为存储的响应是陈旧的。

如果缓存使用 HEAD 响应中提供的元数据更新存储的响应，则缓存必须使用 HEAD 响应中提供的标头字段来更新存储的响应（参见第 3.2 节）。

### 4.4. Invalidating Stored Responses

因为不安全的请求方法（[ HTTP ]的第 9.2.1 节）如 PUT、POST 或 DELETE 有可能改变源服务器上的状态，所以需要干预缓存来使存储的响应无效以保持它们的内容是最新的。

当缓存接收到非错误状态代码以响应不安全的请求方法（包括安全性未知的方法）时，缓存必须使目标 URI（ [ HTTP ]的第 7.1 节）无效。

当缓存接收到响应不安全请求方法（包括安全性未知的方法）的非错误状态代码时，缓存可以使其他 URI 无效。特别是，Location 和 Content-Location 响应标头字段（如果存在）中的 URI 是无效的候选者；其他 URI 可能会通过本文档中未指定的机制被发现。但是，如果要失效的 URI 的来源（ [ HTTP ]的第 4.3.1 节）与目标 URI 的来源（ [ HTTP ]的第 7.1 节）不同，缓存不得在这些条件下触发失效。这有助于防止拒绝服务攻击。

“无效”意味着缓存将删除所有存储的其目标 URI 与给定 URI 匹配的响应，或者将它们标记为“无效”并且需要强制验证才能发送以响应后续请求。

“非错误响应”是带有 2xx（成功）或 3xx（重定向）状态代码的响应。

请注意，这并不能保证所有适当的响应都在全局范围内失效；状态更改请求只会使它经过的缓存中的响应无效。

## 5. Field Deinitions

本节定义了与缓存相关的 HTTP 字段的语法和语义。

### 5.1. Age

"Age" 响应头字段传达了发送方对自响应生成或在源服务器成功验证以来的时间估计。年龄值按照第 4.2.3 节中的规定计算。

```
  Age = delta-seconds
```

Age 字段值是一个非负整数，表示以秒为单位的时间（参见第 1.2.2 节）。

尽管它被定义为单例头字段，但是遇到具有基于列表的 Age 字段值的消息的缓存应该使用字段值的第一个成员，丢弃后续的。

如果字段值（在丢弃额外的成员之后，按照上面的方法）是无效的（例如，它包含非负整数以外的东西），缓存应该忽略该字段。

Age 标头字段的存在意味着响应不是由原始服务器为此请求生成或验证的。但是，缺少 Age 标头字段并不意味着联系了来源。

### 5.2. Cache-Control

"Cache-Control" 头字段用于列出请求/响应链中缓存的指令。缓存指令是单向的，因为请求中存在指令并不意味着响应中存在或复制了相同的指令。

有关如何处理别处定义的 Cache-Control 指令的信息，请参阅第 5.2.3 节。

代理，无论它是否实现缓存，都必须在转发的消息中传递缓存指令，无论它们对该应用程序的重要性如何，因为这些指令可能适用于请求/响应链上的所有接收者。不可能将指令定位到特定缓存。

缓存指令由标记标识，不区分大小写地进行比较，并且有一个可选参数，可以使用标记和引号字符串语法。对于下面定义参数的指令，接收者应该接受这两种形式，即使生成需要特定的形式。

```
  Cache-Control   = #cache-directive

  cache-directive = token [ "=" ( token / quoted-string ) ]
```

对于下面定义的缓存指令，除非另有说明，否则未定义（也不允许）任何参数。

#### 5.2.1. Request Directives

本节定义缓存请求指令。他们是建议性的；缓存可以实现它们，但不是必须的。

##### 5.2.1.1. max-age

Argument syntax:

```
delta-seconds (see Section 1.2.2)
```

max-age 请求指令指示客户端更喜欢年龄小于或等于指定秒数的响应。除非 max-stale 请求指令也存在，否则客户端不希望收到过时的响应。

该指令使用参数语法的记号形式：例如，'max-age=5' 而不是'max-age="5"'。发件人不得生成带引号的字符串形式。

##### 5.2.1.2. max-stale

Argument syntax:

```
delta-seconds (see Section 1.2.2)
```

max-stale 请求指令指示客户端将接受已超过其新鲜度生命周期的响应。如果存在一个值，则客户端愿意接受超出其新鲜度生命周期不超过指定秒数的响应。如果没有为 max-stale 分配值，那么客户端将接受任何年龄的陈旧响应。

该指令使用参数语法的记号形式：例如，'max-stale=10' 而不是'max-stale="10"'。发件人不得生成带引号的字符串形式。

##### 5.2.1.3. min-fresh

Argument syntax:

```
delta-seconds (see Section 1.2.2)
```

min-fresh 请求指令指示客户端更喜欢其新鲜度生命周期不小于其当前年龄加上指定时间（以秒为单位）的响应。也就是说，客户端希望响应至少在指定的秒数内仍然是新鲜的。

该指令使用参数语法的标记形式：例如，'min-fresh=20' 而不是 'min-fresh="20"'。发件人不得生成带引号的字符串形式。

##### 5.2.1.4. no-cache

no-cache 请求指令指示客户端不希望在未在源服务器上成功验证的情况下使用存储的响应来满足请求。

##### 5.2.1.5. no-store

no-store 请求指令指示缓存不得存储此请求或对它的任何响应的任何部分。该指令适用于私有和共享缓存。“不得存储”在此上下文中意味着缓存不得有意将信息存储在非易失性存储中，并且必须尽最大努力在转发信息后尽快从易失性存储中删除信息。

该指令不是确保隐私的可靠或充分的机制。特别是，恶意或受损的缓存可能无法识别或遵守此指令，并且通信网络可能容易受到窃听。

请注意，如果缓存中包含此指令的请求得到满足，则 no-store 请求指令不适用于已存储的响应。

##### 5.2.1.6. no-transform

no-transform 请求指令表示客户端正在请求中介以避免转换内容，如 [ HTTP ] 的第 7.7 节中所定义。

##### 5.2.1.7. only-if-cached

only-if-cached 请求指令指示客户端只希望获得存储的响应。接受这个请求指令的缓存应该，在接收到它时，响应一个与请求的其他约束一致的存储响应或一个 504（Gateway Timeout）状态代码。

#### 5.2.2. Response Directives

本节定义缓存响应指令。缓存必须遵守本节中定义的缓存控制指令。

##### 5.2.2.1. max-age

Argument syntax:

```
delta-seconds (see Section 1.2.2)
```

max-age 响应指令指示响应在其年龄大于指定的秒数后将被视为过时。

该指令使用参数语法的记号形式：例如，'max-age=5' 而不是'max-age="5"'。发件人不得生成带引号的字符串形式。

##### 5.2.2.2. must-revalidate

must-revalidate response 指令指示一旦响应变得陈旧，缓存不得重用该响应来满足另一个请求，直到它已被源成功验证，如第4.3 节所定义。

must-revalidate 指令对于支持某些协议功能的可靠操作是必需的。在所有情况下，缓存不得忽略 must-revalidate 指令；特别是，如果缓存断开连接，缓存必须生成错误响应而不是重用陈旧的响应。生成的状态代码应该是 504（Gateway timeout），除非另一个错误状态代码更适用。

must-revalidate 指令应该由服务器使用，当且仅当未能验证请求可能导致不正确的操作时，例如静默未执行的金融交易。

must-revalidate 指令还允许共享缓存重用对包含 Authorization 标头字段的请求的响应（[ HTTP ]的第 11.6.2 节），服从上述重新验证的要求（第 3.5 节）。

##### 5.2.2.3. must-understand

must-understand response 指令将响应的缓存限制在理解并符合该响应状态代码要求的缓存中。

包含 must-understand 指令的响应也应该 包含 no-store 指令。当实现 must-understand 指令的缓存接收到包含它的响应时，如果缓存理解并实现状态代码的缓存要求，它应该忽略 no-store 指令。

##### 5.2.2.4. no-cache

Argument syntax:
```
#field-name
```

无缓存响应指令以其非限定形式（没有参数）表示响应不得用于满足任何其他请求，除非转发它进行验证并接收到成功的响应；参见第 4.3 节。

这允许源服务器阻止缓存使用响应来满足请求而不联系它，即使缓存已配置为发送过时的响应也是如此。

无缓存响应指令的限定形式，带有一个列出一个或多个字段名称的参数，表示缓存可以使用响应来满足后续请求，如果列出的头字段是从后续响应中排除或后续响应已成功与原始服务器重新验证（更新或删除这些字段）。这允许源服务器防止在响应中重复使用某些标头字段，同时仍然允许缓存响应的其余部分。

给出的字段名称不限于本规范定义的头字段集。字段名称不区分大小写。

该指令使用引号字符串形式的参数语法。发件人不应该生成令牌表单（即使单项列表似乎不需要引用）。

注意：指令的限定形式通常由缓存处理，就像接收到非限定的 no-cache 指令一样；也就是说，对合格表格的特殊处理并未得到广泛实施。

##### 5.2.2.5. no-store

no-store response 指令指示缓存不得存储即时请求或响应的任何部分，并且不得使用响应来满足任何其他请求。

该指令适用于私有和共享缓存。“不得存储”在此上下文中意味着缓存不得有意将信息存储在非易失性存储中，并且必须尽最大努力在转发信息后尽快从易失性存储中删除信息。

该指令不是确保隐私的可靠或充分的机制。特别是，恶意或受损的缓存可能无法识别或遵守此指令，并且通信网络可能容易受到窃听。

请注意，必须理解的缓存指令在某些情况下会覆盖 no-store；参见第 5.2.2.3 节。

##### 5.2.2.6. no-transform

no-transform 响应指令指示中介（无论它是否实现缓存）不得转换内容，如[ HTTP ]的第 7.7 节中所定义。

##### 5.2.2.7. private

Argument syntax:

```
#field-name
```

非限定私有响应指令指示共享缓存不得存储响应（即，响应旨在用于单个用户）。它还表明私有缓存可以存储响应，服从第 3 节中定义的约束，即使响应不会以其他方式被私有缓存启发式缓存。

如果存在限定的私有响应指令，并带有列出一个或多个字段名称的参数，则仅列出的标头字段仅限于单个用户：共享缓存不得存储列出的标头字段，如果它们存在于原始响应，但可以存储响应消息的其余部分，不带这些头字段，受第 3 节中定义的约束的约束。

给出的字段名称不限于本规范定义的头字段集。字段名称不区分大小写。

该指令使用引号字符串形式的参数语法。发件人不应该生成令牌表单（即使单项列表似乎不需要引用）。

> 注意： “私有”一词的这种用法仅控制可以存储响应的位置；它不能确保消息内容的隐私。此外，指令的限定形式通常由缓存处理，就好像接收到不合格的私有指令一样；也就是说，对合格表格的特殊处理并未得到广泛实施。

##### 5.2.2.8. proxy-revalidate

proxy-revalidate 响应指令指示一旦响应变得陈旧，共享缓存不得重用该响应来满足另一个请求，直到它已被源成功验证，如第4.3 节所定义。这类似于 must-revalidate（第 5.2.2.2 节），除了 proxy-revalidate 不适用于私有缓存。

请注意，proxy-revalidate 本身并不意味着响应是可缓存的。例如，它可能与 public 指令（第 5.2.2.9 节）结合使用，允许缓存响应，同时只需要共享缓存在过时时重新生效。

##### 5.2.2.9. public

公共响应指令指示缓存可以存储响应，即使它会被禁止，但要遵守第 3 节中定义的约束。换句话说，public 明确地将响应标记为可缓存。例如，public 允许共享缓存重用对包含 Authorization 标头字段（第 3.5 节）的请求的响应。

请注意，根据第 3 节 ，没有必要将 public 指令添加到已经可缓存的响应中。

如果带有 public 指令的响应没有明确的新鲜度信息，则它是启发式可缓存的（第 4.2.2 节）。

##### 5.2.2.10. s-maxage

Argument syntax:

```
delta-seconds (see Section 1.2.2)
```

s-maxage 响应指令指示，对于共享缓存，此指令指定的最大期限覆盖 max-age 指令或 Expires标 头字段指定的最大期限。

s-maxage 指令合并了共享缓存的代理重新验证响应指令（第 5.2.2.8 节） 的语义。共享缓存不得重复使用带有 s-maxage 的陈旧响应来满足另一个请求，直到它已被源成功验证，如第4.3 节所定义。该指令还允许共享缓存重用对包含 Authorization 标头字段的请求的响应，但要遵守上述关于最长期限和重新验证的要求（第3.5 节）。

该指令使用参数语法的标记形式：例如，'s-maxage=10' 而不是 's-maxage="10"'。发件人不得生成带引号的字符串形式。

#### 5.2.3. Extension Directives

Cache-Control 头字段可以通过使用一个或多个扩展缓存指令来扩展。缓存必须忽略无法识别的缓存指令。

可以在不更改其他指令语义的情况下添加信息扩展（那些不需要更改缓存行为的扩展）。

行为扩展旨在通过充当现有缓存指令基础的修饰符来工作。提供了新指令和旧指令，这样不理解新指令的应用程序将默认执行旧指令指定的行为，而理解新指令的应用程序会将其识别为修改与旧指令相关的要求指示。通过这种方式，可以在不破坏已部署缓存的情况下对现有缓存指令进行扩展。

例如，考虑一个名为“community”的假设新响应指令，它充当私有指令的修饰符：除了私有缓存之外，只允许指定社区成员共享的缓存缓存响应。希望允许 UCI 社区在其共享缓存中使用其他私有响应的源服务器可以通过包含:

```
Cache-Control: private, community="UCI"
```

识别此类社区缓存指令的缓存可以根据该扩展扩展其行为。不识别社区缓存指令的缓存将忽略它并遵守私有指令。

新的扩展指令应该考虑定义：

- 多次指定一个指令意味着什么，
- 当指令不接受参数时，参数存在时意味着什么，
- 当指令需要一个参数时，缺少它意味着什么，以及
- 该指令是特定于请求、特定于响应还是能够在其中任何一个中使用。

#### 5.2.4. Cache Directive Registry

The "Hypertext Transfer Protocol (HTTP) Cache Directive Registry" defines the namespace for the cache directives. It has been created and is now maintained at <https://www.iana.org/assignments/http-cache-directives>.

A registration MUST include the following fields:

- Cache Directive Name
- Pointer to specification text

Values to be added to this namespace require IETF Review (see [RFC8126], Section 4.8).

### 5.3. Expires

“Expires”响应头字段给出响应被认为过时的日期/时间。有关新鲜度模型的进一步讨论，请参阅第 4.2 节。

Expires 头字段的存在并不意味着原始资源将在该时间、之前或之后更改或停止存在。

Expires 字段值是一个 HTTP 日期时间戳，如[ HTTP ]的第 5.6.7 节中所定义。另请参阅第 4.2 节以了解特定于缓存的解析要求。

```
  Expires = HTTP-date
```

例如

```
Expires: Thu, 01 Dec 1994 16:00:00 GMT
```

缓存接收者必须解释无效的日期格式，尤其是值“0”，表示过去的时间（即“已经过期”）。

如果响应包含带有 max-age 指令的Cache-Control头字段（第 5.2.2.1 节），则接收者必须忽略 Expires 头字段。同样，如果响应包含 s-maxage 指令（第 5.2.2.10 节），共享缓存接收者必须忽略 Expires 标头字段。在这两种情况下，Expires 中的值仅适用于尚未实现 Cache-Control 标头字段的接收者。

没有时钟的源服务器（[ HTTP ]的第 5.6.7 节） 不得生成 Expires 标头字段，除非它的值表示过去的固定时间（总是过期）或者它的值已通过具有以下功能的系统与资源相关联一个钟。

从历史上看，HTTP 要求 Expires 字段值不超过未来一年。虽然不再禁止更长的新鲜度生命周期，但已证明极大的值会导致问题（例如，由于使用 32 位整数作为时间值而导致时钟溢出），并且许多缓存会比这更早地驱逐响应。

### 5.4. Pragma

“Pragma”请求标头字段是为 HTTP/1.0 缓存定义的，因此客户端可以指定“无缓存”请求（因为Cache-Control直到 HTTP/1.1 才定义）。

但是，对 Cache-Control 的支持现在很普遍。因此，本规范弃用了 Pragma。

> 注意：由于从未指定响应中“Pragma: no-cache”的含义，因此它无法可靠地替代响应中的“Cache-Control: no-cache”。

### 5.5. Warning

“Warning”报头字段用于携带有关消息的状态或转换的附加信息，这些信息可能不会反映在状态代码中。该规范已将其废弃，因为它并未广泛生成或呈现给用户。它携带的信息可以通过检查其他标头字段（例如Age ）来收集。

## 6. Relationship to Applications and Other Caches

使用 HTTP 的应用程序通常会指定其他形式的缓存。例如，Web 浏览器通常具有诸如“后退”按钮之类的历史记录机制，可用于重新显示先前在会话中检索到的表示。

同样，一些 Web 浏览器在页面视图中实现图像和其他资产的缓存；他们可能会也可能不会遵守 HTTP 缓存语义。

本规范中的要求不一定适用于应用程序如何使用从 HTTP 缓存中检索到的数据。例如，历史机制可以显示以前的表示，即使它已经过期，应用程序可以以其他方式使用缓存的数据，超出其新鲜度生命周期。

本规范不禁止应用程序考虑 HTTP 缓存；例如，历史机制可能会告诉用户视图已过时，或者它可能会遵守缓存指令（例如，Cache-Control: no-store）。

然而，当一个应用程序缓存数据并且没有让用户明显或容易控制时，强烈建议根据 HTTP 缓存指令定义其操作，以免让希望缓存语义得到尊重的作者感到惊讶。例如，虽然在 HTTP“之上”定义一个应用程序缓存可能是合理的，它允许包含 Cache-Control: no-store 的响应被重用于与获取它的请求直接相关的请求（例如那些在相同的页面加载），如果允许它被重新用于与获取它的请求无关的请求，用户和作者可能会感到惊讶和困惑。
