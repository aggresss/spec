# TCP Congestion Control

> 原文 [https://datatracker.ietf.org/doc/html/rfc5681](https://datatracker.ietf.org/doc/html/rfc5681)

## 摘要

本文档定义了 TCP 的四种相互交织的拥塞控制算法：慢启动、避免拥塞、快速重传和快速恢复。此外，该文档规定了TCP在相对较长的空闲期后应如何开始传输，并讨论了各种确认生成方法。此文档废弃了RFC 2581。

## 1. Introduction

本文档规定了四种 TCP[RFC793] 拥塞控制算法：慢启动、避免拥塞、快速重传和快速恢复。这些算法是在 [Jac88] 和 [Jac90] 中设计的。它们与 TCP 的使用在 [RFC1122] 中进行了标准化。 [CJ89] 中给出了在加性增加、乘性减少拥塞控制方面的额外早期工作。

请注意，[Ste94] 提供了这些算法的示例，而 [WS95] 提供了对这些算法的 BSD 实现的源代码的解释。

除了指定这些拥塞控制算法外，本文档还指定了 TCP 连接在相对较长的空闲期后应该做什么，并指定和澄清了与 TCP ACK 生成有关的一些问题。

本文件废止了 [RFC2581]，而后者又废止了 [RFC2001]。

本文件的组织结构如下。第 2 节提供了将在整个文件中使用的各种定义。第 3 节提供了拥塞控制算法的规范。第 4 节概述了与拥塞控制算法相关的问题，最后，第 5 节概述了安全考虑因素。

## 2. Definitions

本节提供了几个术语的定义，这些术语将在本文件的其余部分中使用。

- **SEGMENT**：一个 SEGMENT 是任何 TCP/IP 数据或确认数据包（或两者兼有）。
- **SENDER MAXIMUM SEGMENT SIZE (SMSS)**：SMSS 是发件人可以发送的最大分段的大小。该值可以基于网络的最大传输单元、路径 MTU 发现 [RFC1191，RFC4821] 算法、RMSS（见下一项）或其他因素。大小不包括 TCP/IP 标头和选项。
- **RECEIVER MAXIMUM SEGMENT SIZE (RMSS)**：RMSS 是接收器愿意接受的最大分段的大小。这是接收器在连接启动期间发送的 MSS 选项中指定的值。或者，如果未使用 MSS 选项，则为 536 字节 [RFC1122]。大小不包括 TCP/IP 标头和选项。
- **FULL-SIZED SEGMENT**：包含允许的最大数据字节数的段（即，包含 SMSS 数据字节的段）。
- **RECEIVER WINDOW (rwnd)**：最近发布的接收器窗口。
- **CONGESTION WINDOW (cwnd)**：一个 TCP 状态变量，用于限制 TCP 可以发送的数据量。在任何给定时间，TCP 都不得发送序列号高于最高确认序列号与 cwnd 和 rwnd 最小值之和的数据。
- **INITIAL WINDOW (IW)**：初始窗口是三方握手完成后发送方拥塞窗口的大小。
- **LOSS WINDOW (LW)**：丢失窗口是 TCP 发送器使用其重传计时器检测到丢失后拥塞窗口的大小。
- **RESTART WINDOW (RW)**：重新启动窗口是TCP在空闲期后重新启动传输后的拥塞窗口的大小（如果使用慢启动算法；请参阅第4.1节了解更多讨论）。
- **FLIGHT SIZE**：已发送但尚未累计确认的数据量。
- **DUPLICATE ACKNOWLEDGMENT**：
  - (a) ACK 的接收器有未完成的数据
  - (b) 传入的确认没有携带数据
  - (c) SYN和FIN位都关闭时，确认被视为“重复”
  - (d) 确认号码等于在给定连接上接收到的最大确认（来自 [RFC793] 的 TCP.UNA），
  - (e) 传入确认中的通告窗口等于最后传入确认的通告窗口。或者，利用选择性确认（SACK）[RFC2018，RFC2883] 的 TCP 可以利用 SACK 信息来确定传入ACK何时是 “重复的”（例如，ACK 是否包含以前未知的 SACK 信息）。

## 3. Congestion Control Algorithms

本节定义了 [Jac88] 和 [Jac90] 中开发的四种拥塞控制算法：慢启动、拥塞避免、快速重传和快速恢复。在某些情况下，TCP 发送器比算法允许的更保守可能是有益的；但是，TCP 不得比以下算法允许的更激进（即，当以下算法计算的 cwnd 值不允许发送数据时，不得发送数据）。

此外，请注意，本文档中指定的算法将 丢包 用作拥塞信号。显式拥塞通知（ECN）也可以按照 [RFC3168] 中的规定使用。

### 3.1. Slow Start and Congestion Avoidance

TCP 发送器必须使用慢速启动和拥塞避免算法来控制注入网络的未处理数据量。为了实现这些算法，在 TCP 的每个连接状态中添加两个变量。拥塞窗口（cwnd）是发送方在接收到确认（ACK）之前可以向网络发送的数据量的限制，接收方的通告窗口（rwnd）是接收方对未完成数据量的极限。发送时使用 cwnd 和 rwnd 的最小值控制数据传输。

另一个状态变量，慢启动阈值（ssthresh），用于确定是否使用慢启动或拥塞避免算法来控制数据传输，如下所述。

在未知条件下开始传输到网络需要 TCP 缓慢地探测网络以确定可用容量，以避免不适当的大数据突发堵塞网络。慢启动算法在传输开始时或在修复由重传定时器检测到的丢失之后用于此目的。慢速启动还用于启动 TCP 发送器使用的 “ACK时钟”，以在慢速启动、拥塞避免和丢失恢复算法中将数据释放到网络中。

IW，cwnd的初始值，必须使用以下准则作为上限进行设置。

```
   If SMSS > 2190 bytes:
       IW = 2 * SMSS bytes and MUST NOT be more than 2 segments
   If (SMSS > 1095 bytes) and (SMSS <= 2190 bytes):
       IW = 3 * SMSS bytes and MUST NOT be more than 3 segments
   if SMSS <= 1095 bytes:
       IW = 4 * SMSS bytes and MUST NOT be more than 4 segments
```

根据 [RFC3390] 中的规定，SYN/ACK 和 SYN/ACK 的确认不得增加拥塞窗口的大小。此外，如果 SYN 或 SYN/ACK 丢失，则发送器在正确传输 SYN 之后使用的初始窗口必须是由最多 SMSS 字节组成的一个段。

[RFC3390] 中提供了 IW 设置的详细原理和讨论。

当一个以上分段的初始拥塞窗口与路径MTU发现 [RFC1191] 一起实现，并且发现正在使用的 MSS 太大时，应该减少拥塞窗口 cwnd，以防止较小分段的大突发。具体来说，cwnd 应该减少旧段大小与新段大小的比率。

ssthresh 的初始值应设置为任意高（例如，最大可能广告窗口的大小），但必须降低 ssthresh 以应对拥塞。设置尽可能高的 ssthresh 允许网络条件而不是某个任意的主机限制来决定发送速率。在终端系统对网络路径有充分了解的情况下，更仔细地设置初始 ssthresh 值可能有好处（例如，使得终端主机不会沿着路径产生拥塞）。

当 `cwnd < ssthresh` 时使用慢启动算法，而当 `cwnd > ssthresh` 使用拥塞避免算法。当 cwnd 和 ssthresh 相等时，发送方可以使用慢速启动或避免拥塞。

在缓慢启动期间，TCP 为接收到的每个累积确认新数据的 ACK 增加 cwnd 最多 SMSS 字节。当 cwnd 超过 ssthresh 时（或者，如上所述，可选地，当它达到它时）或者当观察到拥塞时，慢速启动结束。虽然传统的 TCP 实现在接收到覆盖新数据的 ACK 时会将 cwnd 精确地增加 SMSS 字节，但我们建议 TCP 实现增加 cwnd，根据：

```
   cwnd += min (N, SMSS)                      (2)
```

其中 N 是在传入 ACK 中确认的先前未确认字节的数目。这种调整是适当字节计数 [RFC3465] 的一部分，并提供了针对不当行为接收器的鲁棒性，不当行为接收器可能试图使用被称为 “ACK分割” [SCWA99] 的机制诱导发送器人为地膨胀 cwnd。ACK 分割由一个接收器组成，该接收器为单个 TCP 数据段发送多个 ACK，每个 ACK 只确认其数据的一部分。TCP 为每个这样的 ACK 增加 SMSS 的 cwnd 将不适当地增加注入网络的数据量。

在避免拥塞期间，cwnd 每往返时间增加大约 1 个完整大小的段（RTT）。拥塞避免一直持续到检测到拥塞为止。在避免拥塞期间增加 cwnd 的基本指南是：

- 可以将 cwnd 增加 SMSS 字节
- 应根据方程式（2）在每个 RTT 增加 cwnd 一次
- cwnd 的增量不得超过 SMSS 字节

我们注意到，在实验的基础上，[RFC3465] 允许在慢启动期间传入确认的 cwnd 增加超过 SMSS 字节；然而，这种行为是不允许作为标准的一部分。

建议在避免拥塞期间增加 cwnd 的方法是计算 ACK 为新数据确认的字节数。（此实现的缺点是需要维护一个额外的状态变量。）当确认的字节数达到 cwnd 时，cwnd 最多可以增加 SMSS 字节。请注意，在避免拥塞期间，cwnd 的增加量不得超过每个 RTT 的 SMSS 字节。这种方法既允许 TCP 在面对延迟的 ACK 时每个 RTT 将 cwnd 增加一个段，又提供了对抗 ACK-Division 攻击的鲁棒性。

等式（3）中给出了 TCP 在避免拥塞期间可以用来更新 cwnd 的另一个常见公式：

```
   cwnd += SMSS*SMSS/cwnd                     (3)
```

这种调整是在确认新数据的每个传入 ACK 上执行的。方程（3）为每 RTT 将cwnd 增加 1 个全尺寸段的基本原理提供了可接受的近似值。（请注意，对于接收器每隔一个数据包就确认一次的连接，（3）的攻击性低于允许的攻击性 —— 大约每秒钟 RTT 增加 cwnd。）

实现注意：由于 TCP 实现中通常使用整数运算，因此当拥塞窗口大于 SMS*SMSS 时，等式（3）中给出的公式可能无法增加 cwnd。如果上面的公式产生 0，则结果应四舍五入到 1 字节。

实现说明：旧的实现在等式（3）的右侧有一个额外的加法常数。这是不正确的，实际上会导致性能下降[RFC2525]。

实现说明：一些实现以字节为单位维护cwnd，而另一些实现以全尺寸段为单位。后者会发现等式（3）很难使用，可能更喜欢使用上一段中讨论的计数方法。

当 TCP 发送器使用重传计时器检测到段丢失，并且给定的段尚未通过重传计时器重新发送时，ssthresh 的值必须设置为不超过等式（4）中给定的值：

```
   ssthresh = max (FlightSize / 2, 2*SMSS)            (4)
```

其中，如上所述，FlightSize 是网络中未处理的数据量。

另一方面，当 TCP 发送器使用重传定时器检测到段丢失并且给定段已经通过重传定时器重传了至少一次时，ssthresh 的值保持恒定。

实现注意：一个容易犯的错误是简单地使用cwnd，而不是 FlightSize，在某些实现中，FlightSize 可能会意外地远远超过 rwnd。

此外，在超时时（如[RFC2988]中所述），cwnd 必须设置为不超过丢失窗口 LW，它等于 1 个完整大小的段（无论 IW 的值如何）。因此，在重传丢弃的分段之后，TCP 发送器使用慢启动算法将窗口从 1 个完整大小的分段增加到 ssthresh 的新值，在这一点上，拥塞避免再次接管。

如 [FF96] 和 [RFC3782] 所示，超时后缓慢的基于启动的丢失恢复可能会导致触发重复确认的虚假重传。TCP 实现中对这些重复 ACK 的到达的反应变化很大。本文件没有具体说明如何处理此类确认，但指出这是一个可能受益于额外关注、实验和规范的领域。

### 3.2. Fast Retransmit/Fast Recovery

当一个无序段到达时，TCP 接收器应该立即发送一个重复的ACK。该ACK的目的是通知发送者接收到的段是无序的，以及预期的序列号。从发送者的角度来看，重复的ACK可能是由许多网络问题引起的。首先，它们可能是由丢失的线段引起的。在这种情况下，丢弃的段之后的所有段都将触发重复的ACK，直到丢失得到修复。其次，重复的ACK可能是由网络对数据段的重新排序引起的（在一些网络路径上并非罕见事件[Pax97]）。最后，重复的ACK可能是由网络对ACK或数据段的复制引起的。此外，当传入段填充序列空间中的全部或部分间隙时，TCP接收器应该立即发送ACK。这将为发送方通过重传超时、快速重传或高级丢失恢复算法从丢失中恢复生成更及时的信息，如第4.3节所述。

TCP 发送器应该使用“快速重传”算法来检测和修复丢失，基于传入的重复ACK。快速重传算法使用3个重复ACK的到达（如第2节中所定义的，没有任何移动SND.UNA的中间ACK）作为段已经丢失的指示。在接收到3个重复ACK之后，TCP执行似乎是丢失段的重传，而不等待重传定时器到期。

在快速重传算法发送看似丢失的片段后，“快速恢复”算法控制新数据的传输，直到不重复的ACK到达。不执行缓慢启动的原因是，接收到重复的ACK不仅表明段已经丢失，而且表明段最有可能离开网络（尽管网络的大量段重复可能会使这一结论无效）。换句话说，由于接收器只能在分段到达时生成重复的ACK，因此该分段已经离开网络并在接收器的缓冲区中，因此我们知道它不再消耗网络资源。此外，由于保留了ACK“时钟”[Jac88]，TCP发送器可以继续发送新的分段（尽管传输必须使用减少的cwnd继续，因为丢失是拥塞的指示）。

快速重传和快速恢复算法一起实现如下。

1. 在发送器接收到的第一个和第二个重复ACK上，TCP应该根据[RFC3042]发送一段以前未发送的数据，前提是接收器的广告窗口允许，总FlightSize将保持小于或等于cwnd加2*SMSS，并且新数据可用于传输。此外，TCP发送器不得更改cwnd以反映这两个段[RFC3042]。请注意，使用SACK[RFC2018]的发送方不得发送新数据，除非传入的重复确认包含新的SACK信息。
2. 当接收到第三个重复ACK时，TCP必须将ssthresh设置为不大于等式（4）中给出的值。当使用[RFC3042]时，在有限传输中发送的附加数据不得包含在该计算中。
3. 必须重新传输从SND.UNA开始的丢失段，并将cwnd设置为ssthresh加3*SMSS。这人为地将拥塞窗口“膨胀”了已经离开网络并且接收器已经缓冲的段的数量（三个）。
4. 对于接收到的每个额外的重复ACK（在第三个之后），cwnd必须由SMSS递增。这人为地使拥塞窗口膨胀，以反映已经离开网络的附加段。
    > 注：[SCWA99]讨论了一种基于接收器的攻击，即向数据发送器发送许多伪造的重复ACK，以人为地夸大cwnd并导致使用高于适当的发送速率。因此，TCP可以将cwnd在丢失恢复期间被人为膨胀的次数限制为未处理段的数量（或其近似值）。

    > 注：当高级丢失恢复机制（如第4.3节所述）未使用时，FlightSize 的增加可能会导致方程（4）略微膨胀 cwnd 和 ssthresh，因为 SND.UNA 和 SND.NXT 之间的一些段被认为已经离开网络，但仍反映在 FlightSize 中。
5. 当先前未发送的数据可用并且cwnd的新值和接收器的广告窗口允许时，TCP应当发送先前未发送数据的 1*SMSS 字节。
6. 当确认先前未确认数据的下一个ACK到达时，TCP必须将cwnd设置为ssthresh（步骤2中设置的值）。这被称为“给窗户放气”。

该ACK应该是由步骤3的重传引起的确认，在重传后一个RTT（尽管在接收器处存在数据段的严重无序递送的情况下，它可能会更快到达）。此外，如果丢失的段和第三个重复ACK的接收之间没有丢失，则该ACK应当确认发送的所有中间段。

> 注：已知该算法通常不能有效地从单个数据包飞行中的多个丢失中恢复[FF96]。下文第4.3节论述了这种情况。

## 4. Additional Considerations


### 4.1. Restarting Idle Connections


### 4.2. Generating Acknowledgments


### 4.3. Loss Recovery Mechanisms

## 5. Security Considerations


## 6. Changes between RFC 2001 and RFC 2581


## 7. Changes Relative to RFC 2581
## 8. Acknowledgments

