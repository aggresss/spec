# TCP Congestion Control

> 原文 [https://datatracker.ietf.org/doc/html/rfc5681](https://datatracker.ietf.org/doc/html/rfc5681)

## 摘要

本文档定义了 TCP 的四种相互交织的拥塞控制算法：慢启动、避免拥塞、快速重传和快速恢复。此外，该文档规定了TCP在相对较长的空闲期后应如何开始传输，并讨论了各种确认生成方法。此文档废弃了RFC 2581。

## 1. Introduction

本文档规定了四种 TCP[RFC793] 拥塞控制算法：慢启动、避免拥塞、快速重传和快速恢复。这些算法是在 [Jac88] 和 [Jac90] 中设计的。它们与 TCP 的使用在 [RFC1122] 中进行了标准化。 [CJ89] 中给出了在加性增加、乘性减少拥塞控制方面的额外早期工作。

请注意，[Ste94] 提供了这些算法的示例，而 [WS95] 提供了对这些算法的 BSD 实现的源代码的解释。

除了指定这些拥塞控制算法外，本文档还指定了 TCP 连接在相对较长的空闲期后应该做什么，并指定和澄清了与 TCP ACK 生成有关的一些问题。

本文件废止了 [RFC2581]，而后者又废止了 [RFC2001]。

本文件的组织结构如下。第 2 节提供了将在整个文件中使用的各种定义。第 3 节提供了拥塞控制算法的规范。第 4 节概述了与拥塞控制算法相关的问题，最后，第 5 节概述了安全考虑因素。

## 2. Definitions

本节提供了几个术语的定义，这些术语将在本文件的其余部分中使用。

- **SEGMENT**：一个 SEGMENT 是任何 TCP/IP 数据或确认数据包（或两者兼有）。
- **SENDER MAXIMUM SEGMENT SIZE (SMSS)**：SMSS 是发件人可以发送的最大分段的大小。该值可以基于网络的最大传输单元、路径 MTU 发现 [RFC1191，RFC4821] 算法、RMSS（见下一项）或其他因素。大小不包括 TCP/IP 标头和选项。
- **RECEIVER MAXIMUM SEGMENT SIZE (RMSS)**：RMSS 是接收器愿意接受的最大分段的大小。这是接收器在连接启动期间发送的 MSS 选项中指定的值。或者，如果未使用 MSS 选项，则为 536 字节 [RFC1122]。大小不包括 TCP/IP 标头和选项。
- **FULL-SIZED SEGMENT**：包含允许的最大数据字节数的段（即，包含 SMSS 数据字节的段）。
- **RECEIVER WINDOW (rwnd)**：最近发布的接收器窗口。
- **CONGESTION WINDOW (cwnd)**：一个 TCP 状态变量，用于限制 TCP 可以发送的数据量。在任何给定时间，TCP 都不得发送序列号高于最高确认序列号与 cwnd 和 rwnd 最小值之和的数据。
- **INITIAL WINDOW (IW)**：初始窗口是三方握手完成后发送方拥塞窗口的大小。
- **LOSS WINDOW (LW)**：丢失窗口是 TCP 发送器使用其重传计时器检测到丢失后拥塞窗口的大小。
- **RESTART WINDOW (RW)**：重新启动窗口是TCP在空闲期后重新启动传输后的拥塞窗口的大小（如果使用慢启动算法；请参阅第4.1节了解更多讨论）。
- **FLIGHT SIZE**：已发送但尚未累计确认的数据量。
- **DUPLICATE ACKNOWLEDGMENT**：
  - (a) ACK 的接收器有未完成的数据
  - (b) 传入的确认没有携带数据
  - (c) SYN和FIN位都关闭时，确认被视为“重复”
  - (d) 确认号码等于在给定连接上接收到的最大确认（来自 [RFC793] 的 TCP.UNA），
  - (e) 传入确认中的通告窗口等于最后传入确认的通告窗口。或者，利用选择性确认（SACK）[RFC2018，RFC2883] 的 TCP 可以利用 SACK 信息来确定传入ACK何时是 “重复的”（例如，ACK 是否包含以前未知的 SACK 信息）。

## 3. Congestion Control Algorithms

本节定义了 [Jac88] 和 [Jac90] 中开发的四种拥塞控制算法：慢启动、拥塞避免、快速重传和快速恢复。在某些情况下，TCP 发送器比算法允许的更保守可能是有益的；但是，TCP 不得比以下算法允许的更激进（即，当以下算法计算的 cwnd 值不允许发送数据时，不得发送数据）。

此外，请注意，本文档中指定的算法将 丢包 用作拥塞信号。显式拥塞通知（ECN）也可以按照 [RFC3168] 中的规定使用。

### 3.1. Slow Start and Congestion Avoidance

TCP 发送器必须使用慢速启动和拥塞避免算法来控制注入网络的未处理数据量。为了实现这些算法，在 TCP 的每个连接状态中添加两个变量。拥塞窗口（cwnd）是发送方在接收到确认（ACK）之前可以向网络发送的数据量的限制，接收方的通告窗口（rwnd）是接收方对未完成数据量的极限。发送时使用 cwnd 和 rwnd 的最小值控制数据传输。

另一个状态变量，慢启动阈值（ssthresh），用于确定是否使用慢启动或拥塞避免算法来控制数据传输，如下所述。

在未知条件下开始传输到网络需要 TCP 缓慢地探测网络以确定可用容量，以避免不适当的大数据突发堵塞网络。慢启动算法在传输开始时或在修复由重传定时器检测到的丢失之后用于此目的。慢速启动还用于启动 TCP 发送器使用的 “ACK时钟”，以在慢速启动、拥塞避免和丢失恢复算法中将数据释放到网络中。

IW，cwnd的初始值，必须使用以下准则作为上限进行设置。

```
   If SMSS > 2190 bytes:
       IW = 2 * SMSS bytes and MUST NOT be more than 2 segments
   If (SMSS > 1095 bytes) and (SMSS <= 2190 bytes):
       IW = 3 * SMSS bytes and MUST NOT be more than 3 segments
   if SMSS <= 1095 bytes:
       IW = 4 * SMSS bytes and MUST NOT be more than 4 segments
```

根据 [RFC3390] 中的规定，SYN/ACK 和 SYN/ACK 的确认不得增加拥塞窗口的大小。此外，如果 SYN 或 SYN/ACK 丢失，则发送器在正确传输 SYN 之后使用的初始窗口必须是由最多 SMSS 字节组成的一个段。

[RFC3390] 中提供了 IW 设置的详细原理和讨论。

当一个以上分段的初始拥塞窗口与路径MTU发现 [RFC1191] 一起实现，并且发现正在使用的 MSS 太大时，应该减少拥塞窗口 cwnd，以防止较小分段的大突发。具体来说，cwnd 应该减少旧段大小与新段大小的比率。

ssthresh 的初始值应设置为任意高（例如，最大可能广告窗口的大小），但必须降低 ssthresh 以应对拥塞。设置尽可能高的 ssthresh 允许网络条件而不是某个任意的主机限制来决定发送速率。在终端系统对网络路径有充分了解的情况下，更仔细地设置初始 ssthresh 值可能有好处（例如，使得终端主机不会沿着路径产生拥塞）。

当 `cwnd < ssthresh` 时使用慢启动算法，而当 `cwnd > ssthresh` 使用拥塞避免算法。当 cwnd 和 ssthresh 相等时，发送方可以使用慢速启动或避免拥塞。

在缓慢启动期间，TCP 为接收到的每个累积确认新数据的 ACK 增加 cwnd 最多 SMSS 字节。当 cwnd 超过 ssthresh 时（或者，如上所述，可选地，当它达到它时）或者当观察到拥塞时，慢速启动结束。虽然传统的 TCP 实现在接收到覆盖新数据的 ACK 时会将 cwnd 精确地增加 SMSS 字节，但我们建议 TCP 实现增加 cwnd，根据：

```
   cwnd += min (N, SMSS)                      (2)
```

其中 N 是在传入 ACK 中确认的先前未确认字节的数目。这种调整是适当字节计数 [RFC3465] 的一部分，并提供了针对不当行为接收器的鲁棒性，不当行为接收器可能试图使用被称为 “ACK分割” [SCWA99] 的机制诱导发送器人为地膨胀 cwnd。ACK 分割由一个接收器组成，该接收器为单个 TCP 数据段发送多个 ACK，每个 ACK 只确认其数据的一部分。TCP 为每个这样的 ACK 增加 SMSS 的 cwnd 将不适当地增加注入网络的数据量。

在避免拥塞期间，cwnd 每往返时间增加大约 1 个完整大小的段（RTT）。拥塞避免一直持续到检测到拥塞为止。在避免拥塞期间增加 cwnd 的基本指南是：

- 可以将 cwnd 增加 SMSS 字节
- 应根据方程式（2）在每个 RTT 增加 cwnd 一次
- cwnd 的增量不得超过 SMSS 字节

我们注意到，在实验的基础上，[RFC3465] 允许在慢启动期间传入确认的 cwnd 增加超过 SMSS 字节；然而，这种行为是不允许作为标准的一部分。

建议在避免拥塞期间增加 cwnd 的方法是计算 ACK 为新数据确认的字节数。（此实现的缺点是需要维护一个额外的状态变量。）当确认的字节数达到 cwnd 时，cwnd 最多可以增加 SMSS 字节。请注意，在避免拥塞期间，cwnd 的增加量不得超过每个 RTT 的 SMSS 字节。这种方法既允许 TCP 在面对延迟的 ACK 时每个 RTT 将 cwnd 增加一个段，又提供了对抗 ACK-Division 攻击的鲁棒性。

等式（3）中给出了 TCP 在避免拥塞期间可以用来更新 cwnd 的另一个常见公式：

```
   cwnd += SMSS*SMSS/cwnd                     (3)
```

这种调整是在确认新数据的每个传入 ACK 上执行的。方程（3）为每 RTT 将cwnd 增加 1 个全尺寸段的基本原理提供了可接受的近似值。（请注意，对于接收器每隔一个数据包就确认一次的连接，（3）的攻击性低于允许的攻击性 —— 大约每秒钟 RTT 增加 cwnd。）

实现注意：由于 TCP 实现中通常使用整数运算，因此当拥塞窗口大于 SMS*SMSS 时，等式（3）中给出的公式可能无法增加 cwnd。如果上面的公式产生 0，则结果应四舍五入到 1 字节。

实现说明：旧的实现在等式（3）的右侧有一个额外的加法常数。这是不正确的，实际上会导致性能下降[RFC2525]。

实现说明：一些实现以字节为单位维护cwnd，而另一些实现以全尺寸段为单位。后者会发现等式（3）很难使用，可能更喜欢使用上一段中讨论的计数方法。

当 TCP 发送器使用重传计时器检测到段丢失，并且给定的段尚未通过重传计时器重新发送时，ssthresh 的值必须设置为不超过等式（4）中给定的值：

```
   ssthresh = max (FlightSize / 2, 2*SMSS)            (4)
```

其中，如上所述，FlightSize 是网络中未处理的数据量。

另一方面，当 TCP 发送器使用重传定时器检测到段丢失并且给定段已经通过重传定时器重传了至少一次时，ssthresh 的值保持恒定。

实现注意：一个容易犯的错误是简单地使用cwnd，而不是 FlightSize，在某些实现中，FlightSize 可能会意外地远远超过 rwnd。

此外，在超时时（如[RFC2988]中所述），cwnd 必须设置为不超过丢失窗口 LW，它等于 1 个完整大小的段（无论 IW 的值如何）。因此，在重传丢弃的分段之后，TCP 发送器使用慢启动算法将窗口从 1 个完整大小的分段增加到 ssthresh 的新值，在这一点上，拥塞避免再次接管。

如 [FF96] 和 [RFC3782] 所示，超时后缓慢的基于启动的丢失恢复可能会导致触发重复确认的虚假重传。TCP 实现中对这些重复 ACK 的到达的反应变化很大。本文件没有具体说明如何处理此类确认，但指出这是一个可能受益于额外关注、实验和规范的领域。

### 3.2. Fast Retransmit/Fast Recovery

当一个无序段到达时，TCP 接收器应该立即发送一个重复的 ACK。该 ACK 的目的是通知发送者接收到的段是无序的，以及预期的序列号。从发送者的角度来看，重复的 ACK 可能是由许多网络问题引起的。首先，它们可能是由丢失的线段引起的。在这种情况下，丢弃的段之后的所有段都将触发重复的ACK，直到丢失得到修复。其次，重复的 ACK 可能是由网络对数据段的重新排序引起的（在一些网络路径上并非罕见事件 [Pax97]）。最后，重复的 ACK 可能是由网络对 ACK 或数据段的复制引起的。此外，当传入段填充序列空间中的全部或部分间隙时，TCP 接收器应该立即发送 ACK。这将为发送方通过重传超时、快速重传或高级丢失恢复算法从丢失中恢复生成更及时的信息，如第 4.3 节所述。

TCP 发送器应该使用“快速重传”算法来检测和修复丢失，基于传入的重复 ACK。快速重传算法使用 3 个重复 ACK 的到达（如第2节中所定义的，没有任何移动 SND.UNA 的中间 ACK）作为段已经丢失的指示。在接收到 3 个重复 ACK 之后，TCP 执行似乎是丢失段的重传，而不等待重传定时器到期。

在快速重传算法发送看似丢失的片段后，“快速恢复”算法控制新数据的传输，直到不重复的 ACK 到达。不执行缓慢启动的原因是，接收到重复的 ACK 不仅表明段已经丢失，而且表明段最有可能离开网络（尽管网络的大量段重复可能会使这一结论无效）。换句话说，由于接收器只能在分段到达时生成重复的 ACK，因此该分段已经离开网络并在接收器的缓冲区中，因此我们知道它不再消耗网络资源。此外，由于保留了 ACK “时钟”[Jac88]，TCP 发送器可以继续发送新的分段（尽管传输必须使用减少的 cwnd 继续，因为丢失是拥塞的指示）。

快速重传和快速恢复算法一起实现如下。

1. 在发送器接收到的第一个和第二个重复 ACK 上，TCP 应该根据 [RFC3042] 发送一段以前未发送的数据，前提是接收器的广告窗口允许，总 FlightSize 将保持小于或等于 cwnd 加 2*SMSS，并且新数据可用于传输。此外，TCP 发送器不得更改 cwnd 以反映这两个段 [RFC3042]。请注意，使用 SACK[RFC2018] 的发送方不得发送新数据，除非传入的重复确认包含新的 SACK 信息。
2. 当接收到第三个重复 ACK 时，TCP 必须将 ssthresh 设置为不大于等式（4）中给出的值。当使用 [RFC3042] 时，在有限传输中发送的附加数据不得包含在该计算中。
3. 必须重新传输从 SND.UNA 开始的丢失段，并将 cwnd 设置为 ssthresh 加 3*SMSS。这人为地将拥塞窗口“膨胀”了已经离开网络并且接收器已经缓冲的段的数量（三个）。
4. 对于接收到的每个额外的重复 ACK（在第三个之后），cwnd 必须由 SMSS 递增。这人为地使拥塞窗口膨胀，以反映已经离开网络的附加段。
    > 注：[SCWA99]讨论了一种基于接收器的攻击，即向数据发送器发送许多伪造的重复 ACK，以人为地夸大 cwnd 并导致使用高于适当的发送速率。因此，TCP 可以将 cwnd 在丢失恢复期间被人为膨胀的次数限制为未处理段的数量（或其近似值）。

    > 注：当高级丢失恢复机制（如第4.3节所述）未使用时，FlightSize 的增加可能会导致方程（4）略微膨胀 cwnd 和 ssthresh，因为 SND.UNA 和 SND.NXT 之间的一些段被认为已经离开网络，但仍反映在 FlightSize 中。
5. 当先前未发送的数据可用并且 cwnd 的新值和接收器的广告窗口允许时，TCP 应当发送先前未发送数据的 1*SMSS 字节。
6. 当确认先前未确认数据的下一个 ACK 到达时，TCP 必须将 cwnd 设置为 ssthresh（步骤2中设置的值）。这被称为“给窗户放气”。

该 ACK 应该是由步骤 3 的重传引起的确认，在重传后一个 RTT（尽管在接收器处存在数据段的严重无序递送的情况下，它可能会更快到达）。此外，如果丢失的段和第三个重复 ACK 的接收之间没有丢失，则该 ACK 应当确认发送的所有中间段。

> 注：已知该算法通常不能有效地从单个数据包飞行中的多个丢失中恢复[FF96]。下文第 4.3 节论述了这种情况。

## 4. Additional Considerations

### 4.1. Restarting Idle Connections

上述 TCP 拥塞控制算法的一个已知问题是，它们允许在 TCP 空闲相对长的时间段之后传输潜在的不适当的业务突发。在空闲期之后，TCP 不能使用 ACK 时钟将新的段选通到网络中，因为所有 ACK 都已从网络中耗尽。因此，如上所述，TCP 可能在空闲期之后向网络发送 cwnd 大小的线路速率突发。此外，不断变化的网络条件可能导致 TCP 关于两个端点之间可用端到端网络容量的概念（由 cwnd 估计）在长空闲期内不准确。

[Jac88] 建议 TCP 在相对较长的空闲期后使用慢速启动来重新启动传输。慢启动用于重新启动 ACK 时钟，就像在传输开始时一样。这一机制已通过以下方式得到广泛部署。当 TCP 在一个以上的重传超时时间内没有接收到段时，cwnd 将减少到传输开始前的重新启动窗口（RW）的值。

在本标准中，我们定义 `RW=min(IW，cwnd)`

在持久 HTTP 连接的常见情况下，使用最后一次接收段的时间来确定是否减少 cwnd 可能无法减少 cwnd [HTH98]。在这种情况下，Web 服务器在向 Web 客户端发送数据之前接收请求。接收到请求会使空闲连接的测试失败，并允许 TCP 以可能不适当的大 cwnd 开始传输。

因此，如果 TCP 在超过重传超时的时间间隔内未发送数据，则 TCP 应在开始传输之前将 cwnd 设置为不超过 RW。

### 4.2. Generating Acknowledgments

TCP 接收方应该使用 [RFC1122] 中指定的延迟 ACK 算法。 当使用延迟 ACK 时，TCP 接收方不得过度延迟确认。 具体来说，应该至少每隔两个全尺寸段生成一个 ACK，并且必须在第一个未确认数据包到达后 500 毫秒内生成。

[RFC1122] 中列出了“应该”至少每隔一个完整大小的段生成一个 ACK 的要求，其中一个地方列为 “应该”，另一个地方列为 “必须”。 在这里我们明确声明这是应该的。 我们还强调这是应该的，这意味着实施者确实应该在仔细考虑其含义后才可以偏离此要求。 请参阅 [RFC2525] 中对 “Stretch ACK Violation” 的讨论以及其中的参考资料，以了解与每隔一个完整大小的段生成 ACK 的频率相比可能出现的性能问题的讨论。

在某些情况下，发送方和接收方可能无法就全尺寸段的构成达成一致。 如果每次从发送方接收到 `2*RMSS` 字节的新数据时，一个实现至少发送一个确认，则该实现被视为符合此要求，其中 RMSS 是接收方向发送方指定的最大段大小（或默认值） 536 字节，根据 [RFC1122]，如果接收方在连接建立期间未指定 MSS 选项）。 由于最大传输单元 (MTU)、路径 MTU 发现算法或其他因素，发送方可能被迫使用小于 RMSS 的分段大小。 例如，考虑以下情况：接收方宣布 X 字节的 RMSS，但由于路径 MTU 发现（或发送方的 MTU 大小），发送方最终使用 Y 字节的分段大小 (Y < X)。 如果接收方在发送 ACK 之前等待 `2*X` 字节到达，则会生成拉伸 ACK。 显然，这将需要超过 2 个 Y 字节大小的段。 因此，虽然没有定义特定的算法，但接收器希望尝试防止这种情况，例如通过至少每隔两个段确认一次，而不管大小。 最后，我们重申，在等待第二个全尺寸数据段到达时，ACK 的延迟时间不得超过 500 毫秒。

应该立即确认无序数据段，以加速丢失恢复。 为了触发快速重传算法，当接收方收到序列空间间隙上方的数据段时，应该立即发送重复的 ACK。 为了向从丢失中恢复的发送方提供反馈，当接收方收到填充序列空间中全部或部分间隙的数据段时，应该立即发送 ACK。

TCP 接收方不得为每个传入数据段生成多个 ACK，除非在接收应用程序消耗新数据时更新提供的窗口（请参阅 [RFC813] 和 [RFC793] 第 42 页）。

### 4.3. Loss Recovery Mechanisms

TCP 研究人员提出了许多增强快速重传和快速恢复的丢失恢复算法，并在 RFC 系列中详细说明。 虽然其中一些算法基于 TCP 选择性确认 (SACK) 选项 [RFC2018]，例如 [FF96]、[MM96a]、[MM96b] 和 [RFC3517]，但其他算法不需要 SACK，例如 [Hoe96] 、[FF96] 和 [RFC3782]。 非SACK算法使用“部分确认”（覆盖先前未确认的数据的ACK，但不是检测到丢失时所有未确认的数据）来触发重传。 虽然本文档没有对任何可以改进快速重传/快速恢复的特定算法进行标准化，但这些增强的算法是隐式允许的，只要它们遵循上述四种基本算法的一般原则即可。

也就是说，当检测到数据窗口中的第一次丢失时，ssthresh 必须设置为不大于等式（4）给出的值。 其次，在修复相关数据窗口中的所有丢失分段之前，每个 RTT 中传输的分段数量不得超过检测到丢失时未完成分段数量的一半。 最后，在给定的段窗口中的所有丢失都已成功重传后，cwnd 必须设置为不超过 ssthresh，并且必须使用拥塞避免来进一步增加 cwnd。 两个连续数据窗口中的丢失或重传的丢失应被视为拥塞的两个指示，因此，在这种情况下，cwnd（和 ssthresh）必须降低两次。

我们建议 TCP 实现者采用某种形式的高级丢失恢复，可以应对数据窗口中的多个丢失。 [RFC3782] 和 [RFC3517] 中详细介绍的算法符合上面概述的一般原则。 我们注意到，虽然这并不是唯一符合上述一般原则的两种算法，但这两种算法已经过社区的审查，目前正在标准轨道上。

## 5. Security Considerations

本文档要求 TCP 在出现重传超时和重复确认到达的情况下降低其发送速率。 因此，攻击者可以通过导致数据包或其确认丢失，或者伪造过多的重复确认来损害 TCP 连接的性能。

为了响应 [SCWA99] 中概述的 ACK 分割攻击，本文档建议根据每个到达 ACK 中新确认的字节数而不是每个到达 ACK 上的特定常量来增加拥塞窗口（如第 3.1 节中所述）。

互联网在很大程度上依赖于这些算法的正确实施，以保持网络稳定性并避免拥塞崩溃。 攻击者可能会通过伪造过多的重复确认或对新数据的过多确认，导致 TCP 端点在拥塞时做出更积极的响应。 可以想象，这种攻击可能会导致部分网络陷入拥塞崩溃。

## 6. Changes between RFC 2001 and RFC 2581

[RFC2001] 在编辑上被广泛重写，逐项列出 [RFC2001] 和 [RFC2581] 之间的更改列表是不可行的。[RFC2581] 的目的是不改变 [RFC2001] 中给出的任何建议，而是进一步澄清 [RFC2001] 中未详细讨论的情况。 具体来说，[RFC2581] 建议了 TCP 连接在相对较长的空闲期后应该做什么，以及指定和澄清了与 TCP ACK 生成有关的一些问题。 最后，初始拥塞窗口的允许上限从一段提高到两段。

## 7. Changes Relative to RFC 2581

- 基于 BSD TCP 使用的定义，添加了“重复确认”的具体定义。
- 该文档现在指出，在重传计时器触发后如何处理重复的 ACK 是未来的工作，并且在本文档中没有明确指定。
- 初始窗口要求已更改，以允许更大的初始窗口，如 [RFC3390] 中的标准化。 此外，还详细介绍了当由于路径 MTU 发现 [RFC1191] 发现初始窗口太大时要采取的步骤。
- ssthresh 的建议初始值已更改为应该任意高，而之前为“可以”。 这是为了向实施者提供有关此事的额外指导。
- 在慢启动期间，明确建议使用 L=1*SMSS 的适当字节计数 [RFC3465]。 [RFC2581] 中给出的增加cwnd的方法仍然是明确允许的。 还建议在避免拥塞期间进行字节计数，同时仍然允许使用[RFC2581] - 中的方法和其他安全方法。
- 澄清了 ssthresh 对重传超时的处理。 特别是，在给定段的第一次重传时，ssthresh 必须设置为 FlightSize 的一半，然后在同一段的后续重传时保持不变。
- 快速重传和快速恢复的描述已经澄清，现在推荐使用有限传输 [RFC3042]。
- TCP 现在可以限制重复 ACK 的数量，这些重复 ACK 会在丢失恢复期间人为地将 cwnd 膨胀到未完成的段数，以避免 [SCWA99] 中描述的重复 ACK 欺骗攻击。
- 重启窗口已从 IW 更改为 min(IW,cwnd)。 此行为在 [RFC2581] 中被描述为“实验性”。
- 现在建议 TCP 实现者实施符合本文档中概述的原则的高级丢失恢复算法。
- 安全注意事项已更新为讨论 ACK 划分并建议字节计数作为针对此攻击的计数器。

## 8. Acknowledgments

我们描述的核心算法是由 Van Jacobson [Jac88，Jac90] 开发的。 此外，Limited Transmit [RFC3042] 是与 Hari Balakrishnan 和 Sally Floyd 联合开发的。 本文档中指定的初始拥塞窗口大小是与 Sally Floyd 和 Craig Partridge [RFC2414、RFC3390] 合作的结果。

W. Richard（“Rich”）Stevens 编写了本文档的第一个版本 [RFC2001]，并与他人共同撰写了第二个版本 [RFC2581]。 目前的版本受益于他清晰而深思熟虑的描述，我们感谢 Rich 在阐明 TCP 拥塞控制以及更广泛地帮助我们理解与网络相关的众多问题方面所做的贡献。

我们想强调的是，本文件的缺点和错误完全由当前作者负责。

本文档中的一些文本摘自 W. Richard Stevens 的 “TCP/IP Illustrated, Volume 1: The Protocols”（Addison-Wesley，1994）和 Gary R 的 “TCP/IP Illustrated, Volume 2: The Implements” . 赖特和 W. 理查德·史蒂文斯 (Addison-Wesley, 1995)。 本材料的使用已获得 Addison-Wesley 的许可。

Anil Agarwal、Steve Arden、Neal Cardwell、Noritoshi Demizu、Gorry Fairhurst、Kevin Fall、John Heffner、Alfred Hoenes、Sally Floyd、Reiner Ludwig、Matt Mathis、Craig Partridge 和 Joe Touch 提供了许多有用的建议。
