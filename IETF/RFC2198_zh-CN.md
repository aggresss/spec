# RTP Payload for Redundant Audio Data

> Origin [https://datatracker.ietf.org/doc/html/rfc2198](https://datatracker.ietf.org/doc/html/rfc2198)

## 摘要

本文档描述了用于实时传输协议 (RTP) version 2 的有效负载格式，用于编码冗余音频数据。本文描述的方案的主要目的是开发用于有损分组网络 (如 Internet Mbone) 的音频会议工具，尽管该方案并不局限于这些应用程序。

## 1. 介绍

如果多媒体会议要被 Internet Mbone 社区广泛使用，用户必须认为它的质量对大多数应用程序来说足够好。我们已经发现了一些影响会议质量的问题，其中最严重的是丢包问题。这是一个长期存在的问题，特别是考虑到互联网的日益普及和因此增加的负载。即使在低丢包率的情况下，语音清晰度也会受到破坏，这可能会使多数用户误认为通过互联网进行多媒体会议是不可行的。在数据流中增加冗余是一种解决方案。如果一个包丢失了，在平均连续丢失包数较小的情况下，接收端可以从下一个包中到达的冗余数据重建丢失的信息。最近的工作 [4,5] 表明，互联网中的丢包模式是这样的，该方案通常功能良好。

本文档描述了以这种冗余方式编码的音频数据传输的 RTP 有效载荷格式。第 2 节介绍了导致此有效载荷格式定义的需求和动机，但不构成有效载荷格式定义的一部分。第 3 节定义了冗余音频数据的 RTP 有效载荷格式。

## 2. 需求/动机

RTP 下对冗余编码方案的要求如下:

- 数据包必须携带一个主编码和一个或多个冗余编码。
- 由于冗余信息可使用多种编码，因此每一段冗余编码必须有一种编码类型标识符。
- 由于需要使用可变大小编码，数据包中的每个编码块必须有一个长度指示字段。
- RTP 报头提供了一个时间戳字段，对应于编码数据创建的时间。当使用冗余编码时，这个时间戳字段可以指主要编码数据的创建时间。冗余的数据块将与主要数据对应不同的时间间隔，因此每个冗余编码块将需要自己的时间戳。为了减少携带时间戳所需的字节数，可以将其编码为冗余编码的时间戳与主要数据的时间戳差值。

有两种基本的方法可以将冗余音频添加到标准 RTP 规范中:头扩展可以保留冗余，或者可以定义一个或多个额外的负载类型。

在报头扩展中包含包的所有冗余信息将使不实现冗余的应用程序很容易丢弃冗余，只处理主要编码数据。然而，这个方案也有一些缺点:

- 扩展头需要的字节数 (4 字节) 和可能的填充，在扩展结束时需要四舍五入到一个 4 字节的边界 (例如 3 字节会有很大的开销）。对于许多应用程序来说，这种开销是不可接受的。
- 头扩展的使用限制了应用程序的单一冗余编码，除非进一步的结构被引入扩展。这将导致进一步的开销。

由于这些原因，使用 RTP 报头扩展来保存冗余音频编码被忽略了。

音频和视频会议的 RTP Profile [3] 列出了一组有效负载类型，并提供了 32 种编码的动态范围，这些编码可以通过会议控制协议定义。这导致了两种可能的方案为冗余音频应用程序分配额外的 RTP 有效负载类型:

1. 可以使用 RTP 动态有效载荷类型范围，为每个主/冗余有效载荷类型组合定义动态编码方案。
2. 可以定义单个固定的有效负载类型来表示具有冗余的数据包。然后可以将其分配给静态 RTP 负载类型，也可以动态分配其负载类型。

可以定义一组有效载荷类型，表示所提供的 32 种动态有效载荷类型的主编码和次编码的特定组合。对于具有单个冗余块的数据包，这将是一个稍微有限制但可行的解决方案，因为可能的组合的数量不是太大。然而，对多个冗余块的需求大大增加了编码组合的数量，使这种解决方案不可行的。

上述解决方案的一个修改版本可以是在会议开始之前，在一组上决定在会议期间使用的 32 种编码组合。会议中的所有工具都可以用这个编码组合的工作集进行初始化。工作集的通信可以通过使用外部的、带外的机制来实现。建立过程是复杂的，因为在使用相同的参数启动工具时需要非常小心。这种方案更有效，因为只使用一个字节来标识编码组合。

人们认为，将有效载荷类型映射到冗余数据的组合中所固有的复杂性妨碍了这种机制的使用。

一个更灵活的解决方案是使用单一的有效负载类型来表示具有冗余的数据包。然后，该包成为一个容器，将多个有效负载封装到单个 RTP 包中。这种方案是灵活的，因为任何数量的冗余可以封装在单个包中。但是，由于每个封装的有效负载前面必须有一个指示所封装数据类型的头，因此开销很小。这是首选的解决方案，因为它既灵活、可扩展，而且开销相对较低。本文档的其余部分将描述此解决方案。

## 3. 负载格式定义

本文档中的关键词“必须”、“不得”、“必需”、“应”、“不应”、“建议”、“不建议”、“可”和“可选”在所有大写字母出现时（如图所示）应按照 BCP 14 [RFC2119] 所述进行解释。

这个新数据包格式的 RTP 有效负载类型的分配超出了本文的范围，在这里不再指定。预期特定类型的应用程序的 RTP Profile 将为这种编码分配一个有效载荷类型，或者如果没有这样做，则应选择动态范围内的有效载荷类型。

包含冗余数据的 RTP 包应该有一个标准的 RTP 报头，其有效载荷类型表示冗余。RTP 报头的其他字段与冗余数据的主要数据块有关。

RTP 报头后面是一些额外的报头，在下面的图中定义，它们指定包携带的每个编码的内容。这些额外的报头后面是一些数据块，这些数据块包含这些编码的标准 RTP 有效负载数据。需要注意的是，所有报头都对齐到 32 位边界，但是负载数据通常不会对齐。如果一个包中携带多个冗余编码，它们应该对应于不同的时间间隔：没有理由在一个包中包含单个时间间隔的多个数据副本。

```diagram
   0                   1                    2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3  4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |F|   block PT  |  timestamp offset         |   block length    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

报头中的位指定如下:

- `F`: 1 bit 报头的第一位表示后面是否有另一个报头块。为 1 表示后面还有报头块，为 0 表示这是最后一个报头块。
- `block PT`: 当前块的 7 位RTP有效负载类型。
- `timestamp offset`: 相对于 RTP 报头中给出的时间戳的无符号偏移量。使用无符号偏移量意味着冗余数据必须在主数据之后发送，因此需要从当前时间戳中减去一个时间戳，以确定该块为冗余的数据的时间戳。
- `block length`: 10 比特对应数据块的长度 (不包括报头)。

值得注意的是，使用无符号时间戳偏移量稍微限制了冗余数据的使用:在主编码之前不可能发送冗余数据。这可能会影响适合于冗余的低带宽编码在编码过程中较早产生的方案，因此可以较早地传输。然而，符号位的增加将不可接受地减少时间戳偏移的范围，并且将字段的大小增加到 14 位以上将限制块长度字段。似乎在主域之后限制冗余传输比限制其他域的大小造成的问题要少。

一个冗余块的时间戳偏移量与主编码的时间戳的单位相同(例如:与主编码的时钟速率相同的音频样本)。这意味着冗余编码必须以与主编码相同的速率进行采样。

进一步指出，块长度和时间戳偏移量分别为 10 位和 14 位；而不是更明显的 8 位和 16 位。虽然这样的编码对于头信息的解析稍微复杂了一些，并增加了一些额外的处理开销，但更明显的选择涉及到一些问题：8 位块长度字段对大多数 (但不是所有) 可能的编码来说足够了：例如，80ms PCM 和 DVI 音频数据包所包含超过 256 字节，不能用单个字节长度字段进行编码。可以在块长度字段上强加额外的结构(例如，高位集可能意味着较低的7位代码长度的单词，而不是字节)，然而，这样的方案是复杂的。10 位块长度字段的使用保持了简单性，并提供了一个扩大的范围，以减少时间戳值的范围为代价。

主编码块报头被放在包的最后。因此，可以从该块的报头中省略时间戳和块长度字段，因为它们可以从RTP报头和总包长度确定。主(最终)块的报头 F 位只能为 0，块有效载荷类型信息共 8 位。如下图所示:

```diagram
                      0 1 2 3 4 5 6 7
                     +-+-+-+-+-+-+-+-+
                     |0|   Block PT  |
                     +-+-+-+-+-+-+-+-+
```

最后一个报头后面立即跟着数据块，这些数据块按照与报头相同的顺序存储。数据块之间没有填充或其他分隔符，它们通常不是 32 位对齐的。同样，这种选择是为了减少带宽开销，而牺牲了额外的解码时间。

所使用的编码的选择应该反映这些编码的带宽要求。我们期望冗余编码使用的带宽要比主编码少得多：例外情况是主编码的带宽很低，并且有很高的处理要求，在这种情况下，可以使用主编码的一个副本作为冗余。冗余编码的带宽不能高于主编码。

很少有必要使用多级冗余。然而，在那些需要它的情况下，每一级冗余所需的带宽预计将大大低于前一级。

## 4. 限制

RTP 标记位不为冗余数据块保留。因此，如果主元素(包含该标记)丢失，该标记也将丢失。相信这不会造成不适当的问题：即使标记位传输了冗余信息，仍然存在丢失的可能性，因此在编写应用程序时仍然要考虑到这一点。

另外，不保留 CSRC 信息作为冗余数据。冗余音频包 RTP 报头中的 CSRC 数据只与主包相关。由于音频流中的 CSRC 数据预计变化相对较少，因此建议需要该信息的应用程序假设 RTP 头中的 CSRC 数据可以应用于重构的冗余数据。

## 5. SDP 相关

当使用冗余负载时，可能需要将其绑定到 RTP 动态负载类型。这可以通过任何带外机制实现，但一种常见的方法是使用会话描述协议 (SDP)[6] 。SDP 有一种机制，可以使用 "rtpmap" 属性将动态负载类型绑定到特定的编解码器、采样率和通道数量。使用它的一个例子 (使用RTP音频/视频 Profile [3]):

```diagram
       m=audio 12345 RTP/AVP 121 0 5
       a=rtpmap:121 red/8000/1
```

这指定使用 RTP 的音频流使用载荷类型 121 (动态载荷类型)、0 (PCM u-law) 和 5 (DVI)。"rtpmap" 属性用于将载荷类型 121 绑定到编解码器 "red"，表明这个编解码器实际上是一个冗余帧、8KHz 和单音频。当与 SDP 一起使用时，术语 "red" 用于表示本文中讨论的冗余格式。

在这种情况下，指定了 PCM 和 DVI 的附加格式。因此，接收方必须准备好使用这些格式。这样的规范意味着发送方在默认情况下将发送冗余，但也可以发送 PCM 或 DVI。然而，对于冗余的有效载荷，我们认为这意味着除了 PCM 或 DVI 之外，没有任何编解码器将用于冗余编码。请注意，在 "m=" 字段中定义的额外有效载荷格式本身可能是动态有效载荷类型，如果是这样，可能需要许多额外的 "a=" 属性来描述这些动态有效载荷类型。

要接收一个冗余的流，这就是所需要的一切。然而，要发送一个冗余的流，发送方需要知道哪些编解码器被推荐用于主要编码和次要编码(以及第三编码，等等)。这个信息是特定于冗余格式的，使用附加属性 "fmtp" 指定的，该属性传递特定于格式的信息。会话目录不会解析 "fmtp" 属性中指定的值，而只是将其不加修改地交给媒体工具。为了实现冗余，我们将格式参数定义为以斜杠 "/" 分隔的RTP有效负载类型列表。

因此一个完整的例子是:

```diagram
       m=audio 12345 RTP/AVP 121 0 5
       a=rtpmap:121 red/8000/1
       a=fmtp:121 0/5
```

## 6. 安全考虑

包含冗余信息的 RTP 包受到 RTP 规范 [2] 和任何适当的RTP Profile (例如[3])中讨论的安全考虑的影响。这意味着媒体流的保密性是通过加密实现的。
冗余数据流的加密可以通过两种方式进行:

1. 整个流是安全的，所有参与者都有密钥来解码整个流。在这种情况下，不需要做任何特殊的事情，加密是按照通常的方式执行的。
2. 流的一部分将用与其余部分不同的密钥加密。在这种情况下，该部分的最后一个数据包的冗余副本不能被发送，因为没有后续的数据包被正确的密钥加密以发送它。启用/禁用加密时可能会出现类似的限制。

这两者之间的选择只是编码器的问题。解码器可以在不修改的情况下解密这两种形式。

虽然在音频流中添加低带宽冗余是一种有效的方法，通过它可以保护该流不受包丢失的影响，但应用程序设计者应该意识到，添加大量冗余将增加网络拥塞，从而增加包丢失，导致问题的恶化，而使用冗余是为了解决这个问题。在最坏的情况下，这可能导致过度的网络拥塞，并可能构成拒绝服务攻击。

## 7. 示例

一个 RTP 音频数据包包含一个 DVI4 (8KHz)主，和一个使用 8KHz LPC 编码的冗余块(都是 20ms 包)，如定义在 RTP 音频/视频 Profile [3] 所示:

```diagram
    0                   1                    2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3  4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |V=2|P|X| CC=0  |M|      PT     |   sequence number of primary  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |              timestamp  of primary encoding                   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           synchronization source (SSRC) identifier            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1| block PT=7  |  timestamp offset         |   block length    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0| block PT=5  |                                               |
   +-+-+-+-+-+-+-+-+                                               +
   |                                                               |
   +                LPC encoded redundant data (PT=7)              +
   |                (14 bytes)                                     |
   +                                               +---------------+
   |                                               |               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               +
   |                                                               |
   +                                                               +
   |                                                               |
   +                                                               +
   |                                                               |
   +                                                               +
   |                DVI4 encoded primary data (PT=5)               |
   +                (84 bytes, not to scale)                       +
   /                                                               /
   +                                                               +
   |                                                               |
   +                                                               +
   |                                                               |
   +                                               +---------------+
   |                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

```