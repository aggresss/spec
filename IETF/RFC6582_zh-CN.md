# The NewReno Modification to TCP's Fast Recovery Algorithm

> 原文 [https://datatracker.ietf.org/doc/html/rfc6582](https://datatracker.ietf.org/doc/html/rfc6582)

## 摘要

RFC 5681 记录了以下四种相互交织的 TCP 拥塞控制算法：慢启动、拥塞避免、快速重传和快速恢复。 RFC 5681 明确允许对这些算法进行某些修改，包括使用 TCP 选择性确认 (SACK) 选项 (RFC 2883) 的修改，以及响应“部分确认”的修改（覆盖新数据的 ACK，但并非所有未完成的数据） 在没有 SACK 的情况下检测到丢失。 本文档描述了一种用于响应部分确认的特定算法，称为 “NewReno”。 这种对部分致谢的回应最初是由 Janey Hoe 提出的。 本文档废弃了 RFC 3782。

# 1. Introduction

对于 [RFC5681] 中描述的 TCP 快速恢复算法的典型实现（在 1990 年 BSD Reno 版本中首次实现，在 [FF96] 中称为“Reno 算法”），TCP 数据发送方仅在 发生重传超时，或者在三个重复确认到达后触发快速重传算法。 单个重传超时可能会导致多个数据包的重传，但每次调用 RFC 5681 中的快速重传算法只会导致单个数据包的重传。

当单个窗口中发生多个数据包丢失时，Reno TCP 会出现两个问题。 首先，Reno 经常会超时，如 [Hoe95] 中所述。 其次，即使避免了重传超时，也可能会发生多次快速重传和窗口缩小，如[F94]中所述。 当发生多个数据包丢失时，如果 SACK 选项 [RFC2883] 可用，则 TCP 发送方可以根据信息做出智能决策，在快速恢复期间重传哪些数据包以及不重传哪些数据包。

本文档适用于无法使用 TCP 选择性确认 (SACK) 选项的 TCP 连接，原因可能是本地不支持该选项，或者是因为 TCP 对等方未表示愿意使用 SACK。

在没有 SACK 的情况下，TCP 发送方在快速恢复期间做出重传决策时几乎没有可用的信息。根据三个重复的确认，发送方推断出数据包丢失，并重新传输指示的数据包。此后，数据发送方可以接收额外的重复确认，因为数据接收方确认当发送方进入快速重传时已经在传输中的额外数据包。

在从单个数据窗口丢弃多个数据包的情况下，当发送方收到对重传数据包（即首次进入快速重传时重传的数据包）的确认时，发送方可用的第一个新信息出现。如果存在单个数据包丢失且没有重新排序，则对该数据包的确认将确认进入快速重传之前传输的所有数据包。然而，如果存在多个数据包丢失，则对重传数据包的确认将确认快速重传之前传输的一些但不是全部数据包。 我们称这种确认为部分确认。

除了其他一些建议之外，[Hoe95] 建议在快速恢复期间，TCP 数据发送方通过推断下一个按顺序的数据包已丢失并重新传输该数据包来响应部分确认。 本文档描述了对 RFC 5681 中快速恢复算法的修改，该算法合并了对快速恢复期间收到的部分确认的响应。 我们将这种改进的快速恢复算法称为 NewReno，因为它是历史上称为 Reno 的行为的一个微小但重要的变化。 本文档不讨论 [Hoe95] 和 [Hoe96] 中的其他建议，例如在慢启动期间更改 ssthresh 参数，或者在快速恢复期间为每两个重复确认发送一个新数据包的建议。 本文档中 NewReno 的版本还借鉴了文献[LM97] [Hen98] 中对 NewReno 的其他讨论。

我们并不声称这里描述的 NewReno 版本的快速恢复是对无法使用 SACK 的 TCP 连接响应部分确认的快速恢复的最佳修改。 根据我们在 ns-2 [NS] 网络模拟器中对 NewReno 进行修改的经验以及 NewReno 的大量实现，我们相信这种修改可以提高快速重传和快速恢复算法在各种场景中的性能。 此 RFC [RFC2582] [RFC3782] 的先前版本提供了基于模拟的可能性能提升的证据。

## 2. Terminology and Definitions

本文档假定读者熟悉 [RFC5681] 中定义的术语“发送者最大分段大小”(SMSS)、“拥塞窗口”(cwnd) 和“航班大小”(FlightSize)。

本文档定义了一个名为 “recover” 的附加发送方状态变量：

- **recover**：在快速恢复时，该变量记录在声明快速恢复过程结束之前必须确认的发送序列号。

## 3. The Fast Retransmit and Fast Recovery Algorithms in NewReno

### 3.1. Protocol Overview

[RFC5681] 3.2 节中描述的快速重传和快速恢复算法的这些扩展的基本思想如下。 TCP 发送方可以根据重复确认的到达来推断同一数据窗口中是否很可能发生多次丢失，并避免由于此类事件而采取重传超时或进行多次拥塞窗口减少。

NewReno 修改适用于快速恢复过程，该过程在收到三个重复的 ACK 时开始，并在发生重传超时或确认所有数据（包括快速恢复过程开始时未完成的数据）的 ACK 到达时结束。

### 3.2. Specification

遵循 [RFC5681] 第 3.2 节中指定的过程，并进行下列修改。请注意，本规范避免使用 RFC2119 [RFC2119] 中定义的关键字，因为它主要提供发送方实现性能改进的指导，并且不影响互操作性。

1）TCP协议控制块的初始化：当TCP协议控制块初始化时，recover被设置为初始发送序列号。

2）三个重复的ACK：当收到第三个重复的ACK时，TCP发送方首先检查recover的值，看看Cumulative Acknowledgment字段是否覆盖了多个recover。 如果是，则recover的值增加到迄今为止TCP传输的最高序列号的值。 然后 TCP 进入快速重传（[RFC5681]第 3.2 节的步骤 2）。 如果不是，则TCP不会进入快速重传并且不会重置ssthresh。

3）对新确认的数据的响应：[RFC5681]的步骤6指定对确认先前未确认的数据的下一个ACK的响应。 当确认新数据的 ACK 到达时，该 ACK 可以是由快速重传的初始重传引起的确认，或者由稍后的重传引起的确认。 有两种情况：

完整确认：如果此 ACK 确认直到并包括恢复的所有数据，则 ACK 确认在丢失数据段的原始传输和第三个重复 ACK 的接收之间发送的所有中间数据段。 将 cwnd 设置为 (1) min (ssthresh, max(FlightSize, SMSS) + SMSS) 或 (2) ssthresh，其中 ssthresh 是进入快速重传时设置的值，其中 (1) 中的 FlightSize 是数据量 目前表现突出。 这称为窗口“放气”。 如果选择第二个选项，则鼓励实施采取措施避免可能的数据突发，以防网络中未完成的数据量远小于新的拥塞窗口允许的情况。 一种简单的机制是限制可以响应单个确认而发送的数据包的数量。 退出快速恢复过程。

部分确认：如果此 ACK“未”确认所有数据（包括恢复），则这是部分 ACK。 在这种情况下，重传第一个未确认的段。 根据累积确认字段确认的新数据量缩小拥塞窗口。 如果部分 ACK 确认至少一个新数据的 SMSS，则将 SMSS 字节添加回拥塞窗口。 这人为地扩大了拥塞窗口，以反映已离开网络的附加段。 如果 cwnd 的新值允许，则发送新段。 这种“部分窗口紧缩”试图确保，当快速恢复最终结束时，网络中将有大约 ssthresh 量的数据未完成。 不要退出快速恢复过程（即，如果随后到达任何重复的 ACK，则执行 [RFC5681] 第 3.2 节的步骤 4）。

对于快速恢复期间到达的第一个部分 ACK，还要重置重传计时器。 第 4 节更详细地讨论了计时器管理。

4） 重传超时：重传超时后，在变量recover中记录传输的最高序列号，如果适用，则退出快速恢复过程。

上面的步骤 2 指定检查累积确认字段是否覆盖了恢复。 因为确认字段包含发送方接下来期望接收的序列号，所以确认“ack_number”涵盖的内容比恢复时多

```
   ack_number - 1 > recover;
```

即，比上次进入快速重传时未完成的最高字节至少多确认一个字节的数据。

请注意，在上面的步骤 3 中，在收到部分确认后，拥塞窗口会缩小。 当收到部分确认时，拥塞窗口可能已大大扩大。 此外，根据数据包丢失的原始模式，部分确认可能会确认几乎一个数据窗口。 在这种情况下，如果拥塞窗口没有缩小，数据发送方可能能够连续发送近一个窗口的数据。

本文档没有规定在不调用快速重传/快速恢复算法时发送方对重复ACK的响应。 这在其他文档中得到了解决，例如描述有限传输过程的文档 [RFC3042]。 本文档也没有解决调整重复确认阈值的问题，而是假设 IETF 标准中指定的阈值； 当前的标准是 [RFC5681]，它指定了三个重复确认的阈值。

最后一点，我们会观察到，在没有 SACK 选项的情况下，数据发送方仅使用有限的信息进行工作。 当从单个数据窗口中多个丢弃的数据包中恢复的问题特别重要时，最好的替代方案是使用 SACK 选项。

## 4. Handling Duplicate Acknowledgments after a Timeout

每次重传超时后，将迄今为止传输的最高序列号记录在变量 recover 中。 如果在重传超时后，TCP 数据发送方重新发送数据接收方已接收到的三个连续数据包，则 TCP 数据发送方将收到三个重复的确认，这些确认不包括恢复。 在这种情况下，重复的确认并不表示出现新的拥塞情况。 它们只是表明发送方不必要地重传了至少三个数据包。

然而，当重传的数据包本身被丢弃时，发送方还可以收到三个重复的确认，这些确认不包括恢复。 在这种情况下，如果发送方发起快速重传，情况会更好。 对于实现本文档第 3.2 节中指定的算法的 TCP 发送方，在这种情况下，发送方不会从重复确认中推断出数据包丢失。 与往常一样，在这种情况下，重传计时器是推断数据包丢失的备用机制。

有几种启发式方法，基于时间戳或累积确认字段的前进量，允许发送方在某些情况下区分重传数据包被丢弃后的三个重复确认，以及来自不必要的重复确认的三个重复确认。 重传三个数据包 [Gur03] [GF04]。 TCP 发送方可以使用这样的启发式方法来决定在某些情况下调用快速重传，即使三个重复确认不包括恢复。

例如，当三个重复的确认是由三个数据包的不必要的重传引起的时，这可能伴随着累积确认字段前进至少四个段。 类似地，基于时间戳的启发式方法使用这样的事实：当序列空间中存在空洞时，重复确认中回显的时间戳是推进累积确认字段的最新数据包的时间戳[RFC1323]。 如果使用时间戳，并且发送方存储最后确认分段的时间戳，则重复确认回显的时间戳可用于区分被丢弃的重传数据包和来自三个数据包的不必要重传的三个重复确认。

### 4.1. ACK Heuristic

如果使用基于 ACK 的启发式，则随着累积确认字段的前进，发送方将先前累积确认的值存储为 prev_highest_ack，并将最新累积ACK存储为 highest_ack。 此外，如果在第 3.2 节的步骤 2 中，累积确认字段未覆盖更多内容，则执行以下检查。

2*) 如果累积确认字段没有覆盖超过恢复，请检查拥塞窗口是否大于 SMSS 字节，以及最高确认和前一最高确认之间的差异最多为 4*SMSS 字节。 如果为真，则重复的 ACK 表示丢失的段（进入快速重传）。 否则，重复的 ACK 可能会因不必要的重传而产生（不要进入快速重传）。

拥塞窗口检查用于防止重传超时后立即进行快速重传。

如果丢失了多个 ACK，则发送方可以看到超过三个段的累积 ACK 发生跳跃，并且启发式可能会失败。 [RFC5681]建议接收方应该为每个无序数据包发送重复的ACK，例如在快速恢复期间接收到的数据包。 如果接收方不遵循此建议，则 ACK 启发式更有可能失败，因为此时需要较少数量的 ACK 丢失来在累积 ACK 中产生足够的跳跃。

### 4.2. Timestamp Heuristic

如果使用此启发式，发送方将存储最后确认的分段的时间戳。 另外，本文档3.2节步骤2最后一句替换如下：

2**) 如果累积确认字段未涵盖恢复以外的内容，请检查最后一个非重复确认中的回显时间戳是否等于存储的时间戳。 如果为真，则重复的 ACK 表示丢失的段（进入快速重传）。 否则，重复的 ACK 可能会因不必要的重传而产生（不要进入快速重传）。

当接收器回显时间戳（如 [RFC1323] 所指定）及其修订尝试时，时间戳启发式都可以正常工作。 然而，如果接收者任意回显时间戳，启发式方法可能会失败。 如果超时是虚假的并且返回的 ACK 不是来自重传的段，则启发式方法也可能会失败。 这可以通过检测算法来防止，例如 Eifel 检测算法 [RFC3522]。

## 5. Implementation Issues for the Data Receiver

[RFC5681]指定“无序数据段应该立即被确认，以加速丢失恢复”。 Neal Cardwell 指出，某些数据接收方在发送部分确认时不会立即发送确认，而是首先等待其延迟确认计时器到期 [C98]。 正如 [C98] 所指出的，这通过延迟数据发送者部分确认的接收而严重限制了 NewReno 的潜在好处。 与 [RFC5681] 相呼应，我们的建议是数据接收器立即发送对无序段的确认，即使该无序段填充了缓冲区中的一个洞。

## 6. Implementation Issues for the Data Sender

在上面的第 3.2 节步骤 3 中，注意到实现应采取措施，避免在离开快速恢复时可能出现的数据突发，以防发送方由于拥塞的新值而有资格发送的新数据量 窗户很大。 当 ACK 丢失或被视为纯粹的窗口更新时，在 NewReno 期间可能会出现这种情况，从而导致发送方低估在恢复过程中可以发送的新段的数量。 具体来说，当退出快速恢复时，当 FlightSize 远小于新的拥塞窗口时，可能会发生突发。 避免快速恢复时出现数据突发的一种简单机制是限制可以响应单个确认而发送的数据包的数量。 （这在 ns-2 [NS] 中称为“maxburst_”。）避免突发的其他可能机制包括基于速率的调步，或将慢启动阈值设置为结果拥塞窗口，然后将拥塞窗口重置为 FlightSize。 关于避免过度突发发送模式的一般机制的建议超出了本文档的范围。

实现可能想要使用单独的标志来记录它当前是否处于快速恢复过程中。 为此目的使用重复确认计数器的值是不可靠的，因为它可以在窗口更新和乱序确认时重置。

当在快速恢复之外更新累积确认字段时，状态变量恢复也可能需要更新，以便继续允许可能进入快速恢复（第 3.2 节，步骤 2）。 当累积确认字段的更新导致序列回绕，从而影响累积确认字段和状态变量恢复之间的排序时，就会出现此问题。 仅当累积确认字段覆盖的内容多于状态变量恢复时，才可能进入快速恢复。

当发送方不再处于快速恢复状态时（例如，由于重传超时），发送方正确响应收到的重复 ACK 非常重要。 有限传输过程[RFC3042]描述了对第一个和第二个重复确认的可能响应。 当收到三个或更多重复确认时，累积确认字段不涵盖恢复，并且不调用新的快速恢复，发送方应遵循第 4 节中的指导。否则，发送方可能最终陷入链中 虚假超时。 我们提到这一点只是因为几个 NewReno 实现存在此错误，包括 ns-2 [NS] 中的实现。

据观察，一些 TCP 实现在通过第 3.2 节第 3 步中找到的方程设置 cwnd 后立即进入慢启动或拥塞避免窗口更新算法，即使没有新的外部事件生成 cwnd 更改。 请注意，在基于退出快速恢复的过程（第 3.2 节，步骤 3）设置 cwnd 后，不应更新 cwnd，直到在此调整后发生进一步的事件（例如，ack 到达或超时）。

## 7. Security Considerations

[RFC5681] 讨论了有关 TCP 拥塞控制的一般安全注意事项。 本文档描述了符合 [RFC5681] 拥塞控制要求的特定算法，因此这些考虑因素也适用于该算法。 此特定算法没有已知的其他安全问题。

## 8. Conclusions

本文档规定了NewReno的TCP快速重传和快速恢复算法。 NewReno 对 TCP 的修改甚至对于支持 SACK 选项的 TCP 实现也很重要，因为只有当两个 TCP 端节点都支持 SACK 选项时，SACK 选项才能用于 TCP 连接。 在本 RFC ([RFC2582] [RFC3782]) 的先前版本中讨论的许多场景中，NewReno 的性能优于 Reno。

本文档的附录 A 中还引用了第 3 节中介绍的基本算法的许多选项。 其中包括重传计时器的处理、对部分确认的响应以及发送方是否必须维护称为恢复的状态变量。 我们相信，与 Reno 和 NewReno 之间的差异相比，NewReno 的这些变体之间的差异很小。 也就是说，重要的是对于没有SACK的TCP连接实现NewReno而不是Reno； 究竟实施 NewReno 的哪种变体并不那么重要。

## 9. Acknowledgments

非常感谢 Anil Agarwal、Mark Allman、Armando Caro、Jeffrey Hsu、Vern Paxson、Kacheong Poon、Keyur Shah 和 Bernie Volz 对前身 RFC 2582 和 3782 的详细反馈。Jeffrey Hsu 提供了有关变量恢复处理的说明； 这些澄清通过勘误应用于 RFC 3782，并纳入本文档第 6 节的文本中。 Yoshifumi Nishida 对快速恢复算法进行了修改，以解决当 TCP 发送方离开快速恢复而 TCP 接收方使用延迟确认时 FlightSize 为 0 的情况。 Alexander Zimmermann 提供了一些提高文件清晰度的建议。

## 10. References
### 10.1. Normative References
### 10.2. Informative References
## A. Additional Information
## B. Changes Relative to RFC 3782