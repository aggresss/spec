# HTTP/2

> 原文 [https://www.rfc-editor.org/rfc/rfc9113](https://www.rfc-editor.org/rfc/rfc9113)

## 摘要

## 1. Introduction

使用超文本传输协议(HTTP， [HTTP])的应用程序的性能与每个HTTP版本如何使用底层传输协议以及传输协议运行的条件有关。

发送多个并发请求可以减少延迟并提高应用程序性能。HTTP/1.0 在给定的 TCP 连接上只允许在同一时间有一个未完成的请求。HTTP/1.1 增加了请求管道，但这只是部分解决了请求并发，仍然会受到应用层队首阻塞 (head of line blocking) 的影响。因此，HTTP/1.0 和 HTTP/1.1 客户端使用多个到服务器的连接来发起并发请求。

此外，HTTP 字段通常是重复和冗长的，这会导致不必要的网络流量，并导致初始 TCP 拥塞窗口很快被填满。当在一个新的 TCP 连接上发起多个请求时，可能会导致过大的延迟。

HTTP/2 通过定义一个 HTTP 语义到底层连接的优化映射来解决这些问题。具体来说，它允许在同一个连接上交叉消息，并对 HTTP 字段使用高效编码。它还允许对请求进行优先级排序，让更重要的请求更快地完成，进一步提高性能。

最终的协议对网络更友好，因为与 HTTP/1.x 相比，可以使用更少的 TCP 连接。这意味着与其他流的竞争更少，连接寿命更长，从而更好地利用可用的网络容量。不过要注意，这个协议没有解决 TCP 队首阻塞问题。

最后，HTTP/2 还通过使用二进制消息分帧实现了更高效的消息处理。

这份文件淘汰了 [RFC7540] 和 [RFC8740]。附录 B 列出了值得注意的变化。

## 2. HTTP/2 Protocol Overview

HTTP/2 为 HTTP 语义提供了优化的传输。HTTP/2 支持 HTTP 的所有核心特性，但目标是比 HTTP/1.1 更高效。

HTTP/2 是一个运行在 TCP 连接( [TCP] )上的面向连接的应用层协议。客户端是 TCP 连接的发起者。

HTTP/2 的基本协议单位是帧(frame 4.1节)。每种帧类型都有不同的用途。例如，HEADERS 和 DATA 帧构成了 HTTP 请求和响应的基础(第 8.1 节);其他帧类型如 SETTINGS、WINDOW_UPDATE 和 PUSH_PROMISE 用于支持其他 HTTP/2 特性。

请求的多路复用是通过让每个 HTTP 请求/响应 都与自己的流相关联来实现的(第 5 节)。流在很大程度上是彼此独立的，因此阻塞或停滞的请求或响应不会影响其他流的处理。

复用的有效利用依赖于流量控制和优先级。流量控制(第 5.2 节)通过将传输的数据限制为接收端能够处理的数据，确保能够有效地使用多路复用的流。确定优先级(第 5.3 节)可以确保有限的资源得到最有效的利用。HTTP/2 的这个修订版本废弃了 [RFC7540] 中的优先级信令方案。

因为连接中使用的 HTTP 字段可能包含大量冗余数据，所以包含这些数据的帧会被压缩(第 4.3 节)。通常情况下，这对请求长度有特别有利的影响，允许将多个请求压缩到一个分组中。

最后，HTTP/2 增加了一个新的可选交互模式，服务器可以将响应推送给客户端(8.4 节)。它的目的是允许服务器根据预期向客户端发送数据，以牺牲一些网络开销换取潜在的延迟增益。服务器通过合成一个请求来实现这一点，并将其作为 PUSH_PROMISE 帧发送。然后，服务器能够在单独的流上向合成请求发送响应。

### 2.1. Document Organization

HTTP/2规范分为四个部分。

- Starting HTTP/2 (Section 3) 介绍了如何发起HTTP/2连接。
- Frame (Section 4) 和 Stream (Section 5) 描述了 HTTP/2 帧的结构和形成多路复用流的方式。
- Frame Definitions (Section 6) and Error Definitions (Section 7) 包括 HTTP/2 中使用的帧和错误类型的详细信息。
- HTTP Mappings (Section 8) 和 Additional Requirements (Section 9) 描述了如何使用帧和流表达 HTTP 语义。

虽然有些帧层和流层的概念与 HTTP 是隔离的，但本规范并没有定义一个完全通用的帧层。帧层和流层是根据HTTP的需求定制的。

### 2.2. Conventions and Terminology

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.

所有数值都是按网络字节顺序排列的。除非另有说明，否则值是无符号的。根据需要提供十进制或十六进制的字面量。十六进制字面量以 "0x" 作为前缀，以区别于十进制字面量。

本规范使用 RFC9000 [QUIC] 1.3 节中描述的约定描述二进制格式。注意，这种格式使用网络字节序，高值位在低值位之前。

这里使用了下列术语。

- client: 发起HTTP/2连接的端点。客户端发送HTTP请求并接收HTTP响应。
- connection: 两个端点之间的传输层连接。
- connection error: 影响整个 HTTP/2 连接的错误。
- endpoint: 连接的客户端或服务器。
- frame: HTTP/2 连接中通信的最小单位，由首部和根据帧类型构造的可变长度的字节序列组成。
- peer: 一个端点。当讨论一个特定的端点时，“peer”指的是与主要讨论对象相隔较远的端点。
- receiver: 接收帧的端点。
- sender: 传输帧的端点。
- server: 接受 HTTP/2 连接的端点。服务器接收 HTTP 请求并发送 HTTP 响应。
- stream: HTTP/2 连接中的双向帧流。
- stream error: 单个 HTTP/2 流的错误。

最后，术语 "gateway"、"intermediary"、"proxy" 和 "tunnel" 的定义见 [HTTP] 的第 3.7 节。中间设备在不同时间同时充当客户端和服务器。

适用于消息体的术语 "content" 定义在 [HTTP] 章节 6.4 中。

## 3. Staring HTTP/2

生成 HTTP 请求的实现需要知道服务器是否支持 HTTP/2。

HTTP/2 使用 [HTTP] 第 4.2 节中定义的 "HTTP" 和 "https" URI scheme，与 HTTP/1.1 [HTTP/1.1] 具有相同的默认端口号。这些 URI 不包含上游服务器(客户端希望建立连接的直接端)支持的 HTTP 版本的任何指示。

对于 "HTTP" 和 "https" URI，确定是否支持 HTTP/2 的方法是不同的。"https" URI 的发现在 3.2 节中描述。HTTP/2 对 "HTTP" URI 的支持只能通过带外方式发现，并且需要事先了解 3.3 节所述的支持情况。

### 3.1. HTTP/2 Version Identification

本文档中定义的协议有两个标识符。基于其中任何一个标识符创建连接都意味着使用本文档中描述的传输、帧和消息语义。

- 字符串 "h2" 表示 HTTP/2 使用传输层安全协议(Transport Layer Security, TLS)的协议;参见 9.2 节。这个标识符在 TLS 应用层协议协商(ALPN)扩展 [TLS-ALPN] 字段中使用，在任何可以识别 TLS 上 HTTP/2 的地方也会使用。 "h2" 字符串被序列化为 ALPN 协议的两个字节序列: `0x68、0x32` 。
- "h2c" 字符串以前用作令牌，用于 HTTP 升级机制的 Upgrade 头字段( [HTTP] 章节 7.8 )。这种用法从未被广泛部署，并且被本文所弃用。这同样适用于 HTTP2-Settings 头字段，该字段在升级到 "h2c" 时被使用。

### 3.2. Starting HTTP/2 for "https" URIs

客户端使用 TLS [TLS13] 和 ALPN 扩展 [TLS-ALPN] 向 "https" URI 发出请求。

基于 TLS 的 HTTP/2 使用 "h2" 协议标识符。"h2c" 协议标识符不能由客户端发送或由服务器选择; "h2c" 协议标识符描述了不使用 TLS 的协议。

一旦 TLS 协商完成，客户端和服务器都必须发送 connection preface (章节3.4)。

### 3.3. Starting HTTP/2 with Prior Knowledge

客户端可以通过其他方式得知某个服务器支持 HTTP/2。例如，客户端可以配置服务器是否支持 HTTP/2。

客户端知道服务器支持 HTTP/2，就可以建立一个 TCP 连接，并在发送 HTTP/2 帧之后发送连接序言(章节3.4)。服务器可以通过连接序言来识别这些连接。这只对通过明文 TCP 建立 HTTP/2 连接有影响。基于 TLS 的 HTTP/2 连接必须使用 TLS [TLS-ALPN] 中的协议协商。

同样，服务器必须发送连接序言(章节3.4)。

如果没有额外的信息，先前对 HTTP/2 的支持并不是某台服务器在以后的连接中也会支持 HTTP/2 的强信号。例如，服务器配置可能会改变，集群服务器中不同实例的配置可能不同，或者网络条件可能会改变。

### 3.4. HTTP/2 Connection Preface

在 HTTP/2 中，每个端点都需要发送连接序言以最终确认使用的协议，并为 HTTP/2 连接建立初始设置。客户端和服务器分别发送不同的连接序言。

客户端连接序言以24个字节序列开始，用十六进制表示法表示为:

```
  0x505249202a20485454502f322e300d0a0d0a534d0d0a0d0a
```

也就是说，连接序言以字符串 `"PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n"` 开始。这个序列后面必须跟着一个 SETTINGS 帧(章节 6.5)，它可以是空的。客户端发送客户端连接序言作为连接的第一个应用数据字节。

> 注意: 选择客户端连接序言是为了让大部分 HTTP/1.1 或 HTTP/1.0 服务器和中间设备不再尝试处理其他帧。请注意，这并没有解决 [TALKING] 中提出的问题。

服务器连接序言由一个可能为空的 SETTINGS 帧(章节 6.5)组成，它必须是服务器在 HTTP/2 连接中发送的第一个帧。

从另一端接收到的 SETTINGS 帧作为连接序言的一部分，必须在发送连接序言后确认(参见 6.5.3 节)。

为了避免不必要的延迟，允许客户端在发送客户端连接序言后立即向服务器发送额外的帧，而无需等待接收服务器连接序言。但是，需要注意的是，服务器连接序言设置帧可能包括一些必要的设置，这些设置可能会改变客户端预期与服务器通信的方式。在收到设置帧后，客户端被期望遵守任何已建立的设置。在某些配置中，服务器可以在客户端发送额外帧之前发送设置，从而避免这个问题。

客户端和服务器必须将无效的连接序言视为类型为协议错误的连接错误(章节 5.4.1)。在这种情况下，超时帧(第 6.8 节)可能会被忽略，因为无效的序言表明对等端没有使用 HTTP/2。

## 4. HTTP Frames

一旦建立了 HTTP/2 连接，终端就可以开始交换帧了。

### 4.1. Frame Format

所有的帧都以一个固定格式的 9 字节头开始，然后是一个可变长度的帧负载。

```
HTTP Frame {
  Length (24),
  Type (8),

  Flags (8),

  Reserved (1),
  Stream Identifier (31),

  Frame Payload (..),
}
```

帧头的字段定义如下:

- Length: 以字节为单位的无符号 24 位整数表示的帧负载的长度。大于 2^14 (16,384) 的值不能发送，除非接收方为 SETTINGS_MAX_FRAME_SIZE 设置了更大的值。 帧头的 9 个字节不包括在这个值中。
- Type: 帧的 8 位类型。帧类型决定了帧的格式和语义。第 6 节列出了本文档中定义的框架。实现必须忽略和丢弃未知类型的帧。
- Flags: 一个8位字段，用于指定帧类型的布尔标志。标志的语义与指定的帧类型相关。未使用的标志是那些对特定帧类型没有定义语义的标志。未使用的标志在接收时必须忽略，发送时必须保持未设置(0x00)。
- Reserved: 保留的 1 位字段。该比特位的语义未定义，在发送时必须保持未设置 (0x00)，在接收时必须忽略。
- Stream Identifier: 用无符号 31 位整数表示的流标识符(参见第 5.1.1 节)。0x00 这个值是为连接中作为整体关联的帧保留的，而不是单独的流。

帧负载的结构和内容完全取决于帧类型。

### 4.2. Frame Size

帧有效载荷的大小受限于接收端在 SETTINGS_MAX_FRAME_SIZE 设置中通告的最大大小。这个值可以是 2^14 (16,384) 到 2^24-1 (16,777,215) 之间的任意值，包括这个值。

所有的实现必须能够接收和处理长度不超过 2^14 个字节的帧，加上 9 个字节的帧头(章节 4.1)。描述帧大小时，帧头的大小不包括在内。

> 注意:某些类型的帧，如 PING(章节 6.7)，对允许的帧负载数据量有额外的限制。

如果一个帧超过 SETTINGS_MAX_FRAME_SIZE 定义的大小，超过为帧类型定义的任何限制，或者太小不能包含强制帧数据，端点必须发送一个错误码 FRAME_SIZE_ERROR。帧内的帧大小错误可能会改变整个连接的状态，必须被视为连接错误(章节 5.4.1);这包括任何带有字段块(章节 4.3 )的帧(即 HEADERS、PUSH_PROMISE 和 CONTINUATION)、SETTINGS帧，以及任何流标识符为 0 的帧。

端点没有义务使用帧中的所有可用空间。响应性可以通过使用小于允许的最大尺寸的帧来提高。发送大帧可能会导致发送时间敏感帧(如 RST_STREAM、WINDOW_UPDATE 或 PRIORITY )的延迟，如果传输大帧时被阻塞，则会影响性能。

### 4.3. Field Section Compression and Decompression

field 部分的压缩是将一组 field 行( [HTTP] 的 5.2 节)压缩成 field block 的过程。域段解压缩是将域块解码为一组域线的过程。HTTP/2 字段段压缩和解压缩的细节在 [compression] 中定义，由于历史原因，它将这些过程称为 header compression 和 header decompression 。

每个 field block 将 field 部分所有的 filed 压缩成一个 block。标题段还包括以伪标题字段( 8.3 节)的形式与消息关联的控制数据，这些字段使用与字段行相同的格式。

> 注意: RFC7540 [RFC7540] 使用术语 "header block" 取代了更通用的 "field block"。

字段块携带请求、响应、承诺请求和推送响应的控制数据和首部部分(见 8.4 节)。除了在 PUSH_PROMISE (章节 6.6)帧中包含的临时响应和请求外，所有这些消息都可以选择包含一个带有 trailer 节的字段块。

field section 是 field line 的集合。field block 中的每一条 field line 都携带一个值。序列化后的 field block 被分成一个或多个字节序列，称为 field block fragments。第一个字段块片段是在 HEADERS (章节 6.2)或 PUSH_PROMISE (章节 6.6) 的帧负载中传输的，每一个都可以后面跟着 CONTINUATION (章节 6.10) 帧来携带后续的字段块片段。

Cookie 首部字段 [Cookie] 由 HTTP 映射特殊处理(参见 8.2.3 节)。

接收端通过拼接其片段重组字段块，然后解压块以重构字段部分。

一个完整的字段部分包括:

- 一个 HEADERS 或 PUSH_PROMISE 帧，设置了 END_HEADERS 标志，或者
- 未设置 END_HEADERS 标志的 HEADERS 或 PUSH_PROMISE 帧，以及一个或多个延续帧，其中最后一个延续帧设置了 END_HEADERS 标志。

每个字段块被作为一个离散单元处理。字段块必须作为连续的帧序列传输，不能有任何其他类型或来自任何其他流的交叉帧。HEADERS 或 CONTINUATION 帧序列中的最后一帧设置了 END_HEADERS 标志。PUSH_PROMISE 或 CONTINUATION 帧序列中的最后一帧设置了 END_HEADERS 标志。这使得字段块在逻辑上等同于单个帧。

字段块片段只能作为 HEADERS、PUSH_PROMISE 或 CONTINUATION 帧的帧负载发送，因为这些帧携带的数据可以修改接收端维护的压缩上下文。终端接收到 HEADERS、PUSH_PROMISE 或 CONTINUATION 帧时，即使这些帧将被丢弃，也需要重新组装字段块并执行解压缩。如果接收方没有解压缩字段块，则必须以类型为 COMPRESSION_ERROR 的连接错误(章节5.4.1)终止连接。

字段块中的解码错误必须被视为类型为 COMPRESSION_ERROR 的连接错误(章节 5.4.1)。

#### 4.3.1. Compression State

字段压缩是有状态的。每个端点都有一个 HPACK 编码器上下文和一个 HPACK 解码器上下文，用于对连接上的所有字段块进行编码和解码。第 4 节定义了动态表，它是每个上下文的主要状态。

动态表的最大长度是由 HPACK 解码器设定的。终端通过其 HPACK 解码器上下文的 SETTINGS_HEADER_TABLE_SIZE 设置来传递数据长度。参见 6.5.2 节。在建立连接时，两端 HPACK 解码器和编码器的动态表大小都是从 4096 字节开始的，这是 SETTINGS_HEADER_TABLE_SIZE 设置的初始值。

使用 SETTINGS_HEADER_TABLE_SIZE 对最大值所做的任何修改，在端点确认设置时生效(6.5.3 节)。该端点的 HPACK 编码器可以将动态表设置为解码器设置的最大值之前的任意大小。HPACK 编码器通过动态表大小更新指令声明动态表的大小( [COMPRESSION] 章节 6.3)。

一旦终端确认 SETTINGS_HEADER_TABLE_SIZE 发生了变化，使得最大值小于动态表的当前大小，它的 HPACK 编码器就必须用一条动态表大小更新指令开始下一个字段块，该指令将动态表的大小设置为小于或等于缩减后的最大值;参见 [COMPRESSION] 第4.2节。如果一个端点没有以一个符合的动态表大小更新指令开始，那么它必须将在确认缩减到最大动态表大小之后的字段块视为类型为 COMPRESSION_ERROR 的连接错误(章节5.4.1)。

> 建议实现者注意，减少 SETTINGS_HEADER_TABLE_SIZE 的值不能广泛互操作。使用连接序将值减少到初始值 4096 以下，这在某种程度上得到了更好的支持，但在某些实现中可能会失败。

## 5. Streams and Multiplexing

"stream" 是一个独立的、双向的帧序列，在 HTTP/2 连接中在客户端和服务器之间交换。流有几个重要的特征。

- 一个 HTTP/2 连接可以包含多个并发打开的流，任何一个终端都可以交错使用来自多个流的帧。
- 流可以单独建立和使用，也可以由任意一端共享。
- 两个端点都可以关闭流。
- 发送帧的顺序很重要。接收方按照接收帧的顺序处理帧。特别是，首部和数据帧的顺序在语义上很重要。
- 流由一个整数标识。流标识符由初始化流的端点分配给流。

### 5.1. Stream States

```
                                +--------+
                        send PP |        | recv PP
                       ,--------+  idle  +--------.
                      /         |        |         \
                     v          +--------+          v
              +----------+          |           +----------+
              |          |          | send H /  |          |
       ,------+ reserved |          | recv H    | reserved +------.
       |      | (local)  |          |           | (remote) |      |
       |      +---+------+          v           +------+---+      |
       |          |             +--------+             |          |
       |          |     recv ES |        | send ES     |          |
       |   send H |     ,-------+  open  +-------.     | recv H   |
       |          |    /        |        |        \    |          |
       |          v   v         +---+----+         v   v          |
       |      +----------+          |           +----------+      |
       |      |   half-  |          |           |   half-  |      |
       |      |  closed  |          | send R /  |  closed  |      |
       |      | (remote) |          | recv R    | (local)  |      |
       |      +----+-----+          |           +-----+----+      |
       |           |                |                 |           |
       |           | send ES /      |       recv ES / |           |
       |           |  send R /      v        send R / |           |
       |           |  recv R    +--------+   recv R   |           |
       | send R /  `----------->|        |<-----------'  send R / |
       | recv R                 | closed |               recv R   |
       `----------------------->|        |<-----------------------'
                                +--------+
```

- send: endpoint sends this frame
- recv: endpoint receives this frame
- H: HEADERS frame (with implied CONTINUATION frames)
- ES: END_STREAM flag
- R: RST_STREAM frame
- PP: PUSH_PROMISE frame (with implied CONTINUATION frames); state transitions are for the promised stream

请注意，该图只显示了流状态转换以及影响这些转换的帧和标志。在这方面，延续帧不会导致状态转换;它们实际上是它们遵循的 HEADERS 或 PUSH_PROMISE 的一部分。为了进行状态转换，END_STREAM 标志作为带有它的帧的单独事件处理。设置了 END_STREAM 标志的 HEADERS 帧可以导致两次状态转换。

在传输帧时，两端对流的状态都有主观的看法，可能会有所不同。端点不参与流的创建; 它们是由任何一个端点单方面创建的。状态不匹配的负面影响仅限于发送 RST_STREAM 后的“关闭”状态，此时帧可能会在关闭后一段时间内接收到。

流有以下几种状态:

**idle**

All streams start in the "idle" state.

从这个状态开始，下列状态转换是有效的:

- 作为客户端发送 HEADERS 帧，或者作为服务器接收 HEADERS 帧，会导致流变为 "open"。流标识符的选择如 5.1.1 节所述。同样的 HEADERS 帧也会导致流立即变为 "half-closed" 状态。
- 在另一个流上发送 PUSH_PROMISE 帧，会为以后使用预留空闲流。保留流的状态变为 "reserved (local)"。只有服务器可以发送 PUSH_PROMISE 帧。
- 在另一个流上接收 PUSH_PROMISE 帧会预留一个空闲流供以后使用。保留流的状态变为 "reserved (remote)"。只有客户端可以接收 PUSH_PROMISE 帧。
- 注意，PUSH_PROMISE 帧不会在空闲流上发送，而是在被承诺的流 ID 字段中引用新预留的流。
- 通过将流标识符位置 1 来打开流，会导致流立即过渡到 "closed" 状态; 注意，图中没有显示此转换。

在这种状态下，在流上接收到除报头或优先级以外的任何帧都必须被视为类型为协议错误的连接错误(章节 5.4.1)。如果该流是由服务器发起的，如章节 5.1.1 所述，那么接收到 HEADERS 帧也必须被视为类型为协议错误的连接错误(章节5.4.1)。

**reserved (local)**

处于 "reserved (local)" 状态的流是指已经发送了 PUSH_PROMISE 帧的流。PUSH_PROMISE 帧通过将流与远端发起的打开流关联起来来保留一个空闲流(参见 8.4 节)。

在这种状态下，只有以下转换是可能的:

- 端点可以发送 HEADERS 帧。这会导致流以 "reserved (remote)" 状态打开。
- 任何一个终端都可以发送 RST_STREAM 帧来导致流变为 "closed"。这释放了流预留。

在这种状态下，终端不能发送除 HEADERS、RST_STREAM 或 PRIORITY 以外的任何类型的帧。

在这种状态下，可能会接收到 PRIORITY 或 WINDOW_UPDATE 帧。在这种状态下，在流上接收到除 RST_STREAM、PRIORITY 或 WINDOW_UPDATE 以外的任何类型的帧都必须被视为类型为 PROTOCOL_ERROR 的连接错误(章节 5.4.1)。

**reserved (remote)**

处于 "reserved (remote)" 状态的流已经被远程对等端保留了。

在这种状态下，只有以下转换是可能的:

- 接收到 HEADERS 帧会导致流变为 "half-closed (local)" 状态。
- 任何一个终端都可以发送 RST_STREAM 帧来导致流变为 "closed"。这释放了流预留。

在这种状态下，终端不能发送除 RST_STREAM、WINDOW_UPDATE 或 PRIORITY 以外的任何类型的帧。

在这种状态下，流上接收到除 HEADERS、RST_STREAM 或 PRIORITY 以外的任何类型的帧都必须被视为类型为 PROTOCOL_ERROR 的连接错误(章节 5.4.1)。

**open**

处于 "open" 状态的流可以被两端用来发送任何类型的帧。在这种状态下，发送端遵守被通告流级别的流量控制限制(章节 5.2)。

在这种状态下，任何一端都可以发送带有 END_STREAM 标志的帧，这会导致流过渡到 "helf-closed" 状态之一。终端发送 END_STREAM 标志会导致流状态变为 "half-closed (local)"; 终端接收到 END_STREAM 标志会导致流状态变为 "half-closed (remote)"。

任何一端都可以从这个状态发送一个 RST_STREAM 帧，使其立即过渡到 "closed" 状态。

**half-closed (local)**

处于 "half-closed (local)" 状态的流不能用于发送帧，只能用于 WINDOW_UPDATE、PRIORITY 和 RST_STREAM。

当接收到设置了 END_STREAM 标志的帧或任何一端发送了 RST_STREAM 帧时，流从这种状态转换为 "closed" 状态。

在这种状态下，终端可以接收任何类型的帧。使用 WINDOW_UPDATE 帧提供流量控制信用值对于继续接收流量控制帧是必要的。在这种状态下，接收端可以忽略 WINDOW_UPDATE 帧，因为 WINDOW_UPDATE 帧可能会在发送带有 END_STREAM 标志的帧之后的一小段时间内到达。

在这个状态下可以接收到 PRIORITY 帧。

**half-closed (remote)**

"half-closed (remote)" 的流不再被对等端用来发送帧。在这种状态下，终端不再需要维护接收者流量控制窗口。

如果终端接收到 WINDOW_UPDATE、PRIORITY 或 RST_STREAM 以外的其他帧，并且流处于这种状态，它必须响应一个类型为 STREAM_CLOSED 的流错误(章节 5.4.2)。

"half-closed (remote)" 的流可以被终端用来发送任何类型的帧。在这种状态下，端点会继续遵守通告流级别的流量控制限制(章节5.2)。

流可以通过发送设置了 END_STREAM 标志的帧或者任何一端发送 RST_STREAM 帧来从这种状态过渡到 "closed" 状态。

**closed**

"closed" 状态是终端状态。

在终端发送和接收设置了 END_STREAM 标志的帧后，流进入 "closed" 状态。在终端发送或接收 RST_STREAM 帧后，流也会进入 "closed" 状态。

终端不能在已关闭的流上发送除 PRIORITY 以外的帧。终端可以将在已关闭流上接收到的任何其他类型的帧视为类型为 STREAM_CLOSED 的连接错误(章节 5.4.1)，除非如下所述。

一个发送带有 END_STREAM 标志的帧或 RST_STREAM 帧的终端可能会从它的对等端接收到 WINDOW_UPDATE 或 RST_STREAM 帧，这可能是在它接收到并处理关闭流的帧之前的时间。

在处于 "open" 或 "half-closed (local)" 状态的流上发送 RST_STREAM 帧的端点可以接收任何类型的帧。在处理 RST_STREAM 帧之前，端可能已经发送或排队等待发送这些帧。终端必须最低限度地处理然后丢弃在这种状态下接收到的任何帧。这意味着更新 HEADERS 和 PUSH_PROMISE 帧的报头压缩状态。接收到 PUSH_PROMISE 帧也会导致被承诺流变为 "reserved (remote)"，即使是在已关闭的流上接收到 PUSH_PROMISE 帧时也是如此。此外，数据框的内容计入连接流量控制窗口。

终端可以对所有处于 "closed" 状态的流执行这种最小的处理。终端可以使用其他信号来检测一端已经接收到导致流进入 "closed" 状态的帧，并将接收到的除 PRIORITY 以外的任何帧视为类型为协议错误的连接错误(章节5.4.1)。端点可以使用帧来指示另一端已经接收到关闭信号来驱动这一过程。端点不应该为此使用定时器。例如，终端在关闭流后发送 SETTINGS 帧，在收到设置确认后，可以安全地将该流上的 DATA 帧视为错误。其他可能会用到的功能包括 PING 帧、在关闭流后创建的流上接收数据，或者响应关闭流后创建的请求。

在没有更具体规则的情况下，实现应该将接收到的状态描述中没有明确允许的帧作为类型为协议错误的连接错误(章节5.4.1)处理。注意，PRIORITY 可以在任何流状态下发送和接收。

本节中的规则仅适用于本文档中定义的框架。接收到语义未知的帧不能被视为错误，因为发送和接收这些帧的条件也是未知的。参见 5.5 节。

HTTP 请求/响应交换的状态转换示例可以在 8.8 节中找到。在 8.4.1 节和 8.4.2 节可以找到服务器推送的状态转换示例。

#### 5.1.1. Stream Identifiers

流由一个 31 位无符号整数标识。由客户端发起的流必须使用奇数的流标识符;由服务器发起的流必须使用偶数流标识符。0 的流标识符 (0x00) 用于连接控制消息;流标识符 0 不能用于建立新的流。

新建立流的标识符必须在数字上大于起始端点已打开或保留的所有流。它管理使用报头帧打开的流和使用 PUSH_PROMISE 保留的流。接收到意外流标识符的端点必须响应类型为 PROTOCOL_ERROR 的连接错误(章节5.4.1)。

HEADER 帧将由帧头中的流标识符标识的客户端发起的流从 "idle" 转换为 "open"。PUSH_PROMISE 帧会将由承诺流 ID 字段在帧负载中标识的服务器启动流从 "idle" 转换为 "reserved (local)" 或 "reserved (remote)"。当流从 "idle" 状态转换出来时，所有处于 "idle" 状态的流，如果被流标识符值较低的对端打开，将立即转换为 "closed" 状态。也就是说，端点可以跳过流标识符，其效果是被跳过的流立即被关闭。

流标识符不能重用。长时间的连接可能导致端点耗尽可用的流标识符范围。无法建立新流标识符的客户端可以为新流建立新连接。无法建立新的流标识符的服务器可以发送超时帧，这样客户端就被迫为新的流打开一个新连接。

#### 5.1.2. Stream Concurrency

另一端可以在 SETTINGS 帧中使用 SETTINGS_MAX_CONCURRENT_STREAMS 参数(参见 6.5.2 节)来限制并发活动流的数量。最大并发流设置是特定于每个端点的，只适用于接收该设置的一端。也就是说，客户端指定服务器可以发起的最大并发流数，服务器指定客户端可以发起的最大并发流数。

处于 "open" 状态或处于 "half-closed" 状态的流计数为终端允许打开的最大流数。处于这三种状态的流都会计入 SETTINGS_MAX_CONCURRENT_STREAMS 设置中公布的限制。处于任何一种 "reserved" 状态的流都不计入流的限制。

端点不能超过其对等体设置的限制。端点收到报头帧导致其发布的并发流超过限制，必须将其视为类型为 PROTOCOL_ERROR 或 REFUSED_STREAM 的流错误(章节 5.4.2)。错误码的选择决定了端点是否希望启用自动重试(详细信息参见 8.7 节)。

如果终端希望 SETTINGS_MAX_CONCURRENT_STREAMS 的值小于当前打开的流数，可以关闭超过这个值的流，或者允许流完成。

### 5.2. Flow Control

使用流进行多路复用会引起 TCP 连接的争用，从而导致流阻塞。流量控制方案确保同一个连接上的流不会相互干扰。流量控制既用于单个流，也用于整个连接。

HTTP/2 通过使用 WINDOW_UPDATE 帧(章节6.9)提供流量控制。

#### 5.2.1. Flow-Control Principles

HTTP/2 流流量控制的目的是在不改变协议的情况下允许使用各种流量控制算法。HTTP/2 中的流量控制具有以下特点:

1. 流量控制是特定于连接的。HTTP/2 流量控制在单跳端点之间进行，而不是在整个端到端路径上进行。
2. 流量控制基于 WINDOW_UPDATE 帧。接收端通告他们准备在流上以及整个连接中接收多少个字节。这是一个基于信用的计划。
3. 流量控制是定向的，由接收器提供整体控制。接收方可以为每个流和整个连接设置所需的任何窗口大小。发送端必须遵守接收端的流量控制限制。客户端、服务器和中间设备都独立地将它们的流量控制窗口作为接收端通告，并在发送时遵守其他节点设置的流量控制限制。
4. 对于新流和整个连接，流量控制窗口的初始值都是 65,535 字节。
5. 帧类型决定了流控制是否适用于帧。在本文档中指定的帧中，只有 DATA 帧受流量控制;所有其他帧类型都不占用所通告的流量控制窗口的空间。这确保了重要的控制帧不会被流量控制阻塞。
6. 终端可以选择禁用自己的流量控制，但终端不能忽略来自另一端的流量控制信号。
7. HTTP/2 只定义了 WINDOW_UPDATE 帧的格式和语义(章节6.9)。这个文档没有规定接收方如何决定何时发送这个帧或它发送的值，也没有规定发送方如何选择发送数据包。实现可以选择满足需求的任何算法。

实现还负责发送请求和响应的优先级，选择如何避免请求的队首阻塞，以及管理新流的创建。它们的算法选择可以与任何流控制算法交互。

#### 5.2.2. Appropriate Use of Flow Control

流量控制是为了保护在资源限制下运行的端点。例如，一个代理需要在多个连接之间共享内存，也可能有一个缓慢的上游连接和一个快速的下游连接。流量控制解决了接收端无法在一个流上处理数据，但希望在同一个连接上继续处理其他流的情况。

不需要这个功能的部署可以通告一个最大大小的流量控制窗口 (231-1)，并且可以在接收到数据时发送一个 WINDOW_UPDATE 帧来维护这个窗口。这实际上禁用了对该接收端的流量控制。相反，发送端总是受制于接收端通告的流量控制窗口。

在资源受限(例如内存)的部署中，可以采用流量控制来限制一端可以消耗的内存数量。但是，请注意，如果在不知道 带宽*延迟乘积 的情况下启用流量控制，这可能导致可用网络资源的次优使用(参见 [RFC7323])。

即使完全了解当前的 带宽*延迟 乘积，实现流量控制也是很困难的。一旦数据可用，终端必须从 TCP 接收缓冲区读取并处理 HTTP/2 帧。如果不能及时读取关键帧(如 WINDOW_UPDATE)，可能会导致死锁。及时读取帧不会让终端面临资源耗尽攻击，因为 HTTP/2 流量控制限制了资源承诺。

#### 5.2.3. Flow-Control Performance

如果一个端点不能确保它的端在这个连接上始终有大于另一端 带宽*延迟乘积 的可用流量控制窗口空间，它的接收吞吐量将受到 HTTP/2 流量控制的限制。这将导致性能下降。

及时发送 WINDOW_UPDATE 帧可以提高性能。终端需要在提高接收吞吐量的需求和管理资源耗尽风险的需求之间取得平衡，在定义管理窗口大小的策略时，应该仔细注意 10.5 节。

### 5.3. Prioritization

在 HTTP/2 这样的多路复用协议中，优先分配带宽和计算资源给流是获得良好性能的关键。一个糟糕的优先级方案会导致 HTTP/2 性能不佳。如果 TCP 层没有并行，性能可能会比 HTTP/1.1 差得多。

一个好的优先级方案受益于上下文知识的应用，例如资源的内容，资源如何相互关联，以及这些资源将如何被对等节点使用。特别是，客户端可以掌握与服务器优先级相关的请求优先级信息。在这些情况下，让客户端提供优先级信息可以提高性能。

#### 5.3.1. Background on Priority in RFC 7540

RFC 7540 定义了一个用于发送请求优先级的丰富系统。然而，这个系统被证明是复杂的，并且没有统一实施。

灵活的方案意味着客户有可能以非常不同的方式表达优先级，而所采用的方法几乎没有一致性。对于服务器，实现对该方案的通用支持很复杂。优先级的实施在客户端和服务器上都是不平衡的。许多服务器部署在优先处理请求时忽略了客户端信号。

简而言之，RFC 7540 [ RFC7540 ]中的优先级信令并不成功。

#### 5.3.2. Priority Signaling in This Document

对 HTTP/2 的这次更新弃用了RFC 7540 [ RFC7540 ]中定义的优先级信号。与优先信号相关的大部分文本未包含在本文档中。保留帧字段的描述和一些强制性处理，以确保本文档的实现与使用 RFC 7540 中描述的优先级信号的实现保持互操作性。

[ RFC7540 ]的第 5.3 节中保留了对 RFC 7540 优先级方案的详尽描述。

在许多情况下，信令优先级信息是获得良好性能所必需的。在信令优先级信息很重要的地方，鼓励端点使用替代方案，例如[ HTTP-PRIORITY ]中描述的方案。

虽然来自 RFC 7540 的优先级信令没有被广泛采用，但它提供的信息在没有更好信息的情况下仍然有用。在HEADERS或PRIORITY帧中接收优先级信号的端点可以从应用该信息中受益。特别是，在没有替代方案的情况下，使用这些信号的实现不会从丢弃这些优先级信号中获益。

在没有任何优先级信号的情况下，服务器应该使用其他上下文信息来确定请求的优先级。服务器可以将完全没有信号解释为客户端尚未实现该功能的指示。[ RFC7540 ]第 5.3.5 节中描述的默认值在大多数情况下性能不佳，不太可能是故意使用它们。

### 5.4. Error Handing

HTTP/2 框架允许两类错误：

- 导致整个连接不可用的错误情况是连接错误。
- 单个流中的错误是流错误。

错误代码列表包含在第 7 节中。

端点可能会遇到会导致多个错误的帧。实现可能会在处理过程中发现多个错误，但它们最多应该报告一个流和一个连接错误作为结果。

为给定流报告的第一个流错误会阻止报告该流上的任何其他错误。相比之下，该协议允许多个GOAWAY帧，尽管端点应该只报告一种类型的连接错误，除非在正常关闭期间遇到错误。如果发生这种情况，除了包含NO_ERROR的任何先前 GOAWAY 之外，端点可以发送一个带有新错误代码的附加 GOAWAY 帧。

如果端点检测到多个不同的错误，它可以选择报告这些错误中的任何一个。如果帧导致连接错误，则必须报告该错误。此外，端点在检测到错误条件时可以使用任何适用的错误代码；一般错误代码（例如PROTOCOL_ERROR或INTERNAL_ERROR）总是可以用来代替更具体的错误代码。

#### 5.4.1. Connection Error Handing

连接错误是阻止进一步处理帧层或破坏任何连接状态的任何错误。

遇到连接错误的端点应该首先发送一个GOAWAY 帧（第 6.8 节），其中包含它从其对等方成功接收到的最后一个流的流标识符。GOAWAY帧包含一个错误代码（第 7 节），指示连接终止的原因。在为错误条件发送 GOAWAY帧后，端点必须关闭 TCP 连接。

接收端点可能无法可靠地接收到GOAWAY 。在连接错误的情况下， GOAWAY仅提供最大努力尝试与对等方就连接终止的原因进行通信。

端点可以随时结束连接。特别是，端点可以选择将流错误视为连接错误。如果环境允许，端点应该在结束连接时发送一个 GOAWAY帧。

#### 5.4.2. Stream Error Handing

流错误是与特定流相关的错误，不会影响其他流的处理。

检测到流错误的端点发送RST_STREAM帧（第 6.4 节），其中包含发生错误的流的流标识符。RST_STREAM帧包含指示错误类型的错误代码。

RST_STREAM是端点可以在流上发送的最后一帧。发送RST_STREAM帧的对等方必须准备好接收任何由远程对等方发送或排队等待发送的帧。这些帧可以忽略，除非它们修改连接状态（例如为 字段部分压缩（第 4.3 节）或流量控制维护的状态）。

通常，端点不应该为任何流发送超过一个RST_STREAM帧。但是，如果端点在超过往返时间后在关闭的流上接收到帧，则它可以发送额外的RST_STREAM帧。允许此行为来处理行为不当的实现。

为避免循环，端点不得发送RST_STREAM以响应 RST_STREAM帧。

#### 5.4.3. Connection Termination

如果在流保持“打开”或“半关闭”状态时关闭或重置 TCP 连接，则受影响的流无法自动重试（有关详细信息，请参阅第 8.7 节）。

### 5.5. Extending HTTP/2

HTTP/2 允许扩展协议。在本节描述的限制范围内，协议扩展可用于提供附加服务或改变协议的任何方面。扩展仅在单个 HTTP/2 连接范围内有效。

这适用于本文档中定义的协议元素。这不会影响用于扩展 HTTP 的现有选项，例如定义新方法、状态代码或字段（请参阅[ HTTP ]的第 16 节）。

允许扩展使用新的帧类型（第 4.1 节）、新的 设置（第 6.5 节）或新的错误代码（第 7 节）。用于管理这些扩展点的注册表在[ RFC7540 ]的第 11 节中定义。

实现必须忽略所有可扩展协议元素中的未知或不支持的值。实现必须丢弃具有未知或不支持类型的帧。这意味着这些扩展点中的任何一个都可以被扩展安全地使用，而无需事先安排或协商。但是，不允许出现在字段块中间的扩展帧（第 4.3 节） ；这些必须被视为PROTOCOL_ERROR类型的 连接错误（第 5.4.1 节）。

扩展应该避免改变本文档中定义的协议元素或没有定义扩展机制的元素。这包括对帧布局的更改、对帧组成HTTP 消息（第 8.1 节）的方式的添加或更改、伪标头字段的定义，或对合规端点可能视为连接的任何协议元素的更改错误（第 5.4.1 节）。

更改现有协议元素或状态的扩展必须在使用前协商。例如，更改HEADERS框架布局的扩展不能使用，直到对等方给出一个积极的信号表明这是可以接受的。在这种情况下，也可能需要在修改后的布局生效时进行协调。例如，将DATA帧以外的帧视为流量控制需要更改两端点都需要理解的语义，因此这只能通过协商来完成。

本文档没有强制要求使用特定方法来协商扩展的使用，但指出可以为此目的使用一个设置（第 6.5.2 节） 。如果两个对等点都设置了一个值，表示愿意使用该扩展，则可以使用该扩展。如果设置用于扩展协商，则初始值必须以扩展最初被禁用的方式定义。

## 6. Frame Definitions

本规范定义了多种帧类型，每种帧类型由唯一的 8 位类型代码标识。每种帧类型在连接作为一个整体或单个流的建立和管理中都有不同的用途。

特定帧类型的传输可以改变连接的状态。如果端点无法保持连接状态的同步视图，则连接内的成功通信将不再可能。因此，端点对使用任何给定框架如何影响状态有一个共同的理解是很重要的。

### 6.1. DATA

数据帧（类型=0x00）传送与流关联的任意可变长度的八位字节序列。例如，一个或多个数据帧用于携带 HTTP 请求或响应消息内容。

数据帧也可以包含填充。填充可以添加到 DATA 帧以掩盖消息的大小。填充是一项安全功能；参见第 10.7 节。

```
DATA Frame {
  Length (24),
  Type (8) = 0x00,

  Unused Flags (4),
  PADDED Flag (1),
  Unused Flags (2),
  END_STREAM Flag (1),

  Reserved (1),
  Stream Identifier (31),

  [Pad Length (8)],
  Data (..),
  Padding (..2040),
}
```

长度、类型、未使用标志、保留和流标识符字段在第 4 节中描述。数据帧包含以下附加字段：

- padding 长度：一个 8 位字段，包含以八位字节为单位的帧填充长度。该字段是有条件的，仅当设置了 PADDED 标志时才存在。
- 数据：应用程序数据。数据量是帧有效载荷减去存在的其他字段的长度后的剩余部分。
- 填充：不包含应用程序语义值的填充八位字节。发送时填充八位字节必须设置为零。接收方没有义务验证填充，但可以将非零填充视为PROTOCOL_ERROR类型的连接错误（第 5.4.1 节）。

数据帧定义了以下标志：

- 填充（0x08）：设置后，PADDED 标志表示 Pad Length 字段及其描述的任何填充都存在。
- 结束流（0x01）：设置后，END_STREAM 标志指示此帧是端点将为已识别流发送的最后一帧。设置此标志会导致流进入“半关闭”状态或“关闭”状态之一（第 5.1 节）。

> 注意：在发送所有数据后了解流关闭的端点可以通过发送具有零长度数据字段和 END_STREAM 标志集的 STREAM 帧来关闭流。这只有在端点不发送尾部时才有可能，因为在这种情况下 END_STREAM 标志出现在 HEADERS 帧上；参见第 8.1 节。

数据帧必须与流关联。如果接收到流标识符字段为 0x00 的数据帧，接收方必须响应类型为 PROTOCOL_ERROR 的连接错误（第 5.4.1 节）。

DATA 帧受流量控制，只能在流处于“打开”或“半关闭（远程）”状态时发送。整个 DATA 帧有效负载包含在流量控制中，包括 Pad Length 和 Padding 字段（如果存在）。如果接收到的数据帧的流不处于“打开”或“半关闭（本地）”状态，则接收方必须响应类型为 STREAM_CLOSED 的流错误（第 5.4.2 节）。

填充八位字节的总数由填充长度字段的值确定。如果填充的长度是帧有效载荷的长度或更大，接收方 必须将其视为 PROTOCOL_ERROR 类型的连接错误（第 5.4.1 节）。

> 注意：通过包含值为零的填充长度字段，可以将帧的大小增加一个八位字节。

### 6.2. HEADERS

HEADERS 帧（type=0x01）用于打开流（第 5.1 节），另外还携带一个字段块片段。尽管名称如此，但 HEADERS 框架可以携带标题部分或尾部部分。HEADERS 帧可以在“空闲”、“保留（本地）”、“打开”或“半关闭（远程）”状态下在流上发送。

```
HEADERS Frame {
  Length (24),
  Type (8) = 0x01,

  Unused Flags (2),
  PRIORITY Flag (1),
  Unused Flag (1),
  PADDED Flag (1),
  END_HEADERS Flag (1),
  Unused Flag (1),
  END_STREAM Flag (1),

  Reserved (1),
  Stream Identifier (31),

  [Pad Length (8)],
  [Exclusive (1)],
  [Stream Dependency (31)],
  [Weight (8)],
  Field Block Fragment (..),
  Padding (..2040),
}
```

长度、类型、未使用标志、保留和流标识符字段在第 4 节中描述。HEADERS 帧有效负载具有以下附加字段：

- padding 长度： 一个 8 位字段，包含以八位字节为单位的帧填充长度。该字段仅在设置了 PADDED 标志时存在。
- Exclusive： 一位标志。该字段仅在设置了 PRIORITY 标志时出现。HEADERS 帧中的优先级信号已弃用；参见第 5.3.2 节。
- Stream Dependency： 一个 31 位的流标识符。该字段仅在设置了 PRIORITY 标志时出现。
- Weight： 一个无符号的 8 位整数。该字段仅在设置了 PRIORITY 标志时出现。
- Field Block Fragment： 字段块片段（第4.3 节）。
- 填充： 不包含应用程序语义值的填充八位字节。发送时填充八位字节必须设置为零。接收方没有义务验证填充，但可以将非零填充视为 PROTOCOL_ERROR 类型的连接错误（第 5.4.1 节）。

HEADERS 帧定义了以下标志：

- 优先级（0x20）：设置时，PRIORITY 标志指示存在 Exclusive、Stream Dependency 和 Weight 字段。
- 填充（0x08）：设置后，PADDED 标志表示 Pad Length 字段及其描述的任何填充都存在。
- END_HEADERS (0x04): 设置时，END_HEADERS 标志指示此帧包含整个字段块（第 4.3 节）并且后面没有任何 CONTINUATION帧。没有设置 END_HEADERS 标志的 HEADERS 帧必须跟在 同一流的CONTINUATION帧之后。接收方必须将任何其他类型的帧或不同流上的帧的接收视为PROTOCOL_ERROR类型的 连接错误（第 5.4.1 节）。
- 结束流（0x01）：设置时，END_STREAM 标志指示字段块（第 4.3 节）是端点将为已识别流发送的最后一个。设置了 END_STREAM 标志的 HEADERS 帧表示流的结束。但是，设置了 END_STREAM 标志的 HEADERS 帧后面可以跟 在同一流上的 CONTINUATION 帧。从逻辑上讲， CONTINUATION 帧是 HEADERS 帧的一部分。

HEADERS 帧的帧负载包含一个字段块片段（第 4.3 节）。不适合 HEADERS 帧的字段块在 CONTINUATION 帧中继续（第 6.10 节）。

HEADERS 帧必须与流相关联。如果接收到流标识符字段为 0x00 的 HEADERS 帧，则接收方必须响应类型为 PROTOCOL_ERROR 的连接错误（第 5.4.1 节）。

HEADERS 帧改变连接状态，如第 4.3 节所述。

填充八位字节的总数由填充长度字段的值确定。如果填充的长度是帧有效载荷的长度或更大，接收方 必须将其视为 PROTOCOL_ERROR 类型的连接错误（第 5.4.1 节）。

注意：通过包含值为零的填充长度字段，可以将帧的大小增加一个八位字节。

### 6.3. PRIORITY

PRIORITY 帧（type=0x02）已弃用；参见第 5.3.2 节。PRIORITY 帧可以在任何流状态下发送，包括空闲或关闭的流。

```
PRIORITY Frame {
  Length (24) = 0x05,
  Type (8) = 0x02,

  Unused Flags (8),

  Reserved (1),
  Stream Identifier (31),

  Exclusive (1),
  Stream Dependency (31),
  Weight (8),
}
```

长度、类型、未使用标志、保留和流标识符字段在第 4 节中描述。PRIORITY 帧的帧有效载荷包含以下附加字段：

Exclusive：一位标志。
Stream Dependency：一个 31 位的流标识符。
Weight：一个无符号的 8 位整数。

PRIORITY 帧不定义任何标志。

PRIORITY 帧总是标识一个流。如果接收到一个流标识符为 0x00 的 PRIORITY 帧，接收方必须响应一个类型为 PROTOCOL_ERROR 的连接错误（第 5.4.1 节）。

发送或接收优先级帧不会影响任何流的状态（第 5.1 节）。PRIORITY 帧可以在任何状态下在流上发送，包括“空闲”或“关闭”。PRIORITY 帧不能在包含单个字段块的连续帧之间发送（第 4.3 节）。

长度不是 5 个八位字节的 PRIORITY 帧必须被视为 FRAME_SIZE_ERROR 类型的流错误（第 5.4.2 节）。

### 6.4. RST_STREAM

RST_STREAM 帧（类型=0x03）允许立即终止流。发送 RST_STREAM 以请求取消流或指示已发生错误情况。

```
RST_STREAM Frame {
  Length (24) = 0x04,
  Type (8) = 0x03,

  Unused Flags (8),

  Reserved (1),
  Stream Identifier (31),

  Error Code (32),
}
```

长度、类型、未使用标志、保留和流标识符字段在第 4 节中描述。此外，RST_STREAM 帧包含一个无符号的 32 位整数，用于标识错误代码（第 7 节）。错误代码指示流被终止的原因。

RST_STREAM 帧没有定义任何标志。

RST_STREAM 帧完全终止引用流并使其进入“关闭”状态。在流上接收到 RST_STREAM 后，接收方不得为该流发送额外的帧，PRIORITY除外。但是，在发送 RST_STREAM 之后，发送端点必须准备好接收和处理在 RST_STREAM 到达之前对等方可能已经发送的在流上发送的额外帧。

RST_STREAM 帧必须与流关联。如果接收到流标识符为 0x00 的 RST_STREAM 帧，接收方必须将其视为 PROTOCOL_ERROR 类型的 连接错误（第 5.4.1 节）。

不得为处于“空闲”状态的流发送RST_STREAM 帧。如果接收到标识空闲流的 RST_STREAM 帧，接收方必须将其视为 PROTOCOL_ERROR 类型的 连接错误（第 5.4.1 节）。

长度不是 4 个八位字节的 RST_STREAM 帧必须被视为 FRAME_SIZE_ERROR 类型的 连接错误（第 5.4.1 节）。

### 6.5. SETTINGS

SETTINGS 帧（类型=0x04）传达影响端点通信方式的配置参数，例如对端点行为的偏好和约束。SETTINGS 框架也用于确认收到这些设置。单独地，来自 SETTINGS 帧的配置参数被称为“设置”。

设置方式是非协商的；它们描述了发送方的特征，这些特征被接收方使用。每个对等点可以通告相同设置的不同值。例如，客户端可能会设置一个较高的初始流量控制窗口，而服务器可能会设置一个较低的值以节省资源。

SETTINGS 帧必须在连接开始时由两个端点发送，并且可以在连接生命周期内的任何其他时间由任何一个端点发送。实现必须支持本规范定义的所有设置。

SETTINGS 框架中的每个参数都会替换该参数的任何现有值。设置按照它们出现的顺序进行处理，并且 SETTINGS 帧的接收者不需要维护除了每个设置的当前值之外的任何状态。因此，SETTINGS 参数的值是接收者看到的最后一个值。

SETTINGS 帧由接收方确认。为了启用它，SETTINGS 帧定义了 ACK 标志：

确认（0x01）：设置后，ACK 标志表示此帧确认接收和应用对等方的 SETTINGS 帧。设置此位时，SETTINGS 帧的帧有效负载必须为空。收到设置了 ACK 标志且长度字段值不是 0 的 SETTINGS 帧必须被视为 FRAME_SIZE_ERROR 类型的连接错误（第 5.4.1 节）。有关详细信息，请参阅第 6.5.3 节（“设置同步”）。
SETTINGS 帧始终应用于连接，而不是单个流。SETTINGS 帧的流标识符必须为零 (0x00)。如果一个端点接收到一个 SETTINGS 帧，其 Stream Identifier 字段不是 0x00，端点必须响应一个PROTOCOL_ERROR 类型的 连接错误（第 5.4.1 节）。

SETTINGS 帧影响连接状态。格式错误或不完整的 SETTINGS 帧 必须被视为 PROTOCOL_ERROR 类型的连接错误（第 5.4.1 节）。

长度不是 6 个八位字节的倍数的 SETTINGS 帧必须被视为 FRAME_SIZE_ERROR 类型的连接错误（第 5.4.1 节）。

#### 6.5.1. SETTINGS Format

SETTINGS 帧的帧有效载荷由零个或多个设置组成，每个设置由一个无符号的 16 位设置标识符和一个无符号的 32 位值组成。

```
SETTINGS Frame {
  Length (24),
  Type (8) = 0x04,

  Unused Flags (7),
  ACK Flag (1),

  Reserved (1),
  Stream Identifier (31) = 0,

  Setting (48) ...,
}

Setting {
  Identifier (16),
  Value (32),
}
```

长度、类型、未使用标志、保留和流标识符字段在第 4 节中描述。SETTINGS 帧的帧负载包含任意数量的设置字段，每个字段包括：

- Identifier：一个 16 位的设置标识符；参见第 6.5.2 节。
- Value：设置的 32 位值。

#### 6.5.2. Defined Settings

定义了以下设置：

- SETTINGS_HEADER_TABLE_SIZE (0x01): 此设置允许发送方以八位字节为单位通知远程端点用于解码字段块的压缩表的最大大小。编码器可以通过使用特定于字段块内压缩格式的信号来选择等于或小于此值的任何大小（请参阅[ COMPRESSION ]）。初始值为 4,096 个八位字节。
- SETTINGS_ENABLE_PUSH (0x02): 此设置可用于启用或禁用服务器推送。如果服务器收到此参数设置为 0 的值，则不得发送 PUSH_PROMISE帧；参见第 8.4 节。已将此参数设置为 0 并已确认的客户端必须将PUSH_PROMISE帧的接收视为PROTOCOL_ERROR类型的连接错误（第 5.4.1 节）。SETTINGS_ENABLE_PUSH 的初始值为 1。对于客户端来说，这个值表示它愿意接收 PUSH_PROMISE 帧。对于服务器，这个初始值没有影响，等同于值 0。除 0 或 1 之外的任何值都必须被视为 PROTOCOL_ERROR类型的 连接错误（第 5.4.1 节）。服务器不得显式将此值设置为 1。服务器可以在发送 SETTINGS 帧时选择忽略此设置，但如果服务器确实包含一个值，则它必须 为 0。客户端必须将收到的 SETTINGS 帧视为SETTINGS_ENABLE_PUSH 设置为 1 作为PROTOCOL_ERROR类型的 连接错误（第 5.4.1 节）。
- SETTINGS_MAX_CONCURRENT_STREAMS (0x03): 此设置指示发送方将允许的最大并发流数。这个限制是有方向的：它适用于发送方允许接收方创建的流的数量。最初，此值没有限制。建议该值不小于100，以免不必要地限制并行度。端点不应将SETTINGS_MAX_CONCURRENT_STREAMS 的值 0视为特殊值。零值确实会阻止创建新流；但是，对于活动流耗尽的任何限制，也可能发生这种情况。服务器 应该只在短时间内设置零值；如果服务器不想接受请求，则关闭连接更为合适。
- SETTINGS_INITIAL_WINDOW_SIZE (0x04): 此设置指示发送方用于流级流量控制的初始窗口大小（以八位字节为单位）。初始值为 2 16 -1 (65,535) 个八位字节。此设置会影响所有流的窗口大小（请参阅第 6.9.2 节）。大于最大流量控制窗口大小 2 31 -1的值必须 被视为FLOW_CONTROL_ERROR类型的连接错误（第 5.4.1 节）。
- SETTINGS_MAX_FRAME_SIZE (0x05): 此设置指示发送方愿意接收的最大帧有效负载的大小，以八位字节为单位。初始值为 2 14 (16,384) 个八位字节。端点通告的值必须介于此初始值和允许的最大帧大小（2 24 -1 或 16,777,215 个八位字节）之间，包括在内。超出此范围的值 必须被视为PROTOCOL_ERROR 类型的连接错误（第 5.4.1 节）。
- SETTINGS_MAX_HEADER_LIST_SIZE (0x06): 此建议设置以八位字节为单位通知对等方发送方准备接受的最大字段部分大小。该值基于字段行的未压缩大小，包括以八位字节为单位的名称和值的长度加上每个字段行的 32 个八位字节的开销。

对于任何给定的请求，可以强制执行低于所公布的限制。此设置的初始值是无限制的。

接收到带有任何未知或不支持标识符的 SETTINGS 帧的端点 必须忽略该设置。

#### 6.5.3. Settins Synchronization

SETTINGS 中的大多数值受益于或需要了解对等方何时收到并应用更改的参数值。为了提供这样的同步时间点，未设置 ACK 标志的 SETTINGS 帧的接收者必须在收到后尽快应用更新的设置。SETTINGS 帧按照它们被接收的顺序被确认。

SETTINGS 帧中的值必须按照它们出现的顺序进行处理，值之间没有其他帧处理。必须忽略不受支持的设置。一旦处理完所有值，接收方必须立即发出一个设置了 ACK 标志的 SETTINGS 帧。在接收到设置了 ACK 标志的 SETTINGS 帧后，更改设置的发送方可以依赖已应用的最旧的未确认 SETTINGS 帧中的值。

如果 SETTINGS 帧的发送者在合理的时间内没有收到确认，它可能会发出一个 SETTINGS_TIMEOUT 类型的连接错误（第 5.4.1 节）。在设置超时时，需要为对等方的处理延迟留出一些余地；仅基于端点之间的往返时间的超时可能会导致虚假错误。

### 6.6. PUSH_PROMISE

PUSH_PROMISE 帧（类型=0x05）用于提前通知对等端点发送方打算发起的流。PUSH_PROMISE 帧包括端点计划创建的流的无符号 31 位标识符以及为流提供额外上下文的字段部分。 第 8.4 节包含对 PUSH_PROMISE 帧的使用的详尽描述。

```
PUSH_PROMISE Frame {
  Length (24),
  Type (8) = 0x05,

  Unused Flags (4),
  PADDED Flag (1),
  END_HEADERS Flag (1),
  Unused Flags (2),

  Reserved (1),
  Stream Identifier (31),

  [Pad Length (8)],
  Reserved (1),
  Promised Stream ID (31),
  Field Block Fragment (..),
  Padding (..2040),
}
```

长度、类型、未使用标志、保留和流标识符字段在第 4 节中描述。PUSH_PROMISE 帧有效负载具有以下附加字段：

- Pad 长度：一个 8 位字段，包含以八位字节为单位的帧填充长度。该字段仅在设置了 PADDED 标志时存在。
- Promised Stream ID：一个无符号的 31 位整数，用于标识由 PUSH_PROMISE 保留的流。承诺的流标识符必须是发送方发送的下一个流的有效选择（参见第 5.1.1 节中的“新流标识符” ）。
- Field Block Fragment：包含请求控制数据和标头部分的字段块片段（第4.3 节） 。
- Padding：不包含应用程序语义值的填充八位字节。发送时填充八位字节必须设置为零。接收方没有义务验证填充，但可以将非零填充视为 PROTOCOL_ERROR 类型的连接错误（第 5.4.1 节）。

PUSH_PROMISE 帧定义了以下标志：
- 填充（0x08）：设置后，PADDED 标志表示 Pad Length 字段及其描述的任何填充都存在。
- END_HEADERS (0x04): 设置时，END_HEADERS 标志指示此帧包含整个字段块（第 4.3 节）并且后面没有任何 CONTINUATION 帧。没有设置 END_HEADERS 标志的 PUSH_PROMISE 帧必须跟在同一流的 CONTINUATION 帧之后。接收方必须将任何其他类型的帧或不同流上的帧的接收视为PROTOCOL_ERROR类型的 连接错误（第 5.4.1 节）。

PUSH_PROMISE 帧必须仅在处于“打开”或“半关闭（远程）”状态的对等发起的流上发送。PUSH_PROMISE 帧的流标识符指示与其关联的流。如果流标识符字段指定值 0x00，接收者必须响应类型为 PROTOCOL_ERROR 的连接错误（第 5.4.1 节）。承诺的流不需要按照承诺的顺序使用。PUSH_PROMISE 只保留流标识符供以后使用。如果对等端点的SETTINGS_ENABLE_PUSH设置设置为 0，则不得发送PUSH_PROMISE 。已设置此设置并已收到确认的端点必须将 PUSH_PROMISE 帧的接收视为 PROTOCOL_ERROR 类型的连接错误（第 5.4.1 节） .

PUSH_PROMISE 帧的接收者可以通过将引用承诺的流标识符的 RST_STREAM 返回给 PUSH_PROMISE 的发送者来选择拒绝承诺的流 。

PUSH_PROMISE 帧以两种方式修改连接状态。首先，包含一个字段块（第 4.3 节）可能会修改为字段部分压缩维护的状态。其次，PUSH_PROMISE 还保留了一个流供以后使用，使承诺的流进入“保留（本地）”或“保留（远程）”状态。发送者不得在流上发送 PUSH_PROMISE，除非该流是“打开”或“半关闭（远程）”；发送方必须确保承诺的流是新流标识符 的有效选择（第 5.1.1 节）（即，承诺的流必须 处于“空闲”状态）。

由于 PUSH_PROMISE 保留流，忽略 PUSH_PROMISE 帧会导致流状态变得不确定。接收方必须将在既不是“打开”也不是“半关闭（本地）”的流上接收到 PUSH_PROMISE 视为类型为 PROTOCOL_ERROR 的连接错误（第 5.4.1 节）。然而，已经 在相关流上发送RST_STREAM 的端点必须处理可能在 RST_STREAM 帧被接收和处理之前创建的 PUSH_PROMISE 帧。

接收方必须将承诺非法流标识符（第 5.1.1 节）的 PUSH_PROMISE 的接收视为 PROTOCOL_ERROR 类型的 连接错误（第 5.4.1 节）。注意，非法流标识符是当前不处于“空闲”状态的流的标识符。

填充八位字节的总数由填充长度字段的值确定。如果填充的长度是帧有效载荷的长度或更大，接收方 必须将其视为PROTOCOL_ERROR类型的连接错误（第 5.4.1 节）。

注意：通过包含值为零的填充长度字段，可以将帧的大小增加一个八位字节。

### 6.7. PING

PING 帧（类型=0x06）是一种用于测量来自发送方的最小往返时间以及确定空闲连接是否仍然有效的机制。PING 帧可以从任何端点发送。

```
PING Frame {
  Length (24) = 0x08,
  Type (8) = 0x06,

  Unused Flags (7),
  ACK Flag (1),

  Reserved (1),
  Stream Identifier (31) = 0,

  Opaque Data (64),
}
```

长度、类型、未使用标志、保留和流标识符字段在第 4 节中描述。

除了帧头之外，PING 帧必须在帧有效负载中包含 8 个八位字节的不透明数据。发送方可以包含它选择的任何值并以任何方式使用这些八位字节。

不包含 ACK 标志的 PING 帧的接收者必须发送一个设置了 ACK 标志的 PING 帧作为响应，并具有相同的帧负载。PING 响应应该比任何其他帧都具有更高的优先级。

PING 帧定义了以下标志：

- 确认（0x01）： 设置后，ACK 标志指示此 PING 帧是 PING 响应。端点必须 在 PING 响应中设置此标志。端点不得响应包含此标志的 PING 帧。
PING 帧不与任何单独的流相关联。如果接收到的 PING 帧的流标识符字段值不是 0x00，则接收方必须响应 类型为 PROTOCOL_ERROR 的连接错误（第 5.4.1 节）。

收到长度字段值不是 8 的 PING 帧必须被视为 FRAME_SIZE_ERROR 类型的 连接错误（第 5.4.1 节）。

### 6.8. GOAWAY

GOAWAY 帧（类型=0x07）用于启动连接关闭或发出严重错误情况的信号。GOAWAY 允许端点优雅地停止接受新流，同时仍然完成对先前建立的流的处理。这会启用管理操作，例如服务器维护。

在开始新流的端点和发送 GOAWAY 帧的远程对等方之间存在固有的竞争条件。为了处理这种情况，GOAWAY 包含最后一个对等发起的流的流标识符，该流已经或可能在此连接的发送端点上处理。例如，如果服务器发送一个 GOAWAY 帧，则标识的流是客户端发起的编号最高的流。

一旦发送了 GOAWAY，如果流的标识符高于包含的最后一个流标识符，则发送方将忽略在接收方发起的流上发送的帧。GOAWAY 帧的接收者不得在连接上打开额外的流，尽管可以为新流建立新连接。

如果 GOAWAY 的接收者在流上发送的数据具有比 GOAWAY 帧中指示的更高的流标识符，则这些流不会或不会被处理。GOAWAY 帧的接收者可以将流视为从未创建过，从而允许稍后在新连接上重试这些流。

端点应该总是在关闭连接之前发送一个 GOAWAY 帧，以便远程对等方可以知道流是否已被部分处理。例如，如果 HTTP 客户端在服务器关闭连接的同时发送 POST，如果服务器不发送 GOAWAY 帧以指示它可能具有哪些流，则客户端无法知道服务器是否开始处理该 POST 请求采取行动。

一个端点可能会选择关闭连接而不为行为不端的对等方发送 GOAWAY。

GOAWAY 帧可能不会立即关闭连接；不再使用连接的 GOAWAY 接收者应该在终止连接之前发送一个 GOAWAY 帧。

```
GOAWAY Frame {
  Length (24),
  Type (8) = 0x07,

  Unused Flags (8),

  Reserved (1),
  Stream Identifier (31) = 0,

  Reserved (1),
  Last-Stream-ID (31),
  Error Code (32),
  Additional Debug Data (..),
}
```

长度、类型、未使用标志、保留和流标识符字段在第 4 节中描述。

GOAWAY 框架没有定义任何标志。

GOAWAY 帧适用于连接，而不是特定的流。端点必须将流标识符不是 0x00 的GOAWAY帧视为PROTOCOL_ERROR类型的 连接错误（第 5.4.1 节）。

GOAWAY 帧中的最后一个流标识符包含编号最高的流标识符，GOAWAY 帧的发送者可能已经对其采取了一些行动或可能尚未采取行动。可能已经以某种方式处理了直到并包括已识别流的所有流。如果没有流被处理，最后的流标识符可以设置为 0。

注意：在这种情况下，“已处理”意味着流中的一些数据被传递到某个更高层的软件，这些软件可能因此采取了一些行动。

如果连接在没有 GOAWAY 帧的情况下终止，则最后一个流标识符实际上是最高可能的流标识符。

在连接关闭之前未完全关闭的具有较低或相同编号标识符的流上，不可能重新尝试请求、事务或任何协议活动，但 HTTP GET、PUT 或 DELETE 等幂等操作除外。任何使用更高编号流的协议活动都可以使用新连接安全地重试。

编号小于或等于最后一个流标识符的流上的活动可能仍会成功完成。GOAWAY 帧的发送者可以通过发送 GOAWAY 帧优雅地关闭连接，将连接保持在“打开”状态，直到所有正在进行的流完成。

如果情况发生变化，端点可以发送多个 GOAWAY 帧。例如，在正常关闭期间发送带有NO_ERROR的 GOAWAY 的端点随后可能会遇到需要立即终止连接的情况。接收到的最后一个 GOAWAY 帧的最后一个流标识符指示可以对哪些流采取行动。端点不得增加它们在最后一个流标识符中发送的值，因为对等点可能已经在另一个连接上重试了未处理的请求。

无法重试请求的客户端会在服务器关闭连接时丢失所有正在进行的请求。对于可能不使用 HTTP/2 为客户端提供服务的中介来说尤其如此。试图正常关闭连接的服务器应该发送一个初始 GOAWAY 帧，其中最后一个流标识符设置为 2 31 -1 和一个NO_ERROR代码。这向客户端发出即将关闭并且禁止发起进一步请求的信号。在为任何飞行中的流创建留出时间（至少一个往返时间）之后，服务器可以 发送另一个带有更新的最后一个流标识符的 GOAWAY 帧。这确保可以干净地关闭连接而不会丢失请求。

发送 GOAWAY 帧后，发送方可以丢弃由接收方发起的流的帧，这些流的标识符高于所识别的最后一个流。但是，不能完全忽略任何改变连接状态的帧。例如， 必须最少处理HEADERS、PUSH_PROMISE和CONTINUATION帧 ，以确保为字段部分压缩维护的状态是一致的（参见第 4.3 节）；类似地，数据帧必须计入连接流控制窗口。未能处理这些帧会导致流量控制或字段部分压缩状态变得不同步。

GOAWAY 帧还包含一个 32 位错误代码（第 7 节），其中包含关闭连接的原因。

端点可以将不透明数据附加到任何 GOAWAY 帧的帧有效载荷。附加调试数据仅用于诊断目的，不具有任何语义价值。调试信息可能包含对安全或隐私敏感的数据。记录的或以其他方式持久存储的调试数据必须有足够的保护措施以防止未经授权的访问。

### 6.9. WINDOW_UPDATE

WINDOW_UPDATE帧（type=0x08）用于实现流控；有关概述，请参见第 5.2 节。

流控制在两个级别上运行：在每个单独的流上和在整个连接上。

两种类型的流量控制都是逐跳的，即仅在两个端点之间。中介不在依赖连接之间转发 WINDOW_UPDATE 帧。但是，任何接收方对数据传输的节流都会间接导致流量控制信息向原始发送方传播。

流量控制仅适用于被识别为受流量控制影响的帧。在本文档中定义的帧类型中，这仅包括数据帧。免于流量控制的帧必须被接受和处理，除非接收方无法分配资源来处理该帧。如果接收方无法接受帧，则它可以用 FLOW_CONTROL_ERROR 类型的 流错误（第 5.4.2 节）或连接错误（第 5.4.1 节）进行响应。

```
WINDOW_UPDATE Frame {
  Length (24) = 0x04,
  Type (8) = 0x08,

  Unused Flags (8),

  Reserved (1),
  Stream Identifier (31),

  Reserved (1),
  Window Size Increment (31),
}
```

长度、类型、未使用标志、保留和流标识符字段在第 4 节中描述。WINDOW_UPDATE 帧的帧有效载荷是一个保留位加上一个无符号的 31 位整数，指示发送方除了现有的流控制窗口之外还可以传输的八位字节数。流控制窗口增量的合法范围是 1 到 2 31 -1 (2,147,483,647) 个八位字节。

WINDOW_UPDATE 框架没有定义任何标志。

WINDOW_UPDATE 帧可以特定于流或整个连接。在前一种情况下，帧的流标识符指示受影响的流；在后者中，值 “0” 表示整个连接是帧的主题。

接收方必须将接收到的流控制窗口增量为 0 的 WINDOW_UPDATE 帧视为 PROTOCOL_ERROR 类型的 流错误（第 5.4.2 节）；连接流控制窗口上的错误必须被视为连接错误（第 5.4.1 节）。

WINDOW_UPDATE 可以由已发送带有 END_STREAM 标志集的帧的对等方发送。这意味着接收器可以在“半关闭（远程）”或“关闭”状态的流上接收 WINDOW_UPDATE 帧。接收方不得将此视为错误（参见第 5.1 节）。

接收流控制帧的接收者必须始终考虑其对连接流控制窗口的贡献，除非接收者将此视为连接错误（第 5.4.1 节）。即使帧出错，这也是必要的。发送方向流量控制窗口计数帧，但如果接收方不这样做，则发送方和接收方的流量控制窗口可能会变得不同。

长度不是 4 个八位字节的 WINDOW_UPDATE 帧必须被视为FRAME_SIZE_ERROR类型的 连接错误（第 5.4.1 节）。

#### 6.9.1. The Flow-Control Window

HTTP/2 中的流量控制是使用每个发送者在每个流上保留的窗口来实现的。流量控制窗口是一个简单的整数值，表示允许发送方传输多少个八位字节的数据；因此，它的大小是接收器缓冲能力的度量。

适用的流控窗口有两种：流流控窗口和连接流控窗口。发送方不得发送长度超过接收方通告的任一流量控制窗口中可用空间的流量控制帧。如果任一流控制窗口中没有可用空间，则可以发送带有 END_STREAM 标志设置的零长度帧（即空数据帧） 。

对于流量控制计算，不计算 9 字节帧头。

发送流控帧后，发送方将两个窗口中的可用空间减少所传输帧的长度。

帧的接收者发送 WINDOW_UPDATE 帧，因为它消耗数据并释放流控制窗口中的空间。为流级和连接级流量控制窗口发送单独的 WINDOW_UPDATE 帧。建议接收方采用适当的机制来避免发送增量非常小的 WINDOW_UPDATE 帧；请参阅[ RFC1122 ]的第 4.2.3.3 节。

接收 WINDOW_UPDATE 帧的发送方按照帧中指定的数量更新相应的窗口。

发送方不得允许流量控制窗口超过 2 31 -1 个八位字节。如果发送方收到导致流量控制窗口超过此最大值的 WINDOW_UPDATE，则它必须视情况终止流或连接。对于流，发送方发送错误代码为  FLOW_CONTROL_ERROR的RST_STREAM；对于连接，发送 错误代码为 FLOW_CONTROL_ERROR的GOAWAY帧。

来自发送方的流量控制帧和来自接收方的 WINDOW_UPDATE 帧彼此完全异步。此属性允许接收方积极更新发送方保留的窗口大小，以防止流停止。

#### 6.9.2. Initial Flow-Control Window Size

首次建立 HTTP/2 连接时，将创建新流，其初始流量控制窗口大小为 65,535 个八位字节。连接流量控制窗口也是 65,535 个八位字节。两个端点都可以通过在 SETTINGS 框架中包含 SETTINGS_INITIAL_WINDOW_SIZE 的值来调整新流的初始窗口大小 。只能使用 WINDOW_UPDATE 帧更改连接流控制窗口。

在收到为 SETTINGS_INITIAL_WINDOW_SIZE 设置值的 SETTINGS 帧之前，端点在发送流控帧时只能使用默认的初始窗口大小。类似地，连接流控制窗口是根据默认的初始窗口大小设置的，直到收到  WINDOW_UPDATE 帧。

除了更改尚未激活的流的流量控制窗口外， SETTINGS 帧还可以更改具有活动流量控制窗口的流的初始流量控制窗口大小（即，处于“打开”或“半”状态的流-关闭（远程）”状态）。当 SETTINGS_INITIAL_WINDOW_SIZE 的值 改变时，接收者必须通过新值和旧值之间的差异来调整它维护的所有流流控制窗口的大小。

对 SETTINGS_INITIAL_WINDOW_SIZE 的更改可能导致流量控制窗口中的可用空间变为负数。发送方必须跟踪负流量控制窗口并且不得发送新的流量控制帧，直到它收到导致流量控制窗口变为正的  WINDOW_UPDATE 帧。

例如，如果客户端在连接建立时立即发送 60 KB 并且服务器将初始窗口大小设置为 16 KB，则客户端将在收到SETTINGS帧时重新计算可用的流量控制窗口为 -44 KB 。客户端保留负流量控制窗口，直到 WINDOW_UPDATE 帧将窗口恢复为正，之后客户端可以恢复发送。

SETTINGS 框架不能改变连接流控制窗口。

端点必须将导致任何流控制窗口超过最大大小的 SETTINGS_INITIAL_WINDOW_SIZE 更改视为 FLOW_CONTROL_ERROR 类型的连接错误（第 5.4.1 节）。

#### 6.9.3. Reducing the Stream Window Size

希望使用比当前大小更小的流量控制窗口的接收者可以发送一个新的 SETTINGS 帧。但是，接收方必须准备好接收超过此窗口大小的数据，因为发送方可能会在处理 SETTINGS 帧之前发送超过下限的数据。

在发送减小初始流量控制窗口大小的设置帧后，接收方可以继续处理超过流量控制限制的流。允许流继续不会允许接收方立即减少它为流量控制窗口保留的空间。这些流的进展也可能停滞，因为 需要WINDOW_UPDATE 帧来允许发送方恢复发送。接收方可以为受影响的流发送错误代码为 FLOW_CONTROL_ERROR的RST_STREAM 。

### 6.10. CONTINUATION

CONTINUATION 帧（type=0x09）用于延续字段块片段序列（第 4.3 节）。可以发送任意数量的 CONTINUATION 帧，只要前一帧在同一流上并且是 没有设置 END_HEADERS 标志的 HEADERS、PUSH_PROMISE 或 CONTINUATION 帧。

```
CONTINUATION Frame {
  Length (24),
  Type (8) = 0x09,

  Unused Flags (5),
  END_HEADERS Flag (1),
  Unused Flags (2),

  Reserved (1),
  Stream Identifier (31),

  Field Block Fragment (..),
}
```

长度、类型、未使用标志、保留和流标识符字段在第 4 节中描述。CONTINUATION 帧有效载荷包含一个字段块片段（第 4.3 节）。

CONTINUATION 帧定义了以下标志：

END_HEADERS (0x04):
设置时，END_HEADERS 标志指示此帧结束一个字段块（第 4.3 节）。

如果未设置 END_HEADERS 标志，则该帧必须跟在另一个 CONTINUATION 帧之后。接收方必须将任何其他类型的帧或不同流上的帧的接收视为PROTOCOL_ERROR类型的连接错误（第 5.4.1 节）。

CONTINUATION 帧改变4.3 节中定义的连接状态。

CONTINUATION 帧必须与流关联。如果接收到流标识符字段为 0x00 的 CONTINUATION 帧，接收方必须响应类型为 PROTOCOL_ERROR 的连接错误（第 5.4.1 节） 。

CONTINUATION 帧之前必须有一个HEADERS、 PUSH_PROMISE或 CONTINUATION 帧，而没有设置 END_HEADERS 标志。观察到违反此规则的接收者必须响应类型为 PROTOCOL_ERROR的连接错误（第 5.4.1 节）。

## 7. Error Codes

错误代码是在 RST_STREAM 和 GOAWAY 帧中使用的 32 位字段，用于传达流或连接错误的原因。

错误代码共享一个公共代码空间。一些错误代码仅适用于流或整个连接，并且在其他上下文中没有定义的语义。

定义了以下错误代码：

- NO_ERROR (0x00): 关联的条件不是错误的结果。例如， GOAWAY可能包含此代码以指示正常关闭连接。
- PROTOCOL_ERROR (0x01): 终结点检测到一个不特定的协议错误。当更具体的错误代码不可用时使用此错误。
- INTERNAL_ERROR (0x02): 终结点遇到意外的内部错误。
- FLOW_CONTROL_ERROR (0x03): 端点检测到其对等方违反了流量控制协议。
- SETTINGS_TIMEOUT (0x04): 端点发送了一个SETTINGS帧，但没有及时收到响应。请参阅第 6.5.3 节（“设置同步”）。
- STREAM_CLOSED (0x05): 端点在流半关闭后收到一个帧。
- FRAME_SIZE_ERROR (0x06): 端点收到一个大小无效的帧。
- REFUSED_STREAM (0x07): 端点在执行任何应用程序处理之前拒绝流（ 有关详细信息，请参阅第 8.7 节）。
- CANCEL (0x08): 端点使用此错误代码来指示不再需要该流。
- COMPRESSION_ERROR (0x09): 端点无法维护连接的字段部分压缩上下文。
- CONNECT_ERROR (0x0a): 为响应CONNECT 请求（第 8.5 节）而建立的连接被重置或异常关闭。
- ENHANCE_YOUR_CALM (0x0b)：端点检测到其对等端正在表现出可能产生过载的行为。
- INADEQUATE_SECURITY (0x0c): 底层传输具有不满足最低安全要求的属性（请参阅第 9.2 节）。
- HTTP_1_1_REQUIRED (0x0d): 端点要求使用 HTTP/1.1 而不是 HTTP/2。

未知或不受支持的错误代码不得触发任何特殊行为。这些可能被实现视为等同于INTERNAL_ERROR。

## 8. Expressing HTTP Semantics in HTTP/2

HTTP/2 是 HTTP 消息抽象的实例（[ HTTP ]的第 6 节）。

### 8.1. HTTP Message Framing

客户端使用以前未使用的流标识符（第 5.1.1 节）在新流上发送 HTTP 请求。服务器在与请求相同的流上发送 HTTP 响应。

HTTP 消息（请求或响应）包括：

1. 一个包含标题部分的 HEADERS 帧（后跟零个或多个CONTINUATION帧）（参见 [ HTTP ]的第 6.3 节），
2. 包含消息内容的零个或多个数据帧（参见[ HTTP ]的第 6.4 节），以及
3. 可选地，一个包含尾部部分的 HEADERS 帧（后跟零个或多个 CONTINUATION 帧）（如果存在）（参见 [ HTTP ]的第 6.5 节）。

仅对于响应，服务器可以在包含最终响应的 HEADERS 帧之前发送任意数量的临时响应。临时响应由一个 HEADERS 帧（后面可能跟零个或多个 CONTINUATION 帧）组成，其中包含临时 (1xx) HTTP 响应的控制数据和标头部分（参见[ HTTP ]的第 15 节）。设置了 END_STREAM 标志且带有信息性状态代码的 HEADERS 帧格式不正确（第 8.1.1 节）。

序列中的最后一帧带有 END_STREAM 标志，注意设置了 END_STREAM 标志的 HEADERS 帧后面可以跟有携带字段块的任何剩余片段的 CONTINUATION 帧。

其他帧（来自任何流）不得出现在 HEADERS 帧和可能跟随的任何 CONTINUATION 帧之间。

HTTP/2 使用 DATA 帧来承载消息内容。[ HTTP/1.1 ]第 7.1 节 chunked 中定义的传输编码不能在 HTTP/2 中使用；参见第 8.2.2 节。

尾部字段在也终止流的字段块中携带。也就是说，尾部字段包括一个以 HEADERS 帧开始的序列，随后是零个或多个 CONTINUATION 帧，其中 HEADERS 帧带有 END_STREAM 标志。尾部不得包含 伪标头字段（第 8.3 节）。在尾部接收伪报头字段的端点必须将请求或响应视为格式错误（第 8.1.1 节）。

在接收到打开请求的HEADERS帧后或在接收到最终（非信息性）状态代码后接收到未设置END_STREAM 标志的HEADERS帧的端点必须将相应的请求或响应视为格式错误（第 8.1.1 节）。

HTTP 请求/响应交换完全消耗单个流。请求以将流置于“打开”状态的HEADERS帧开始。请求以设置了 END_STREAM 标志的帧结束，这导致流对客户端变为“半关闭（本地）”，对服务器变为“半关闭（远程）”。响应流以HEADERS帧中的零个或多个临时响应开始，然后是包含最终状态代码的HEADERS帧。

在服务器发送或客户端接收到设置了 END_STREAM 标志的帧（包括完成字段块所需的任何CONTINUATION帧）后，HTTP 响应完成。如果响应不依赖于尚未发送和接收的请求的任何部分，则服务器可以在客户端发送整个请求之前发送完整的响应。如果为真，服务器可以通过在发送完整响应（即设置了 END_STREAM 标志的帧）后发送错误代码为NO_ERROR的RST_STREAM来请求客户端无错误地中止请求的传输。客户不得丢弃响应作为收到这样的RST_STREAM的结果，尽管客户端总是可以出于其他原因自行决定丢弃响应。

#### 8.1.1. Malformed Messages

格式错误的请求或响应是一种有效的 HTTP/2 帧序列，但由于存在无关帧、禁止字段或伪标头字段、缺少强制性伪标头字段、包含大写字母而无效字段名称，或无效的字段名称和/或值（在某些情况下；参见第 8.2 节）。

包含消息内容的请求或响应可以包含 content-length标头字段。如果报头字段的值不等于构成内容的数据content-length帧有效负载长度的总和，则请求或响应也是格式错误的，除非消息被定义为没有内容。例如，204 或 304 响应不包含任何内容，对 HEAD 请求的响应也是如此。定义为没有内容的响应，如[ HTTP ]的第 6.4.1 节所述，可能具有非零标头字段，即使 数据帧中不包含任何内容。content-length

处理 HTTP 请求或响应的中介（即任何不充当隧道的中介）不得转发格式错误的请求或响应。检测到的格式错误的请求或响应必须被视为PROTOCOL_ERROR类型的流错误（第 5.4.2 节）。

对于格式错误的请求，服务器可以在关闭或重置流之前发送 HTTP 响应。客户端不得接受格式错误的响应。

逐步处理消息的端点可能在将请求或响应识别为格式错误之前执行了一些处理。例如，可以在未收到完整请求的情况下生成信息或 404 状态代码。同样，中介可能会在检测到错误之前转发不完整的消息。当响应不依赖于请求的其余部分是否正确时，服务器可以在接收整个请求之前生成最终响应。

这些要求旨在防止针对 HTTP 的多种类型的常见攻击；他们故意严格，因为宽容会使实现暴露于这些漏洞。

### 8.2. HTTP Fields

HTTP 字段（[ HTTP ]的第 5 节）由 HTTP/2 在 HEADERS、CONTINUATION 和 PUSH_PROMISE 帧中传送，并使用 HPACK [ COMPRESSION ]压缩。

构造 HTTP/2 消息时，字段名称必须转换为小写。

#### 8.2.1. Field Validity

HTTP 中字段名称和值的定义禁止 HPACK 可能能够传送的某些字符。HTTP/2 实现应该分别根据[ HTTP ]第 5.1节和第 5.5节中的定义来验证字段名称和值，并将包含禁止字符的消息视为格式 错误（第 8.1.1 节）。

无法验证字段可被用于请求走私攻击。特别是，当使用 HTTP/1.1 [ HTTP/1.1 ]转发消息时，未经验证的字段可能会引发攻击，其中使用回车 (CR)、换行 (LF) 和 COLON 等字符作为分隔符。实现必须执行以下字段名称和值的最小验证：

- 字段名称不得包含 0x00-0x20、0x41-0x5a 或 0x7f-0xff（包括所有范围）范围内的字符。这特别排除了所有不可见的 ASCII 字符、ASCII SP (0x20) 和大写字符（'A' 到 'Z'，ASCII 0x41 到 0x5a）。
- 除了名称以单个冒号开头的伪头字段（第 8.3 节）之外，字段名称不得包含冒号（ASCII COLON，0x3a）。
- 字段值不得在任何位置包含零值（ASCII NUL，0x00）、换行符（ASCII LF，0x0a）或回车符（ASCII CR，0x0d）。
- 字段值不得以 ASCII 空白字符（ASCII SP 或 HTAB、0x20 或 0x09）开头或结尾。

> 注意：根据 [ HTTP ]第5.1节和第 5.5节中的定义验证字段的实现只需要额外检查字段名称不包含大写字符。

包含违反任何这些条件的字段的请求或响应必须 被视为格式错误（第 8.1.1 节）。特别是，在转发消息时不处理字段的中介不得转发包含上面列出的任何禁止值的字段。

当请求消息违反这些要求之一时，实现应该 生成 400（错误请求）状态代码（参见[ HTTP ]的第 15.5.1 节），除非定义了更合适的状态代码或无法发送状态代码（例如，因为错误发生在尾部字段中）。

> 注意：根据相应字段的定义无效的字段值不会导致请求格式错误；上述要求仅适用于[ HTTP ]第 5 节中定义的字段的通用语法。

#### 8.2.2. Connection-Specific Header Fields

HTTP/2 不使用 Connection 标头字段（[ HTTP ]的第 7.6.1 节）来指示特定于连接的标头字段；在此协议中，特定于连接的元数据通过其他方式传送。端点不得生成包含特定于连接的标头字段的 HTTP/2 消息。这包括 标头字段和在[ HTTP ]的第 7.6.1 节 Connection 中列为具有连接特定语义的字段（Proxy-Connection, Keep-Alive, Transfer-Encoding, and Upgrade）。任何包含特定连接头字段的消息必须被视为 格式错误（第 8.1.1 节）。

唯一的例外是 TE 标头字段，它可能出现在 HTTP/2 请求中；如果是，它不得包含除 “trailers” 以外的任何值。

将 HTTP/1.x 消息转换为 HTTP/2 的中介必须删除特定于连接的标头字段，如[ HTTP ]的第 7.6.1 节所述，否则它们的消息将被其他 HTTP/2 端点视为格式错误（第 8.1.1 节）。

> 注意：HTTP/2 有意不支持升级到另一个协议。第 3 节中描述的握手方法被认为足以协商替代协议的使用。

#### 8.2.3. Compressing the Cookie Header Fields

Cookie 标头字段[ COOKIE ]使用分号（“;”）来分隔 cookie 对（或“面包屑”）。此标头字段包含多个值，但不使用逗号 (",") 作为分隔符，从而防止 cookie 对在多个字段行上发送（请参阅 [HTTP] 的第5.2节）。这会显着降低压缩效率，因为对单个 cookie 对的更新会使存储在 HPACK 表中的任何字段行无效。

为了获得更好的压缩效率，Cookie 头字段可以拆分为单独的头字段，每个头字段有一个或多个 cookie 对。如果解压缩后有多个 Cookie 头字段，则必须在将它们传递到非 HTTP/2 上下文之前，使用 0x3b、0x20（ASCII 字符串“;”）的两个八位字节定界符将它们连接成一个八位字节字符串，例如作为 HTTP/1.1 连接，或通用 HTTP 服务器应用程序。

因此，下面两个 Cookie 头字段列表在语义上是等价的。

```
cookie: a=b; c=d; e=f

cookie: a=b
cookie: c=d
cookie: e=f
```

### 8.3. HTTP Control Data

HTTP/2 使用以 “:” 字符 (ASCII 0x3a) 开头的特殊伪标头字段来传送消息控制数据（请参阅[ HTTP ]的第 6.2 节）。

伪标头字段不是 HTTP 标头字段。除了本文档中定义的那些之外，端点不得生成伪报头字段。请注意，扩展可以协商使用额外的伪标头字段；参见 第 5.5 节。

伪标头字段仅在定义它们的上下文中有效。为请求定义的伪标头字段不得出现在响应中；为响应定义的伪标头字段不得出现在请求中。伪标头字段不得出现在尾部部分。端点必须将包含未定义或无效伪报头字段的请求或响应视为格式错误（第 8.1.1 节）。

所有伪报头字段必须出现在所有常规字段行之前的字段块中。任何包含出现在常规字段行之后的字段块中的伪报头字段的请求或响应必须被视为格式错误（第 8.1.1 节）。

相同的伪头字段名不得在字段块中出现多次。包含重复伪报头字段名称的 HTTP 请求或响应的字段块必须被视为格式错误（第 8.1.1 节）。

#### 8.3.1. Request Pseudo-Header Fields

为 HTTP/2 请求定义了以下伪标头字段：

- “:method” 伪报头字段包括 HTTP 方法（[ HTTP ]的第 9 节）。
- “:scheme”伪报头字段包括请求目标的方案部分。该方案在直接生成请求时取自目标 URI（[ RFC3986 ]的第 3.1 节），或者取自转换请求的方案（例如，参见[ HTTP/1.1 ]的第 3.3 节）。CONNECT 请求（第 8.5 节）省略了 Scheme 。
    - “:scheme” 不限于 “http” 和 “https” 计划的 URI。代理或网关可以转换对非 HTTP 方案的请求，从而允许使用 HTTP 与非 HTTP 服务进行交互。
- “:authority” 伪标头字段传达目标 URI（[ HTTP ]的第 7.1 节）的权限部分（[ RFC3986 ]的第 3.2 节）。如果存在“:authority”，HTTP/2 请求的接收者不得使用 Host 标头字段来确定目标 URI 。
    - 直接生成 HTTP/2 请求的客户端必须使用 “:authority” 伪标头字段来传递权限信息，除非没有要传递的权限信息（在这种情况下它不能生成 “:authority”）。
    - 客户端不得生成具有不同于 “:authority” 伪标头字段的 Host 标头字段的请求。如果请求包含标识实体的标头字段与 “:authority” 伪标头字段中的实体不同，则服务器应该将请求视为格式错误。字段的值需要被规范化以比较它们（参见[ RFC3986 ]的第 6.2 节）。源服务器可以应用任何规范化方法，而其他服务器必须执行基于方案的规范化（参见[ RFC3986 ]的第 6.2.3 节) 的两个字段。
    - 通过 HTTP/2 转发请求的中介必须使用原始请求的控制数据中的权限信息构造一个 “:authority” 伪报头字段，除非原始请求的目标 URI 不包含权限信息（在这种情况下它不得生成“ :authority”）。请注意，Host标题字段不是此信息的唯一来源；请参阅[ HTTP ]的第 7.2 节。
    - 需要生成 Host 标头字段（构造 HTTP/1.1 请求可能需要）的中介必须使用 “:authority” 伪标头字段中的值作为该 Host 字段的值，除非中介也更改了请求目标。这将替换任何现有 Host 字段以避免 HTTP 路由中的潜在漏洞。
    - 通过 HTTP/2 转发请求的中介可以保留任何 Host 标头字段。
    - 请注意，CONNECT 或星号形式的 OPTIONS 请求的请求目标从不包含权限信息；请参阅[ HTTP ] 的第 7.1 和 7.2 节。
    - “:authority” 绝不能包含 “http” 或 “https” 方案 URI 的已弃用的 userinfo 子组件。
- “:path” 伪标头字段包括目标 URI 的路径和查询部分（生产absolute-path 和可选的 '?' 字符后跟生产 query；参见[ HTTP ]的第 4.1 节）。星号形式的请求（对于 OPTIONS）包括 “:path” 伪标头字段的值 “*” 。
    - 对于 “http” 或 “https” URI，此伪标头字段不得为空；“http” 或 “https” 不包含路径组件的 URI 必须包含值“/”。这条规则的例外是：
        - 对不包含路径组件的 “http” 或 “https” URI的 OPTIONS 请求；这些必须包含一个 :path 值为 “*” 的伪标头字段（参见[ HTTP ]的第 7.1 节）。
        - CONNECT 请求（第 8.5 节），其中省略了 “:path” 伪标头字段。

所有 HTTP/2 请求必须只包含 “:method”、“:scheme”和 “:path” 伪标头字段的一个有效值，除非它们是 CONNECT 请求（第 8.5 节）。省略强制性伪标头字段的 HTTP 请求是格式错误的（第 8.1.1 节）。

单个 HTTP/2 请求不携带协议版本的明确指示符。所有 HTTP/2 请求都隐式地具有协议版本 “2.0”（参见 [ HTTP ]的第 6.2 节）。

#### 8.3.2. Response Pseudo-Header Fields

对于 HTTP/2 响应，定义了 一个单独的 “:status” 伪标头字段，它携带 HTTP 状态代码字段（参见[ HTTP ]的第 15 节）。这个伪头字段必须包含在所有响应中，包括临时响应；否则，响应 格式错误（第 8.1.1 节）。

HTTP/2 响应隐式具有协议版本 “2.0”。

### 8.4. Server Push

HTTP/2 允许服务器抢先发送（或“推送”）响应（连同相应的“承诺”请求）给与先前客户端发起的请求相关联的客户端。

服务器推送旨在允许服务器通过预测哪些请求将跟随它接收到的请求来提高客户端感知的性能，从而消除它们的往返行程。例如，对 HTML 的请求之后通常是对该页面引用的样式表和脚本的请求。当这些请求被推送时，客户端不需要等待在 HTML 中接收到对它们的引用并发出单独的请求。

在实践中，服务器推送很难有效使用，因为它需要服务器正确预测客户端将发出的额外请求，同时考虑缓存、内容协商和用户行为等因素。预测错误可能导致性能下降，这是由于在线路上的额外数据所代表的机会成本。特别是，推送任何大量数据都可能导致与更重要的响应发生争用问题。

客户端可以请求禁用服务器推送，尽管这是针对每个跃点独立协商的。SETTINGS_ENABLE_PUSH 设置可以设置为 0 以指示禁用服务器推送。

承诺的请求必须是安全的（参见[ HTTP ]的第 9.2.1 节）和可缓存的（参见[ HTTP ]的第 9.2.3 节）。承诺的请求不能包含任何内容或预告片部分。收到不可缓存、未知安全或表明存在请求内容的承诺请求的客户端必须使用PROTOCOL_ERROR类型的 流错误（第 5.4.2 节）重置承诺流. 请注意，如果客户端不认为新定义的方法是安全的，这可能会导致承诺的流被重置。

如果客户端实现了 HTTP 缓存，那么可缓存的推送响应（请参阅[缓存]的第 3 节）可以由客户端存储。推送的响应被认为在源服务器上成功验证（例如，如果存在“无缓存”缓存响应指令；请参阅[缓存]的第 5.2.2.4 节），而由承诺的流标识符标识的流仍然打开。

不可缓存的推送响应不得由任何 HTTP 缓存存储。它们可以 单独提供给应用程序。

服务器必须在服务器对其具有权威性的 “:authority” 伪报头字段中包含一个值（参见第 10.1 节）。客户端必须将服务器不授权的PUSH_PROMISE视为PROTOCOL_ERROR类型的流错误（第 5.4.2 节）。

中介可以从服务器接收推送并选择不将它们转发给客户端。换句话说，如何使用推送的信息取决于中介。同样，中介可能会选择向客户端发送额外的推送，而服务器不采取任何操作。

客户端不能推送。因此，服务器必须将PUSH_PROMISE帧的接收视为 PROTOCOL_ERROR 类型的连接错误（第 5.4.1 节）。服务器不能将 SETTINGS_ENABLE_PUSH 设置设置为 0 以外的值（参见第 6.5.2 节）。

#### 8.4.1. Push Requests

服务器推送在语义上等同于服务器响应请求；然而，在这种情况下，该请求也由服务器作为 PUSH_PROMISE 帧发送。

PUSH_PROMISE 帧包括一个包含控制数据的字段块和一组完整的请求头字段，服务器将这些字段归于请求。无法推送对包含消息内容的请求的响应。

承诺的请求总是与来自客户端的显式请求相关联。服务器发送的 PUSH_PROMISE 帧在该显式请求的流上发送。PUSH_PROMISE 帧还包括一个承诺的流标识符，从服务器可用的流标识符中选择（参见第 5.1.1 节）。

PUSH_PROMISE 和任何后续的 CONTINUATION 帧中的标头字段必须是有效且完整的请求标头字段集（第 8.3.1 节）。服务器必须在 “:method” 伪标头字段中包含一个安全且可缓存的方法。如果客户端收到一个 PUSH_PROMISE，它不包含一个完整且有效的头字段集，或者 “:method” 伪头字段标识了一个不安全的方法，它必须在承诺的流上响应一个流错误（第 5.4.2 节）)的类型 PROTOCOL_ERROR。

服务器应该在发送引用承诺响应的任何帧之前发送 PUSH_PROMISE （第 6.6 节）帧。这避免了客户端在收到任何 PUSH_PROMISE 帧之前发出请求的竞争。

例如，如果服务器收到对包含多个图像文件的嵌入式链接的文档的请求，并且服务器选择将这些附加图像推送给客户端，则在包含图像链接的数据帧之前发送 PUSH_PROMISE 帧可确保客户端能够在发现嵌入链接之前查看资源将被推送。类似地，如果服务器推送字段块引用的资源（例如，在 Link 标头字段中），则在发送标头之前发送 PUSH_PROMISE 可确保客户端不会请求这些资源。

客户端不得发送 PUSH_PROMISE 帧。

服务器可以在任何客户端发起的流上发送 PUSH_PROMISE 帧，但流必须相对于服务器处于“打开”或“半关闭（远程）”状态。 PUSH_PROMISE 帧散布在包含响应的帧中，尽管它们不能散布在包含单个字段块的 HEADERS 和 CONTINUATION 帧中。

发送 PUSH_PROMISE 帧会创建一个新流，并将流置于服务器的“保留（本地）”状态和客户端的“保留（远程）”状态。

#### 8.4.2. Push Responses

发送 PUSH_PROMISE 帧后，服务器可以开始将推送的响应作为响应（第 8.3.2 节）传递到使用承诺的流标识符的服务器启动的流上。服务器使用这个流来传输 HTTP 响应，使用与第 8.1 节中定义的相同的帧序列。在发送初始HEADERS帧后，此流对客户端（第 5.1 节）变为“半关闭” 。

一旦客户端收到 PUSH_PROMISE 帧并选择接受推送的响应，在承诺的流关闭之前，客户端不应该发出任何对承诺的响应的请求。

如果客户端出于任何原因确定它不希望从服务器接收推送的响应，或者如果服务器花了太长时间才开始发送承诺的响应，则客户端可以使用 CANCEL 或 REFUSED_STREAM 发送 RST_STREAM 帧代码并引用推送流的标识符。

客户端可以使用 SETTINGS_MAX_CONCURRENT_STREAMS 设置来限制服务器可以同时推送的响应数量。公布 SETTINGS_MAX_CONCURRENT_STREAMS 值为零可防止服务器打开推送响应所需的流。但是，这不会阻止服务器使用 PUSH_PROMISE 帧保留流，因为保留的流不计入并发流限制。不希望接收推送资源的客户端需要重置任何不需要的保留流或将 SETTINGS_ENABLE_PUSH 设置为 0。

接收推送响应的客户端必须验证服务器是权威的（请参阅第 10.1 节）或提供推送响应的代理已为相应的请求配置。例如，只为 DNS-ID 提供证书的服务器 example.com（参见[ RFC6125 ]）不允许推送对 < https://www.example.org/doc> 的响应。

PUSH_PROMISE流的响应以一个HEADERS帧开始 ，它立即将流置于服务器的“半关闭（远程）”状态和客户端的“半关闭（本地）”状态，并以一个帧结束设置了 END_STREAM 标志，将流置于“关闭”状态。

> 注意：客户端永远不会为服务器推送发送带有 END_STREAM 标志的帧。

### 8.5. The CONNECT Method

CONNECT 方法（[ HTTP ]的第 9.3.6 节）用于将 HTTP 连接转换为到远程主机的隧道。CONNECT 主要与 HTTP 代理一起使用，以与源服务器建立 TLS 会话，以便与 “https” 资源进行交互。

在 HTTP/2 中，CONNECT 方法通过单个 HTTP/2 流建立到远程主机的隧道，而不是将整个连接转换为隧道。CONNECT 报头部分按照第 8.3.1 节（“请求伪报头字段”）中的定义构造，但有一些差异。具体来说：

“:method” 伪标头字段设置为 CONNECT。
必须省略 “:scheme” 和 “:path” 伪报头字段。
“:authority” 伪头字段包含要连接的主机和端口（相当于 CONNECT 请求的请求目标的授权形式；参见[ HTTP/1.1 ]的第 3.2.3 节）。
不符合这些限制的 CONNECT 请求是格式错误的（第 8.1.1 节）。

支持 CONNECT 的代理建立 TCP 连接[ TCP ] 到 “:authority” 伪报头字段中标识的主机和端口。一旦成功建立此连接，代理就会向客户端发送包含 2xx 系列状态代码的 HEADERS 帧，如[ HTTP ]的第 9.3.6 节中所定义。

在每个对等方发送初始 HEADERS 帧之后，所有后续的 DATA 帧都对应于在 TCP 连接上发送的数据。客户端发送的任何数据帧的帧负载由代理传输到 TCP 服务器；从 TCP 服务器接收到的数据由代理组装成数据帧。DATA 或流管理帧（RST_STREAM、WINDOW_UPDATE 和 PRIORITY）以外的帧类型不得在连接的流上发送，并且必须被视为流错误（第 5.4.2 节）)如果收到。

TCP 连接可以由任一对等方关闭。DATA 帧上的 END_STREAM 标志被视为等同于 TCP FIN 位。客户端在接收到设置了 END_STREAM 标志的帧后，应发送一个设置了 END_STREAM 标志的数据帧。接收到设置了 END_STREAM 标志的数据帧的代理发送附加数据，并在最后一个 TCP 段上设置了 FIN 位。接收到设置了 FIN 位的 TCP 段的代理发送设置了 END_STREAM 标志的数据帧。请注意，最后的 TCP 段或数据帧可能为空。

TCP 连接错误通过 RST_STREAM 发出信号。代理将 TCP 连接中的任何错误（包括接收设置了 RST 位的 TCP 段）视为类型为 CONNECT_ERROR 的流错误（第 5.4.2 节）。相应地，如果代理检测到流或 HTTP/2 连接错误，则它必须发送一个 RST 位设置的 TCP 段。

### 8.6. The Upgrade Header Field

HTTP/2 不支持 101（切换协议）信息状态代码（[ HTTP ]的第 15.2.2 节）。

101（切换协议）的语义不适用于多路复用协议。通过使用扩展的 CONNECT [ RFC8441 ]可能会启用类似的功能，并且其他协议能够使用 HTTP/2 用于协商其使用的相同机制（请参阅第 3 节）。

### 8.7. Request Reliability

通常，HTTP 客户端在发生错误时无法重试非幂等请求，因为无法确定错误的性质（请参阅 [HTTP] 的第 9.2.2 节）。有可能在错误之前发生了一些服务器处理，如果重新尝试请求，这可能会导致不良影响。

HTTP/2 提供了两种机制来向客户端保证请求未被处理：

- GOAWAY 帧指示可能已处理的最高流编号。因此，保证对具有更高编号的流的请求可以安全重试。
- REFUSED_STREAM 错误代码可以包含在 RST_STREAM 帧中，以指示流在任何处理发生之前被关闭。在重置流上发送的任何请求都可以安全地重试。

未处理的请求没有失败；客户端可以自动重试它们，即使是那些使用非幂等方法的。

服务器不得指示流未被处理，除非它可以保证这一事实。如果流上的帧被传递给任何流的应用层，则 REFUSED_STREAM 不得用于该流，并且 GOAWAY 帧必须包含大于或等于给定流标识符的流标识符。

除了这些机制之外，PING 帧还为客户端提供了一种轻松测试连接的方法。保持空闲的连接可能会断开，因为某些中间件（例如，网络地址转换器或负载平衡器）会默默地丢弃连接绑定。PING 帧允许客户端在不发送请求的情况下安全地测试连接是否仍处于活动状态。

### 8.8. Examples

本节展示了 HTTP/1.1 请求和响应，以及等效的 HTTP/2 请求和响应的示意图。

#### 8.8.1. Simple Request

HTTP GET 请求包括控制数据和没有消息内容的请求头，因此作为单个 HEADERS 帧传输，后跟零个或多个包含请求头字段序列化块的 CONTINUATION 帧。下面的 HEADERS 帧同时设置了 END_HEADERS 和 END_STREAM 标志；没有发送任何 CONTINUATION 帧。

```
  GET /resource HTTP/1.1           HEADERS
  Host: example.org          ==>     + END_STREAM
  Accept: image/jpeg                 + END_HEADERS
                                       :method = GET
                                       :scheme = https
                                       :authority = example.org
                                       :path = /resource
                                       host = example.org
                                       accept = image/jpeg
```

#### 8.8.2. Simple Response

类似地，仅包括控制数据和响应标头的响应作为包含响应标头字段序列化块的标头帧（同样，后跟零个或多个 连续帧）传输 。

```
  HTTP/1.1 304 Not Modified        HEADERS
  ETag: "xyzzy"              ==>     + END_STREAM
  Expires: Thu, 23 Jan ...           + END_HEADERS
                                       :status = 304
                                       etag = "xyzzy"
                                       expires = Thu, 23 Jan ...
```

#### 8.8.3. Complex Request

包含控制数据和带有消息内容的请求标头的 HTTP POST 请求作为一个 HEADERS 帧传输，后跟零个或多个包含请求标头的 CONTINUATION 帧，然后是一个或多个 DATA 帧，最后一个 CONTINUATION（或 HEADERS）设置了 END_HEADERS 标志的帧和 设置了 END_STREAM 标志的最终数据帧：

```
  POST /resource HTTP/1.1          HEADERS
  Host: example.org          ==>     - END_STREAM
  Content-Type: image/jpeg           - END_HEADERS
  Content-Length: 123                  :method = POST
                                       :authority = example.org
                                       :path = /resource
  {binary data}                        :scheme = https

                                   CONTINUATION
                                     + END_HEADERS
                                       content-type = image/jpeg
                                       host = example.org
                                       content-length = 123

                                   DATA
                                     + END_STREAM
                                   {binary data}
```

请注意，有助于任何给定字段的数据可以分布在字段片段之间。在这个例子中字段到帧的分配只是说明性的。

#### 8.8.4. Response with Body

包含控制数据和带有消息内容的响应头的响应作为一个 HEADERS 帧传输，后跟零个或多个 CONTINUATION 帧，然后是一个或多个 DATA 帧，序列中的最后一个 DATA 帧设置了 END_STREAM 标志：

```
  HTTP/1.1 200 OK                  HEADERS
  Content-Type: image/jpeg   ==>     - END_STREAM
  Content-Length: 123                + END_HEADERS
                                       :status = 200
  {binary data}                        content-type = image/jpeg
                                       content-length = 123

                                   DATA
                                     + END_STREAM
                                   {binary data}
```

#### 8.8.5. Informational Responses

使用 101 以外的 1xx 状态代码的信息响应作为 HEADERS 帧传输 ，后跟零个或多个 CONTINUATION 帧。

在请求或响应字段块和所有数据帧都已发送后，尾部部分作为字段块发送。开始包含尾部部分的字段块的HEADERS帧 设置了 END_STREAM 标志。

下面的示例包括一个 100(Continue) 状态代码，它是为响应在 Expect 标头字段中包含 “100-continue” 令牌的请求而发送的，以及一个尾部部分：

```
  HTTP/1.1 100 Continue            HEADERS
  Extension-Field: bar       ==>     - END_STREAM
                                     + END_HEADERS
                                       :status = 100
                                       extension-field = bar

  HTTP/1.1 200 OK                  HEADERS
  Content-Type: image/jpeg   ==>     - END_STREAM
  Transfer-Encoding: chunked         + END_HEADERS
  Trailer: Foo                         :status = 200
                                       content-type = image/jpeg
  123                                  trailer = Foo
  {binary data}
  0                                DATA
  Foo: bar                           - END_STREAM
                                   {binary data}

                                   HEADERS
                                     + END_STREAM
                                     + END_HEADERS
                                       foo = bar
```

## 9. HTTP/2 Connections

本节概述了 HTTP 的属性，这些属性可以提高互操作性、减少对已知安全漏洞的暴露或减少实现变化的可能性。

### 9.1. Connection Management

HTTP/2 连接是持久的。为了获得最佳性能，预计客户端不会关闭连接，直到确定不需要与服务器进行进一步通信（例如，当用户导航离开特定网页时）或直到服务器关闭连接。

客户端不应该打开超过一个到给定主机和端口对的 HTTP/2 连接，其中主机来自 URI、选定的替代服务[ ALT-SVC ]或配置的代理。

客户端可以创建额外的连接作为替换，以替换接近耗尽可用流标识符空间的连接（第 5.1.1 节），刷新 TLS 连接的密钥材料，或替换遇到错误的连接（第 5.1.1节） 5.4.1）。

客户端可以使用不同的服务器名称指示[ TLS-EXT ]值打开到相同 IP 地址和 TCP 端口的多个连接 ，或者提供不同的 TLS 客户端证书，但应该避免使用相同的配置创建多个连接。

鼓励服务器尽可能长时间保持打开的连接，但允许在必要时终止空闲连接。当任一端点选择关闭传输层 TCP 连接时，终止端点应该首先发送一个 GOAWAY（第 6.8 节）帧，以便两个端点都可以可靠地确定先前发送的帧是否已被处理并优雅地完成或终止任何必要的剩余任务。

#### 9.1.1. Connection Reuse

与原始服务器建立的连接，无论是直接连接还是通过使用 CONNECT 方法（第 8.5 节）创建的隧道，都可以重新用于具有多个不同 URI 授权组件的请求。只要原始服务器是权威的（第 10.1 节） ，就可以重用连接。对于没有 TLS 的 TCP 连接，这取决于已解析到相同 IP 地址的主机。

对于 “https” 资源，连接重用还取决于具有对 URI 中的主机有效的证书。服务器提供的证书必须满足客户端在为 URI 中的主机建立新的 TLS 连接时执行的任何检查。单个证书可用于为多个来源建立授权。 [ HTTP ]的第 4.3 节 描述了客户端如何确定服务器是否对 URI 具有权威性。

在某些部署中，为多个来源重复使用连接可能会导致请求被定向到错误的来源服务器。例如，TL​​S 终止可能由使用 TLS 服务器名称指示[ TLS-EXT ]扩展来选择源服务器的中间盒执行。这意味着客户端有可能将请求发送到可能不是请求的预期目标的服务器，即使服务器在其他方面是权威的。

不希望客户端重用连接的服务器可以通过发送 421(Misdirected Request) 状态代码来响应请求（参见 [HTTP] 的第 15.5.20 节）来表明它对请求没有权威。

配置为通过 HTTP/2 使用代理的客户端通过单个连接将请求定向到该代理。也就是说，所有通过代理发送的请求都会重用与代理的连接。

### 9.2. Use of TLS Features

HTTP/2 的实现必须使用 TLS 版本 1.2 [ TLS12 ] 或更高版本用于基于 TLS 的 HTTP/2。应遵循[ TLSBCP ] 中的一般 TLS 使用指南，以及一些特定于 HTTP/2 的附加限制。

TLS 实现必须支持服务器名称指示 (SNI) [ TLS-EXT ]对 TLS 的扩展。如果服务器由域名[ DNS-TERMS ]标识，客户端必须发送 server_name TLS 扩展，除非使用替代机制来指示目标主机。

协商 TLS 1.3 [ TLS13 ]的 HTTP/2 部署要求 包含在第 9.2.3 节中。TLS 1.2 的部署符合第 9.2.1 和 9.2.2 节中的要求。鼓励实现提供合规的默认值，但认识到部署最终要对合规性负责。

#### 9.2.1. TLS 1.2 Features

本节介绍对可与 HTTP/2 一起使用的 TLS 1.2 功能集的限制。由于部署限制，当不满足这些限制时，可能无法使 TLS 协商失败。端点可以立即终止不满足这些 TLS 要求的 HTTP/2 连接，并出现类型为 INADEQUATE_SECURITY 的连接错误（第 5.4.1 节）。

通过 TLS 1.2 部署 HTTP/2 必须禁用压缩。TLS 压缩可能会导致以其他方式不会被泄露的信息泄露[ RFC3749 ]。通用压缩是不必要的，因为 HTTP/2 提供了更了解上下文的压缩功能，因此可能更适合用于性能、安全性或其他原因。

通过 TLS 1.2 部署 HTTP/2 必须禁用重新协商。端点必须将 TLS 重新协商视为 PROTOCOL_ERROR 类型的连接错误（第 5.4.1 节）。请注意，由于底层密码套件可以加密的消息数量受到限制，禁用重新协商可能会导致长期连接变得不可用。

端点可以使用重新协商为握手中提供的客户端凭证提供机密性保护，但任何重新协商必须在发送连接前言之前发生。如果服务器在建立连接后立即看到重新协商请求，则它应该请求客户端证书。

这有效地防止了使用重新协商来响应对特定受保护资源的请求。未来的规范可能会提供一种支持此用例的方法。或者，服务器可能使用 HTTP_1_1_REQUIRED 类型的错误（第 5.4 节）来请求客户端使用支持重新协商的协议。

对于使用临时有限域 Diffie-Hellman (DHE)（ [ TLS12 ]的第 8.1.2 节）的密码套件，实现必须支持至少 2048 位的临时密钥交换大小，对于使用临时椭圆曲线 Diffie-Hellman 的密码套件，至少支持 224 位的临时密钥交换大小(ECDHE) [ RFC8422 ]。客户端必须接受最大 4096 位的 DHE 大小。端点可以将小于下限的密钥大小的协商视为INADEQUATE_SECURITY类型的连接错误（第 5.4.1 节）。

#### 9.2.2. TLS 1.2 Cipher Suites

基于 TLS 1.2 的 HTTP/2 部署不应使用附录 A中列出的任何禁止的密码套件。

如果协商了禁止的密码套件之一，端点可以选择生成类型为INADEQUATE_SECURITY的连接错误（第 5.4.1 节） 。选择使用禁止的密码套件的部署有触发连接错误的风险，除非已知潜在对等点集接受该密码套件。

实现不得生成此错误以响应未禁止的密码套件的协商。因此，当客户端提供未被禁止的密码套件时，他们必须准备好将该密码套件与 HTTP/2 一起使用。

禁止的密码套件列表包括 TLS 1.2 强制执行的密码套件，这意味着 TLS 1.2 部署可以具有不相交的允许密码套件集。为了避免这个导致 TLS 握手失败的问题，使用 TLS 1.2 的 HTTP/2 部署必须支持 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 [ TLS-ECDHE ]和 P-256 椭圆曲线[ RFC8422 ]。

请注意，客户端可能会公布对被禁止的密码套件的支持，以允许连接到不支持 HTTP/2 的服务器。这允许服务器选择带有 HTTP/2 中禁止的密码套件的 HTTP/1.1。但是，如果独立选择应用程序协议和密码套件，这可能会导致 HTTP/2 与禁止的密码套件协商。

#### 9.2.3. TLS 1.3 Features

TLS 1.3 包含许多早期版本中不可用的功能。本节讨论这些功能的使用。

HTTP/2 服务器不得发送握手后 TLS 1.3 CertificateRequest 消息。HTTP/2 客户端必须将 TLS 握手后 CertificateRequest 消息视为 PROTOCOL_ERROR 类型的连接错误（第 5.4.1 节）。

即使客户端提供了 “post_handshake_auth” TLS 扩展，握手后身份验证的禁令也适用。握手后身份验证支持可能会独立于ALPN [ TLS-ALPN ]进行广告宣传。客户端可能会提供在其他协议中使用的能力，但包含扩展并不意味着支持 HTTP/2。

[ TLS13 ]定义了其他握手后消息，NewSessionTicket 和 KeyUpdate，可以使用它们，因为它们与 HTTP/2 没有直接交互。除非使用新类型的 TLS 消息取决于与应用层协议的交互，否则可以在握手完成后发送该 TLS 消息。

TLS 早期数据可以用于发送请求，前提是遵守[ RFC8470 ]中的指南。客户端在假定所有服务器设置的初始值的早期数据中发送请求。
