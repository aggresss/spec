# HTTP/2

> 原文 [https://www.rfc-editor.org/rfc/rfc9113](https://www.rfc-editor.org/rfc/rfc9113)

## 摘要

## 1. Introduction

使用超文本传输协议(HTTP， [HTTP])的应用程序的性能与每个HTTP版本如何使用底层传输协议以及传输协议运行的条件有关。

发送多个并发请求可以减少延迟并提高应用程序性能。HTTP/1.0 在给定的 TCP 连接上只允许在同一时间有一个未完成的请求。HTTP/1.1 增加了请求管道，但这只是部分解决了请求并发，仍然会受到应用层队首阻塞 (head of line blocking) 的影响。因此，HTTP/1.0 和 HTTP/1.1 客户端使用多个到服务器的连接来发起并发请求。

此外，HTTP 字段通常是重复和冗长的，这会导致不必要的网络流量，并导致初始 TCP 拥塞窗口很快被填满。当在一个新的 TCP 连接上发起多个请求时，可能会导致过大的延迟。

HTTP/2 通过定义一个 HTTP 语义到底层连接的优化映射来解决这些问题。具体来说，它允许在同一个连接上交叉消息，并对 HTTP 字段使用高效编码。它还允许对请求进行优先级排序，让更重要的请求更快地完成，进一步提高性能。

最终的协议对网络更友好，因为与 HTTP/1.x 相比，可以使用更少的 TCP 连接。这意味着与其他流的竞争更少，连接寿命更长，从而更好地利用可用的网络容量。不过要注意，这个协议没有解决 TCP 队首阻塞问题。

最后，HTTP/2 还通过使用二进制消息分帧实现了更高效的消息处理。

这份文件淘汰了 [RFC7540] 和 [RFC8740]。附录 B 列出了值得注意的变化。

## 2. HTTP/2 Protocol Overview

HTTP/2 为 HTTP 语义提供了优化的传输。HTTP/2 支持 HTTP 的所有核心特性，但目标是比 HTTP/1.1 更高效。

HTTP/2 是一个运行在 TCP 连接( [TCP] )上的面向连接的应用层协议。客户端是 TCP 连接的发起者。

HTTP/2 的基本协议单位是帧(frame 4.1节)。每种帧类型都有不同的用途。例如，HEADERS 和 DATA 帧构成了 HTTP 请求和响应的基础(第 8.1 节);其他帧类型如 SETTINGS、WINDOW_UPDATE 和 PUSH_PROMISE 用于支持其他 HTTP/2 特性。

请求的多路复用是通过让每个 HTTP 请求/响应 都与自己的流相关联来实现的(第 5 节)。流在很大程度上是彼此独立的，因此阻塞或停滞的请求或响应不会影响其他流的处理。

复用的有效利用依赖于流量控制和优先级。流量控制(第 5.2 节)通过将传输的数据限制为接收端能够处理的数据，确保能够有效地使用多路复用的流。确定优先级(第 5.3 节)可以确保有限的资源得到最有效的利用。HTTP/2 的这个修订版本废弃了 [RFC7540] 中的优先级信令方案。

因为连接中使用的 HTTP 字段可能包含大量冗余数据，所以包含这些数据的帧会被压缩(第 4.3 节)。通常情况下，这对请求长度有特别有利的影响，允许将多个请求压缩到一个分组中。

最后，HTTP/2 增加了一个新的可选交互模式，服务器可以将响应推送给客户端(8.4 节)。它的目的是允许服务器根据预期向客户端发送数据，以牺牲一些网络开销换取潜在的延迟增益。服务器通过合成一个请求来实现这一点，并将其作为 PUSH_PROMISE 帧发送。然后，服务器能够在单独的流上向合成请求发送响应。

### 2.1. Document Organization

HTTP/2规范分为四个部分。

- Starting HTTP/2 (Section 3) 介绍了如何发起HTTP/2连接。
- Frame (Section 4) 和 Stream (Section 5) 描述了 HTTP/2 帧的结构和形成多路复用流的方式。
- Frame Definitions (Section 6) and Error Definitions (Section 7) 包括 HTTP/2 中使用的帧和错误类型的详细信息。
- HTTP Mappings (Section 8) 和 Additional Requirements (Section 9) 描述了如何使用帧和流表达 HTTP 语义。

虽然有些帧层和流层的概念与 HTTP 是隔离的，但本规范并没有定义一个完全通用的帧层。帧层和流层是根据HTTP的需求定制的。

### 2.2. Conventions and Terminology

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.

所有数值都是按网络字节顺序排列的。除非另有说明，否则值是无符号的。根据需要提供十进制或十六进制的字面量。十六进制字面量以 "0x" 作为前缀，以区别于十进制字面量。

本规范使用 RFC9000 [QUIC] 1.3 节中描述的约定描述二进制格式。注意，这种格式使用网络字节序，高值位在低值位之前。

这里使用了下列术语。

- client: 发起HTTP/2连接的端点。客户端发送HTTP请求并接收HTTP响应。
- connection: 两个端点之间的传输层连接。
- connection error: 影响整个 HTTP/2 连接的错误。
- endpoint: 连接的客户端或服务器。
- frame: HTTP/2 连接中通信的最小单位，由首部和根据帧类型构造的可变长度的字节序列组成。
- peer: 一个端点。当讨论一个特定的端点时，“peer”指的是与主要讨论对象相隔较远的端点。
- receiver: 接收帧的端点。
- sender: 传输帧的端点。
- server: 接受 HTTP/2 连接的端点。服务器接收 HTTP 请求并发送 HTTP 响应。
- stream: HTTP/2 连接中的双向帧流。
- stream error: 单个 HTTP/2 流的错误。

最后，术语 "gateway"、"intermediary"、"proxy" 和 "tunnel" 的定义见 [HTTP] 的第 3.7 节。中间设备在不同时间同时充当客户端和服务器。

适用于消息体的术语 "content" 定义在 [HTTP] 章节 6.4 中。

## 3. Staring HTTP/2

生成 HTTP 请求的实现需要知道服务器是否支持 HTTP/2。

HTTP/2 使用 [HTTP] 第 4.2 节中定义的 "HTTP" 和 "https" URI scheme，与 HTTP/1.1 [HTTP/1.1] 具有相同的默认端口号。这些 URI 不包含上游服务器(客户端希望建立连接的直接端)支持的 HTTP 版本的任何指示。

对于 "HTTP" 和 "https" URI，确定是否支持 HTTP/2 的方法是不同的。"https" URI 的发现在 3.2 节中描述。HTTP/2 对 "HTTP" URI 的支持只能通过带外方式发现，并且需要事先了解 3.3 节所述的支持情况。

### 3.1. HTTP/2 Version Identification

本文档中定义的协议有两个标识符。基于其中任何一个标识符创建连接都意味着使用本文档中描述的传输、帧和消息语义。

- 字符串 "h2" 表示 HTTP/2 使用传输层安全协议(Transport Layer Security, TLS)的协议;参见 9.2 节。这个标识符在 TLS 应用层协议协商(ALPN)扩展 [TLS-ALPN] 字段中使用，在任何可以识别 TLS 上 HTTP/2 的地方也会使用。 "h2" 字符串被序列化为 ALPN 协议的两个字节序列: `0x68、0x32` 。
- "h2c" 字符串以前用作令牌，用于 HTTP 升级机制的 Upgrade 头字段( [HTTP] 章节 7.8 )。这种用法从未被广泛部署，并且被本文所弃用。这同样适用于 HTTP2-Settings 头字段，该字段在升级到 "h2c" 时被使用。

### 3.2. Starting HTTP/2 for "https" URIs

客户端使用 TLS [TLS13] 和 ALPN 扩展 [TLS-ALPN] 向 "https" URI 发出请求。

基于 TLS 的 HTTP/2 使用 "h2" 协议标识符。"h2c" 协议标识符不能由客户端发送或由服务器选择; "h2c" 协议标识符描述了不使用 TLS 的协议。

一旦 TLS 协商完成，客户端和服务器都必须发送 connection preface (章节3.4)。

### 3.3. Starting HTTP/2 with Prior Knowledge

客户端可以通过其他方式得知某个服务器支持 HTTP/2。例如，客户端可以配置服务器是否支持 HTTP/2。

客户端知道服务器支持 HTTP/2，就可以建立一个 TCP 连接，并在发送 HTTP/2 帧之后发送连接序言(章节3.4)。服务器可以通过连接序言来识别这些连接。这只对通过明文 TCP 建立 HTTP/2 连接有影响。基于 TLS 的 HTTP/2 连接必须使用 TLS [TLS-ALPN] 中的协议协商。

同样，服务器必须发送连接序言(章节3.4)。

如果没有额外的信息，先前对 HTTP/2 的支持并不是某台服务器在以后的连接中也会支持 HTTP/2 的强信号。例如，服务器配置可能会改变，集群服务器中不同实例的配置可能不同，或者网络条件可能会改变。

### 3.4. HTTP/2 Connection Preface

在 HTTP/2 中，每个端点都需要发送连接序言以最终确认使用的协议，并为 HTTP/2 连接建立初始设置。客户端和服务器分别发送不同的连接序言。

客户端连接序言以24个字节序列开始，用十六进制表示法表示为:

```
  0x505249202a20485454502f322e300d0a0d0a534d0d0a0d0a
```

也就是说，连接序言以字符串 `"PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n"` 开始。这个序列后面必须跟着一个 SETTINGS 帧(章节 6.5)，它可以是空的。客户端发送客户端连接序言作为连接的第一个应用数据字节。

> 注意: 选择客户端连接序言是为了让大部分 HTTP/1.1 或 HTTP/1.0 服务器和中间设备不再尝试处理其他帧。请注意，这并没有解决 [TALKING] 中提出的问题。

服务器连接序言由一个可能为空的 SETTINGS 帧(章节 6.5)组成，它必须是服务器在 HTTP/2 连接中发送的第一个帧。

从另一端接收到的 SETTINGS 帧作为连接序言的一部分，必须在发送连接序言后确认(参见 6.5.3 节)。

为了避免不必要的延迟，允许客户端在发送客户端连接序言后立即向服务器发送额外的帧，而无需等待接收服务器连接序言。但是，需要注意的是，服务器连接序言设置帧可能包括一些必要的设置，这些设置可能会改变客户端预期与服务器通信的方式。在收到设置帧后，客户端被期望遵守任何已建立的设置。在某些配置中，服务器可以在客户端发送额外帧之前发送设置，从而避免这个问题。

客户端和服务器必须将无效的连接序言视为类型为协议错误的连接错误(章节 5.4.1)。在这种情况下，超时帧(第 6.8 节)可能会被忽略，因为无效的序言表明对等端没有使用 HTTP/2。

## 4. HTTP Frames

一旦建立了 HTTP/2 连接，终端就可以开始交换帧了。

### 4.1. Frame Format

所有的帧都以一个固定格式的 9 字节头开始，然后是一个可变长度的帧负载。

```
HTTP Frame {
  Length (24),
  Type (8),

  Flags (8),

  Reserved (1),
  Stream Identifier (31),

  Frame Payload (..),
}
```

帧头的字段定义如下:

- Length: 以字节为单位的无符号 24 位整数表示的帧负载的长度。大于 2^14 (16,384) 的值不能发送，除非接收方为 SETTINGS_MAX_FRAME_SIZE 设置了更大的值。 帧头的 9 个字节不包括在这个值中。
- Type: 帧的 8 位类型。帧类型决定了帧的格式和语义。第 6 节列出了本文档中定义的框架。实现必须忽略和丢弃未知类型的帧。
- Flags: 一个8位字段，用于指定帧类型的布尔标志。标志的语义与指定的帧类型相关。未使用的标志是那些对特定帧类型没有定义语义的标志。未使用的标志在接收时必须忽略，发送时必须保持未设置(0x00)。
- Reserved: 保留的 1 位字段。该比特位的语义未定义，在发送时必须保持未设置 (0x00)，在接收时必须忽略。
- Stream Identifier: 用无符号 31 位整数表示的流标识符(参见第 5.1.1 节)。0x00 这个值是为连接中作为整体关联的帧保留的，而不是单独的流。

帧负载的结构和内容完全取决于帧类型。

### 4.2. Frame Size

帧有效载荷的大小受限于接收端在 SETTINGS_MAX_FRAME_SIZE 设置中通告的最大大小。这个值可以是 2^14 (16,384) 到 2^24-1 (16,777,215) 之间的任意值，包括这个值。

所有的实现必须能够接收和处理长度不超过 2^14 个字节的帧，加上 9 个字节的帧头(章节 4.1)。描述帧大小时，帧头的大小不包括在内。

> 注意:某些类型的帧，如 PING(章节 6.7)，对允许的帧负载数据量有额外的限制。

如果一个帧超过 SETTINGS_MAX_FRAME_SIZE 定义的大小，超过为帧类型定义的任何限制，或者太小不能包含强制帧数据，端点必须发送一个错误码 FRAME_SIZE_ERROR。帧内的帧大小错误可能会改变整个连接的状态，必须被视为连接错误(章节 5.4.1);这包括任何带有字段块(章节 4.3 )的帧(即 HEADERS、PUSH_PROMISE 和 CONTINUATION)、SETTINGS帧，以及任何流标识符为 0 的帧。

端点没有义务使用帧中的所有可用空间。响应性可以通过使用小于允许的最大尺寸的帧来提高。发送大帧可能会导致发送时间敏感帧(如 RST_STREAM、WINDOW_UPDATE 或 PRIORITY )的延迟，如果传输大帧时被阻塞，则会影响性能。

### 4.3. Field Section Compression and Decompression

field 部分的压缩是将一组 field 行( [HTTP] 的 5.2 节)压缩成 field block 的过程。域段解压缩是将域块解码为一组域线的过程。HTTP/2 字段段压缩和解压缩的细节在 [compression] 中定义，由于历史原因，它将这些过程称为 header compression 和 header decompression 。

每个 field block 将 field 部分所有的 filed 压缩成一个 block。标题段还包括以伪标题字段( 8.3 节)的形式与消息关联的控制数据，这些字段使用与字段行相同的格式。

> 注意: RFC7540 [RFC7540] 使用术语 "header block" 取代了更通用的 "field block"。

字段块携带请求、响应、承诺请求和推送响应的控制数据和首部部分(见 8.4 节)。除了在 PUSH_PROMISE (章节 6.6)帧中包含的临时响应和请求外，所有这些消息都可以选择包含一个带有 trailer 节的字段块。

field section 是 field line 的集合。field block 中的每一条 field line 都携带一个值。序列化后的 field block 被分成一个或多个字节序列，称为 field block fragments。第一个字段块片段是在 HEADERS (章节 6.2)或 PUSH_PROMISE (章节 6.6) 的帧负载中传输的，每一个都可以后面跟着 CONTINUATION (章节 6.10) 帧来携带后续的字段块片段。

Cookie 首部字段 [Cookie] 由 HTTP 映射特殊处理(参见 8.2.3 节)。

接收端通过拼接其片段重组字段块，然后解压块以重构字段部分。

一个完整的字段部分包括:

- 一个 HEADERS 或 PUSH_PROMISE 帧，设置了 END_HEADERS 标志，或者
- 未设置 END_HEADERS 标志的 HEADERS 或 PUSH_PROMISE 帧，以及一个或多个延续帧，其中最后一个延续帧设置了 END_HEADERS 标志。

每个字段块被作为一个离散单元处理。字段块必须作为连续的帧序列传输，不能有任何其他类型或来自任何其他流的交叉帧。HEADERS 或 CONTINUATION 帧序列中的最后一帧设置了 END_HEADERS 标志。PUSH_PROMISE 或 CONTINUATION 帧序列中的最后一帧设置了 END_HEADERS 标志。这使得字段块在逻辑上等同于单个帧。

字段块片段只能作为 HEADERS、PUSH_PROMISE 或 CONTINUATION 帧的帧负载发送，因为这些帧携带的数据可以修改接收端维护的压缩上下文。终端接收到 HEADERS、PUSH_PROMISE 或 CONTINUATION 帧时，即使这些帧将被丢弃，也需要重新组装字段块并执行解压缩。如果接收方没有解压缩字段块，则必须以类型为 COMPRESSION_ERROR 的连接错误(章节5.4.1)终止连接。

字段块中的解码错误必须被视为类型为 COMPRESSION_ERROR 的连接错误(章节 5.4.1)。

#### 4.3.1. Compression State

字段压缩是有状态的。每个端点都有一个 HPACK 编码器上下文和一个 HPACK 解码器上下文，用于对连接上的所有字段块进行编码和解码。第 4 节定义了动态表，它是每个上下文的主要状态。

动态表的最大长度是由 HPACK 解码器设定的。终端通过其 HPACK 解码器上下文的 SETTINGS_HEADER_TABLE_SIZE 设置来传递数据长度。参见 6.5.2 节。在建立连接时，两端 HPACK 解码器和编码器的动态表大小都是从 4096 字节开始的，这是 SETTINGS_HEADER_TABLE_SIZE 设置的初始值。

使用 SETTINGS_HEADER_TABLE_SIZE 对最大值所做的任何修改，在端点确认设置时生效(6.5.3 节)。该端点的 HPACK 编码器可以将动态表设置为解码器设置的最大值之前的任意大小。HPACK 编码器通过动态表大小更新指令声明动态表的大小( [COMPRESSION] 章节 6.3)。

一旦终端确认 SETTINGS_HEADER_TABLE_SIZE 发生了变化，使得最大值小于动态表的当前大小，它的 HPACK 编码器就必须用一条动态表大小更新指令开始下一个字段块，该指令将动态表的大小设置为小于或等于缩减后的最大值;参见 [COMPRESSION] 第4.2节。如果一个端点没有以一个符合的动态表大小更新指令开始，那么它必须将在确认缩减到最大动态表大小之后的字段块视为类型为 COMPRESSION_ERROR 的连接错误(章节5.4.1)。

> 建议实现者注意，减少 SETTINGS_HEADER_TABLE_SIZE 的值不能广泛互操作。使用连接序将值减少到初始值 4096 以下，这在某种程度上得到了更好的支持，但在某些实现中可能会失败。

## 5. Streams and Multiplexing

"stream" 是一个独立的、双向的帧序列，在 HTTP/2 连接中在客户端和服务器之间交换。流有几个重要的特征。

- 一个 HTTP/2 连接可以包含多个并发打开的流，任何一个终端都可以交错使用来自多个流的帧。
- 流可以单独建立和使用，也可以由任意一端共享。
- 两个端点都可以关闭流。
- 发送帧的顺序很重要。接收方按照接收帧的顺序处理帧。特别是，首部和数据帧的顺序在语义上很重要。
- 流由一个整数标识。流标识符由初始化流的端点分配给流。

### 5.1. Stream States

```
                                +--------+
                        send PP |        | recv PP
                       ,--------+  idle  +--------.
                      /         |        |         \
                     v          +--------+          v
              +----------+          |           +----------+
              |          |          | send H /  |          |
       ,------+ reserved |          | recv H    | reserved +------.
       |      | (local)  |          |           | (remote) |      |
       |      +---+------+          v           +------+---+      |
       |          |             +--------+             |          |
       |          |     recv ES |        | send ES     |          |
       |   send H |     ,-------+  open  +-------.     | recv H   |
       |          |    /        |        |        \    |          |
       |          v   v         +---+----+         v   v          |
       |      +----------+          |           +----------+      |
       |      |   half-  |          |           |   half-  |      |
       |      |  closed  |          | send R /  |  closed  |      |
       |      | (remote) |          | recv R    | (local)  |      |
       |      +----+-----+          |           +-----+----+      |
       |           |                |                 |           |
       |           | send ES /      |       recv ES / |           |
       |           |  send R /      v        send R / |           |
       |           |  recv R    +--------+   recv R   |           |
       | send R /  `----------->|        |<-----------'  send R / |
       | recv R                 | closed |               recv R   |
       `----------------------->|        |<-----------------------'
                                +--------+
```

- send: endpoint sends this frame
- recv: endpoint receives this frame
- H: HEADERS frame (with implied CONTINUATION frames)
- ES: END_STREAM flag
- R: RST_STREAM frame
- PP: PUSH_PROMISE frame (with implied CONTINUATION frames); state transitions are for the promised stream

请注意，该图只显示了流状态转换以及影响这些转换的帧和标志。在这方面，延续帧不会导致状态转换;它们实际上是它们遵循的 HEADERS 或 PUSH_PROMISE 的一部分。为了进行状态转换，END_STREAM 标志作为带有它的帧的单独事件处理。设置了 END_STREAM 标志的 HEADERS 帧可以导致两次状态转换。

在传输帧时，两端对流的状态都有主观的看法，可能会有所不同。端点不参与流的创建; 它们是由任何一个端点单方面创建的。状态不匹配的负面影响仅限于发送 RST_STREAM 后的“关闭”状态，此时帧可能会在关闭后一段时间内接收到。

流有以下几种状态:

**idle**

All streams start in the "idle" state.

从这个状态开始，下列状态转换是有效的:

- 作为客户端发送 HEADERS 帧，或者作为服务器接收 HEADERS 帧，会导致流变为 "open"。流标识符的选择如 5.1.1 节所述。同样的 HEADERS 帧也会导致流立即变为 "half-closed" 状态。
- 在另一个流上发送 PUSH_PROMISE 帧，会为以后使用预留空闲流。保留流的状态变为 "reserved (local)"。只有服务器可以发送 PUSH_PROMISE 帧。
- 在另一个流上接收 PUSH_PROMISE 帧会预留一个空闲流供以后使用。保留流的状态变为 "reserved (remote)"。只有客户端可以接收 PUSH_PROMISE 帧。
- 注意，PUSH_PROMISE 帧不会在空闲流上发送，而是在被承诺的流 ID 字段中引用新预留的流。
- 通过将流标识符位置 1 来打开流，会导致流立即过渡到 "closed" 状态; 注意，图中没有显示此转换。

在这种状态下，在流上接收到除报头或优先级以外的任何帧都必须被视为类型为协议错误的连接错误(章节 5.4.1)。如果该流是由服务器发起的，如章节 5.1.1 所述，那么接收到 HEADERS 帧也必须被视为类型为协议错误的连接错误(章节5.4.1)。

**reserved (local)**

处于 "reserved (local)" 状态的流是指已经发送了 PUSH_PROMISE 帧的流。PUSH_PROMISE 帧通过将流与远端发起的打开流关联起来来保留一个空闲流(参见 8.4 节)。

在这种状态下，只有以下转换是可能的:

- 端点可以发送 HEADERS 帧。这会导致流以 "reserved (remote)" 状态打开。
- 任何一个终端都可以发送 RST_STREAM 帧来导致流变为 "closed"。这释放了流预留。

在这种状态下，终端不能发送除 HEADERS、RST_STREAM 或 PRIORITY 以外的任何类型的帧。

在这种状态下，可能会接收到 PRIORITY 或 WINDOW_UPDATE 帧。在这种状态下，在流上接收到除 RST_STREAM、PRIORITY 或 WINDOW_UPDATE 以外的任何类型的帧都必须被视为类型为 PROTOCOL_ERROR 的连接错误(章节 5.4.1)。

**reserved (remote)**

处于 "reserved (remote)" 状态的流已经被远程对等端保留了。

在这种状态下，只有以下转换是可能的:

- 接收到 HEADERS 帧会导致流变为 "half-closed (local)" 状态。
- 任何一个终端都可以发送 RST_STREAM 帧来导致流变为 "closed"。这释放了流预留。

在这种状态下，终端不能发送除 RST_STREAM、WINDOW_UPDATE 或 PRIORITY 以外的任何类型的帧。

在这种状态下，流上接收到除 HEADERS、RST_STREAM 或 PRIORITY 以外的任何类型的帧都必须被视为类型为 PROTOCOL_ERROR 的连接错误(章节 5.4.1)。

**open**

处于 "open" 状态的流可以被两端用来发送任何类型的帧。在这种状态下，发送端遵守被通告流级别的流量控制限制(章节 5.2)。

在这种状态下，任何一端都可以发送带有 END_STREAM 标志的帧，这会导致流过渡到 "helf-closed" 状态之一。终端发送 END_STREAM 标志会导致流状态变为 "half-closed (local)"; 终端接收到 END_STREAM 标志会导致流状态变为 "half-closed (remote)"。

任何一端都可以从这个状态发送一个 RST_STREAM 帧，使其立即过渡到 "closed" 状态。

**half-closed (local)**

处于 "half-closed (local)" 状态的流不能用于发送帧，只能用于 WINDOW_UPDATE、PRIORITY 和 RST_STREAM。

当接收到设置了 END_STREAM 标志的帧或任何一端发送了 RST_STREAM 帧时，流从这种状态转换为 "closed" 状态。

在这种状态下，终端可以接收任何类型的帧。使用 WINDOW_UPDATE 帧提供流量控制信用值对于继续接收流量控制帧是必要的。在这种状态下，接收端可以忽略 WINDOW_UPDATE 帧，因为 WINDOW_UPDATE 帧可能会在发送带有 END_STREAM 标志的帧之后的一小段时间内到达。

在这个状态下可以接收到 PRIORITY 帧。

**half-closed (remote)**

"half-closed (remote)" 的流不再被对等端用来发送帧。在这种状态下，终端不再需要维护接收者流量控制窗口。

如果终端接收到 WINDOW_UPDATE、PRIORITY 或 RST_STREAM 以外的其他帧，并且流处于这种状态，它必须响应一个类型为 STREAM_CLOSED 的流错误(章节 5.4.2)。

"half-closed (remote)" 的流可以被终端用来发送任何类型的帧。在这种状态下，端点会继续遵守通告流级别的流量控制限制(章节5.2)。

流可以通过发送设置了 END_STREAM 标志的帧或者任何一端发送 RST_STREAM 帧来从这种状态过渡到 "closed" 状态。

**closed**

"closed" 状态是终端状态。

在终端发送和接收设置了 END_STREAM 标志的帧后，流进入 "closed" 状态。在终端发送或接收 RST_STREAM 帧后，流也会进入 "closed" 状态。

终端不能在已关闭的流上发送除 PRIORITY 以外的帧。终端可以将在已关闭流上接收到的任何其他类型的帧视为类型为 STREAM_CLOSED 的连接错误(章节 5.4.1)，除非如下所述。

一个发送带有 END_STREAM 标志的帧或 RST_STREAM 帧的终端可能会从它的对等端接收到 WINDOW_UPDATE 或 RST_STREAM 帧，这可能是在它接收到并处理关闭流的帧之前的时间。

在处于 "open" 或 "half-closed (local)" 状态的流上发送 RST_STREAM 帧的端点可以接收任何类型的帧。在处理 RST_STREAM 帧之前，端可能已经发送或排队等待发送这些帧。终端必须最低限度地处理然后丢弃在这种状态下接收到的任何帧。这意味着更新 HEADERS 和 PUSH_PROMISE 帧的报头压缩状态。接收到 PUSH_PROMISE 帧也会导致被承诺流变为 "reserved (remote)"，即使是在已关闭的流上接收到 PUSH_PROMISE 帧时也是如此。此外，数据框的内容计入连接流量控制窗口。

终端可以对所有处于 "closed" 状态的流执行这种最小的处理。终端可以使用其他信号来检测一端已经接收到导致流进入 "closed" 状态的帧，并将接收到的除 PRIORITY 以外的任何帧视为类型为协议错误的连接错误(章节5.4.1)。端点可以使用帧来指示另一端已经接收到关闭信号来驱动这一过程。端点不应该为此使用定时器。例如，终端在关闭流后发送 SETTINGS 帧，在收到设置确认后，可以安全地将该流上的 DATA 帧视为错误。其他可能会用到的功能包括 PING 帧、在关闭流后创建的流上接收数据，或者响应关闭流后创建的请求。

在没有更具体规则的情况下，实现应该将接收到的状态描述中没有明确允许的帧作为类型为协议错误的连接错误(章节5.4.1)处理。注意，PRIORITY 可以在任何流状态下发送和接收。

本节中的规则仅适用于本文档中定义的框架。接收到语义未知的帧不能被视为错误，因为发送和接收这些帧的条件也是未知的。参见 5.5 节。

HTTP 请求/响应交换的状态转换示例可以在 8.8 节中找到。在 8.4.1 节和 8.4.2 节可以找到服务器推送的状态转换示例。

#### 5.1.1. Stream Identifiers

流由一个 31 位无符号整数标识。由客户端发起的流必须使用奇数的流标识符;由服务器发起的流必须使用偶数流标识符。0 的流标识符 (0x00) 用于连接控制消息;流标识符 0 不能用于建立新的流。

新建立流的标识符必须在数字上大于起始端点已打开或保留的所有流。它管理使用报头帧打开的流和使用 PUSH_PROMISE 保留的流。接收到意外流标识符的端点必须响应类型为 PROTOCOL_ERROR 的连接错误(章节5.4.1)。

HEADER 帧将由帧头中的流标识符标识的客户端发起的流从 "idle" 转换为 "open"。PUSH_PROMISE 帧会将由承诺流 ID 字段在帧负载中标识的服务器启动流从 "idle" 转换为 "reserved (local)" 或 "reserved (remote)"。当流从 "idle" 状态转换出来时，所有处于 "idle" 状态的流，如果被流标识符值较低的对端打开，将立即转换为 "closed" 状态。也就是说，端点可以跳过流标识符，其效果是被跳过的流立即被关闭。

流标识符不能重用。长时间的连接可能导致端点耗尽可用的流标识符范围。无法建立新流标识符的客户端可以为新流建立新连接。无法建立新的流标识符的服务器可以发送超时帧，这样客户端就被迫为新的流打开一个新连接。

#### 5.1.2. Stream Concurrency

另一端可以在 SETTINGS 帧中使用 SETTINGS_MAX_CONCURRENT_STREAMS 参数(参见 6.5.2 节)来限制并发活动流的数量。最大并发流设置是特定于每个端点的，只适用于接收该设置的一端。也就是说，客户端指定服务器可以发起的最大并发流数，服务器指定客户端可以发起的最大并发流数。

处于 "open" 状态或处于 "half-closed" 状态的流计数为终端允许打开的最大流数。处于这三种状态的流都会计入 SETTINGS_MAX_CONCURRENT_STREAMS 设置中公布的限制。处于任何一种 "reserved" 状态的流都不计入流的限制。

端点不能超过其对等体设置的限制。端点收到报头帧导致其发布的并发流超过限制，必须将其视为类型为 PROTOCOL_ERROR 或 REFUSED_STREAM 的流错误(章节 5.4.2)。错误码的选择决定了端点是否希望启用自动重试(详细信息参见 8.7 节)。

如果终端希望 SETTINGS_MAX_CONCURRENT_STREAMS 的值小于当前打开的流数，可以关闭超过这个值的流，或者允许流完成。

### 5.2. Flow Control

使用流进行多路复用会引起 TCP 连接的争用，从而导致流阻塞。流量控制方案确保同一个连接上的流不会相互干扰。流量控制既用于单个流，也用于整个连接。

HTTP/2 通过使用 WINDOW_UPDATE 帧(章节6.9)提供流量控制。

#### 5.2.1. Flow-Control Principles

HTTP/2 流流量控制的目的是在不改变协议的情况下允许使用各种流量控制算法。HTTP/2 中的流量控制具有以下特点:

1. 流量控制是特定于连接的。HTTP/2 流量控制在单跳端点之间进行，而不是在整个端到端路径上进行。
2. 流量控制基于 WINDOW_UPDATE 帧。接收端通告他们准备在流上以及整个连接中接收多少个字节。这是一个基于信用的计划。
3. 流量控制是定向的，由接收器提供整体控制。接收方可以为每个流和整个连接设置所需的任何窗口大小。发送端必须遵守接收端的流量控制限制。客户端、服务器和中间设备都独立地将它们的流量控制窗口作为接收端通告，并在发送时遵守其他节点设置的流量控制限制。
4. 对于新流和整个连接，流量控制窗口的初始值都是 65,535 字节。
5. 帧类型决定了流控制是否适用于帧。在本文档中指定的帧中，只有 DATA 帧受流量控制;所有其他帧类型都不占用所通告的流量控制窗口的空间。这确保了重要的控制帧不会被流量控制阻塞。
6. 终端可以选择禁用自己的流量控制，但终端不能忽略来自另一端的流量控制信号。
7. HTTP/2 只定义了 WINDOW_UPDATE 帧的格式和语义(章节6.9)。这个文档没有规定接收方如何决定何时发送这个帧或它发送的值，也没有规定发送方如何选择发送数据包。实现可以选择满足需求的任何算法。

实现还负责发送请求和响应的优先级，选择如何避免请求的队首阻塞，以及管理新流的创建。它们的算法选择可以与任何流控制算法交互。

#### 5.2.2. Appropriate Use of Flow Control

流量控制是为了保护在资源限制下运行的端点。例如，一个代理需要在多个连接之间共享内存，也可能有一个缓慢的上游连接和一个快速的下游连接。流量控制解决了接收端无法在一个流上处理数据，但希望在同一个连接上继续处理其他流的情况。

不需要这个功能的部署可以通告一个最大大小的流量控制窗口 (231-1)，并且可以在接收到数据时发送一个 WINDOW_UPDATE 帧来维护这个窗口。这实际上禁用了对该接收端的流量控制。相反，发送端总是受制于接收端通告的流量控制窗口。

在资源受限(例如内存)的部署中，可以采用流量控制来限制一端可以消耗的内存数量。但是，请注意，如果在不知道 带宽*延迟乘积 的情况下启用流量控制，这可能导致可用网络资源的次优使用(参见 [RFC7323])。

即使完全了解当前的 带宽*延迟 乘积，实现流量控制也是很困难的。一旦数据可用，终端必须从 TCP 接收缓冲区读取并处理 HTTP/2 帧。如果不能及时读取关键帧(如 WINDOW_UPDATE)，可能会导致死锁。及时读取帧不会让终端面临资源耗尽攻击，因为 HTTP/2 流量控制限制了资源承诺。

#### 5.2.3. Flow-Control Performance

如果一个端点不能确保它的端在这个连接上始终有大于另一端 带宽*延迟乘积 的可用流量控制窗口空间，它的接收吞吐量将受到 HTTP/2 流量控制的限制。这将导致性能下降。

及时发送 WINDOW_UPDATE 帧可以提高性能。终端需要在提高接收吞吐量的需求和管理资源耗尽风险的需求之间取得平衡，在定义管理窗口大小的策略时，应该仔细注意 10.5 节。

### 5.3. Prioritization

在 HTTP/2 这样的多路复用协议中，优先分配带宽和计算资源给流是获得良好性能的关键。一个糟糕的优先级方案会导致 HTTP/2 性能不佳。如果 TCP 层没有并行，性能可能会比 HTTP/1.1 差得多。

一个好的优先级方案受益于上下文知识的应用，例如资源的内容，资源如何相互关联，以及这些资源将如何被对等节点使用。特别是，客户端可以掌握与服务器优先级相关的请求优先级信息。在这些情况下，让客户端提供优先级信息可以提高性能。

#### 5.3.1. Background on Priority in RFC 7540

RFC 7540 定义了一个用于发送请求优先级的丰富系统。然而，这个系统被证明是复杂的，并且没有统一实施。

灵活的方案意味着客户有可能以非常不同的方式表达优先级，而所采用的方法几乎没有一致性。对于服务器，实现对该方案的通用支持很复杂。优先级的实施在客户端和服务器上都是不平衡的。许多服务器部署在优先处理请求时忽略了客户端信号。

简而言之，RFC 7540 [ RFC7540 ]中的优先级信令并不成功。

#### 5.3.2. Priority Signaling in This Document

对 HTTP/2 的这次更新弃用了RFC 7540 [ RFC7540 ]中定义的优先级信号。与优先信号相关的大部分文本未包含在本文档中。保留帧字段的描述和一些强制性处理，以确保本文档的实现与使用 RFC 7540 中描述的优先级信号的实现保持互操作性。

[ RFC7540 ]的第 5.3 节中保留了对 RFC 7540 优先级方案的详尽描述。

在许多情况下，信令优先级信息是获得良好性能所必需的。在信令优先级信息很重要的地方，鼓励端点使用替代方案，例如[ HTTP-PRIORITY ]中描述的方案。

虽然来自 RFC 7540 的优先级信令没有被广泛采用，但它提供的信息在没有更好信息的情况下仍然有用。在HEADERS或PRIORITY帧中接收优先级信号的端点可以从应用该信息中受益。特别是，在没有替代方案的情况下，使用这些信号的实现不会从丢弃这些优先级信号中获益。

在没有任何优先级信号的情况下，服务器应该使用其他上下文信息来确定请求的优先级。服务器可以将完全没有信号解释为客户端尚未实现该功能的指示。[ RFC7540 ]第 5.3.5 节中描述的默认值在大多数情况下性能不佳，不太可能是故意使用它们。

### 5.4. Error Handing

HTTP/2 框架允许两类错误：

- 导致整个连接不可用的错误情况是连接错误。
- 单个流中的错误是流错误。

错误代码列表包含在第 7 节中。

端点可能会遇到会导致多个错误的帧。实现可能会在处理过程中发现多个错误，但它们最多应该报告一个流和一个连接错误作为结果。

为给定流报告的第一个流错误会阻止报告该流上的任何其他错误。相比之下，该协议允许多个GOAWAY帧，尽管端点应该只报告一种类型的连接错误，除非在正常关闭期间遇到错误。如果发生这种情况，除了包含NO_ERROR的任何先前 GOAWAY 之外，端点可以发送一个带有新错误代码的附加 GOAWAY 帧。

如果端点检测到多个不同的错误，它可以选择报告这些错误中的任何一个。如果帧导致连接错误，则必须报告该错误。此外，端点在检测到错误条件时可以使用任何适用的错误代码；一般错误代码（例如PROTOCOL_ERROR或INTERNAL_ERROR）总是可以用来代替更具体的错误代码。

#### 5.4.1. Connection Error Handing

连接错误是阻止进一步处理帧层或破坏任何连接状态的任何错误。

遇到连接错误的端点应该首先发送一个GOAWAY 帧（第 6.8 节），其中包含它从其对等方成功接收到的最后一个流的流标识符。GOAWAY帧包含一个错误代码（第 7 节），指示连接终止的原因。在为错误条件发送 GOAWAY帧后，端点必须关闭 TCP 连接。

接收端点可能无法可靠地接收到GOAWAY 。在连接错误的情况下， GOAWAY仅提供最大努力尝试与对等方就连接终止的原因进行通信。

端点可以随时结束连接。特别是，端点可以选择将流错误视为连接错误。如果环境允许，端点应该在结束连接时发送一个 GOAWAY帧。

#### 5.4.2. Stream Error Handing

流错误是与特定流相关的错误，不会影响其他流的处理。

检测到流错误的端点发送RST_STREAM帧（第 6.4 节），其中包含发生错误的流的流标识符。RST_STREAM帧包含指示错误类型的错误代码。

RST_STREAM是端点可以在流上发送的最后一帧。发送RST_STREAM帧的对等方必须准备好接收任何由远程对等方发送或排队等待发送的帧。这些帧可以忽略，除非它们修改连接状态（例如为 字段部分压缩（第 4.3 节）或流量控制维护的状态）。

通常，端点不应该为任何流发送超过一个RST_STREAM帧。但是，如果端点在超过往返时间后在关闭的流上接收到帧，则它可以发送额外的RST_STREAM帧。允许此行为来处理行为不当的实现。

为避免循环，端点不得发送RST_STREAM以响应 RST_STREAM帧。

#### 5.4.3. Connection Termination

如果在流保持“打开”或“半关闭”状态时关闭或重置 TCP 连接，则受影响的流无法自动重试（有关详细信息，请参阅第 8.7 节）。

### 5.5. Extending HTTP/2

HTTP/2 允许扩展协议。在本节描述的限制范围内，协议扩展可用于提供附加服务或改变协议的任何方面。扩展仅在单个 HTTP/2 连接范围内有效。

这适用于本文档中定义的协议元素。这不会影响用于扩展 HTTP 的现有选项，例如定义新方法、状态代码或字段（请参阅[ HTTP ]的第 16 节）。

允许扩展使用新的帧类型（第 4.1 节）、新的 设置（第 6.5 节）或新的错误代码（第 7 节）。用于管理这些扩展点的注册表在[ RFC7540 ]的第 11 节中定义。

实现必须忽略所有可扩展协议元素中的未知或不支持的值。实现必须丢弃具有未知或不支持类型的帧。这意味着这些扩展点中的任何一个都可以被扩展安全地使用，而无需事先安排或协商。但是，不允许出现在字段块中间的扩展帧（第 4.3 节） ；这些必须被视为PROTOCOL_ERROR类型的 连接错误（第 5.4.1 节）。

扩展应该避免改变本文档中定义的协议元素或没有定义扩展机制的元素。这包括对帧布局的更改、对帧组成HTTP 消息（第 8.1 节）的方式的添加或更改、伪标头字段的定义，或对合规端点可能视为连接的任何协议元素的更改错误（第 5.4.1 节）。

更改现有协议元素或状态的扩展必须在使用前协商。例如，更改HEADERS框架布局的扩展不能使用，直到对等方给出一个积极的信号表明这是可以接受的。在这种情况下，也可能需要在修改后的布局生效时进行协调。例如，将DATA帧以外的帧视为流量控制需要更改两端点都需要理解的语义，因此这只能通过协商来完成。

本文档没有强制要求使用特定方法来协商扩展的使用，但指出可以为此目的使用一个设置（第 6.5.2 节） 。如果两个对等点都设置了一个值，表示愿意使用该扩展，则可以使用该扩展。如果设置用于扩展协商，则初始值必须以扩展最初被禁用的方式定义。

## 6. Frame Definitions

本规范定义了多种帧类型，每种帧类型由唯一的 8 位类型代码标识。每种帧类型在连接作为一个整体或单个流的建立和管理中都有不同的用途。

特定帧类型的传输可以改变连接的状态。如果端点无法保持连接状态的同步视图，则连接内的成功通信将不再可能。因此，端点对使用任何给定框架如何影响状态有一个共同的理解是很重要的。

### 6.1. DATA

数据帧（类型=0x00）传送与流关联的任意可变长度的八位字节序列。例如，一个或多个数据帧用于携带 HTTP 请求或响应消息内容。

数据帧也可以包含填充。填充可以添加到 DATA 帧以掩盖消息的大小。填充是一项安全功能；参见第 10.7 节。

```
DATA Frame {
  Length (24),
  Type (8) = 0x00,

  Unused Flags (4),
  PADDED Flag (1),
  Unused Flags (2),
  END_STREAM Flag (1),

  Reserved (1),
  Stream Identifier (31),

  [Pad Length (8)],
  Data (..),
  Padding (..2040),
}
```

长度、类型、未使用标志、保留和流标识符字段在第 4 节中描述。数据帧包含以下附加字段：

- padding 长度：一个 8 位字段，包含以八位字节为单位的帧填充长度。该字段是有条件的，仅当设置了 PADDED 标志时才存在。
- 数据：应用程序数据。数据量是帧有效载荷减去存在的其他字段的长度后的剩余部分。
- 填充：不包含应用程序语义值的填充八位字节。发送时填充八位字节必须设置为零。接收方没有义务验证填充，但可以将非零填充视为PROTOCOL_ERROR类型的连接错误（第 5.4.1 节）。

数据帧定义了以下标志：

- 填充（0x08）：设置后，PADDED 标志表示 Pad Length 字段及其描述的任何填充都存在。
- 结束流（0x01）：设置后，END_STREAM 标志指示此帧是端点将为已识别流发送的最后一帧。设置此标志会导致流进入“半关闭”状态或“关闭”状态之一（第 5.1 节）。

> 注意：在发送所有数据后了解流关闭的端点可以通过发送具有零长度数据字段和 END_STREAM 标志集的 STREAM 帧来关闭流。这只有在端点不发送尾部时才有可能，因为在这种情况下 END_STREAM 标志出现在 HEADERS 帧上；参见第 8.1 节。

数据帧必须与流关联。如果接收到流标识符字段为 0x00 的数据帧，接收方必须响应类型为 PROTOCOL_ERROR 的连接错误（第 5.4.1 节）。

DATA 帧受流量控制，只能在流处于“打开”或“半关闭（远程）”状态时发送。整个 DATA 帧有效负载包含在流量控制中，包括 Pad Length 和 Padding 字段（如果存在）。如果接收到的数据帧的流不处于“打开”或“半关闭（本地）”状态，则接收方必须响应类型为 STREAM_CLOSED 的流错误（第 5.4.2 节）。

填充八位字节的总数由填充长度字段的值确定。如果填充的长度是帧有效载荷的长度或更大，接收方 必须将其视为 PROTOCOL_ERROR 类型的连接错误（第 5.4.1 节）。

> 注意：通过包含值为零的填充长度字段，可以将帧的大小增加一个八位字节。

### 6.2. HEADERS

HEADERS 帧（type=0x01）用于打开流（第 5.1 节），另外还携带一个字段块片段。尽管名称如此，但 HEADERS 框架可以携带标题部分或尾部部分。HEADERS 帧可以在“空闲”、“保留（本地）”、“打开”或“半关闭（远程）”状态下在流上发送。

```
HEADERS Frame {
  Length (24),
  Type (8) = 0x01,

  Unused Flags (2),
  PRIORITY Flag (1),
  Unused Flag (1),
  PADDED Flag (1),
  END_HEADERS Flag (1),
  Unused Flag (1),
  END_STREAM Flag (1),

  Reserved (1),
  Stream Identifier (31),

  [Pad Length (8)],
  [Exclusive (1)],
  [Stream Dependency (31)],
  [Weight (8)],
  Field Block Fragment (..),
  Padding (..2040),
}
```

长度、类型、未使用标志、保留和流标识符字段在第 4 节中描述。HEADERS 帧有效负载具有以下附加字段：

- padding 长度： 一个 8 位字段，包含以八位字节为单位的帧填充长度。该字段仅在设置了 PADDED 标志时存在。
- Exclusive： 一位标志。该字段仅在设置了 PRIORITY 标志时出现。HEADERS 帧中的优先级信号已弃用；参见第 5.3.2 节。
- Stream Dependency： 一个 31 位的流标识符。该字段仅在设置了 PRIORITY 标志时出现。
- Weight： 一个无符号的 8 位整数。该字段仅在设置了 PRIORITY 标志时出现。
- Field Block Fragment： 字段块片段（第4.3 节）。
- 填充： 不包含应用程序语义值的填充八位字节。发送时填充八位字节必须设置为零。接收方没有义务验证填充，但可以将非零填充视为 PROTOCOL_ERROR 类型的连接错误（第 5.4.1 节）。

HEADERS 帧定义了以下标志：

- 优先级（0x20）：设置时，PRIORITY 标志指示存在 Exclusive、Stream Dependency 和 Weight 字段。
- 填充（0x08）：设置后，PADDED 标志表示 Pad Length 字段及其描述的任何填充都存在。
- END_HEADERS (0x04): 设置时，END_HEADERS 标志指示此帧包含整个字段块（第 4.3 节）并且后面没有任何 CONTINUATION帧。没有设置 END_HEADERS 标志的 HEADERS 帧必须跟在 同一流的CONTINUATION帧之后。接收方必须将任何其他类型的帧或不同流上的帧的接收视为PROTOCOL_ERROR类型的 连接错误（第 5.4.1 节）。
- 结束流（0x01）：设置时，END_STREAM 标志指示字段块（第 4.3 节）是端点将为已识别流发送的最后一个。设置了 END_STREAM 标志的 HEADERS 帧表示流的结束。但是，设置了 END_STREAM 标志的 HEADERS 帧后面可以跟 在同一流上的 CONTINUATION 帧。从逻辑上讲， CONTINUATION 帧是 HEADERS 帧的一部分。

HEADERS 帧的帧负载包含一个字段块片段（第 4.3 节）。不适合 HEADERS 帧的字段块在 CONTINUATION 帧中继续（第 6.10 节）。

HEADERS 帧必须与流相关联。如果接收到流标识符字段为 0x00 的 HEADERS 帧，则接收方必须响应类型为 PROTOCOL_ERROR 的连接错误（第 5.4.1 节）。

HEADERS 帧改变连接状态，如第 4.3 节所述。

填充八位字节的总数由填充长度字段的值确定。如果填充的长度是帧有效载荷的长度或更大，接收方 必须将其视为 PROTOCOL_ERROR 类型的连接错误（第 5.4.1 节）。

注意：通过包含值为零的填充长度字段，可以将帧的大小增加一个八位字节。

### 6.3. PRIORITY

PRIORITY 帧（type=0x02）已弃用；参见第 5.3.2 节。PRIORITY 帧可以在任何流状态下发送，包括空闲或关闭的流。

```
PRIORITY Frame {
  Length (24) = 0x05,
  Type (8) = 0x02,

  Unused Flags (8),

  Reserved (1),
  Stream Identifier (31),

  Exclusive (1),
  Stream Dependency (31),
  Weight (8),
}
```

长度、类型、未使用标志、保留和流标识符字段在第 4 节中描述。PRIORITY 帧的帧有效载荷包含以下附加字段：

Exclusive：一位标志。
Stream Dependency：一个 31 位的流标识符。
Weight：一个无符号的 8 位整数。

PRIORITY 帧不定义任何标志。

PRIORITY 帧总是标识一个流。如果接收到一个流标识符为 0x00 的 PRIORITY 帧，接收方必须响应一个类型为 PROTOCOL_ERROR 的连接错误（第 5.4.1 节）。

发送或接收优先级帧不会影响任何流的状态（第 5.1 节）。PRIORITY 帧可以在任何状态下在流上发送，包括“空闲”或“关闭”。PRIORITY 帧不能在包含单个字段块的连续帧之间发送（第 4.3 节）。

长度不是 5 个八位字节的 PRIORITY 帧必须被视为 FRAME_SIZE_ERROR 类型的流错误（第 5.4.2 节）。

### 6.4. RST_STREAM

RST_STREAM 帧（类型=0x03）允许立即终止流。发送 RST_STREAM 以请求取消流或指示已发生错误情况。

```
RST_STREAM Frame {
  Length (24) = 0x04,
  Type (8) = 0x03,

  Unused Flags (8),

  Reserved (1),
  Stream Identifier (31),

  Error Code (32),
}
```

长度、类型、未使用标志、保留和流标识符字段在第 4 节中描述。此外，RST_STREAM 帧包含一个无符号的 32 位整数，用于标识错误代码（第 7 节）。错误代码指示流被终止的原因。

RST_STREAM 帧没有定义任何标志。

RST_STREAM 帧完全终止引用流并使其进入“关闭”状态。在流上接收到 RST_STREAM 后，接收方不得为该流发送额外的帧，PRIORITY除外。但是，在发送 RST_STREAM 之后，发送端点必须准备好接收和处理在 RST_STREAM 到达之前对等方可能已经发送的在流上发送的额外帧。

RST_STREAM 帧必须与流关联。如果接收到流标识符为 0x00 的 RST_STREAM 帧，接收方必须将其视为 PROTOCOL_ERROR 类型的 连接错误（第 5.4.1 节）。

不得为处于“空闲”状态的流发送RST_STREAM 帧。如果接收到标识空闲流的 RST_STREAM 帧，接收方必须将其视为 PROTOCOL_ERROR 类型的 连接错误（第 5.4.1 节）。

长度不是 4 个八位字节的 RST_STREAM 帧必须被视为 FRAME_SIZE_ERROR 类型的 连接错误（第 5.4.1 节）。

### 6.5. SETTINGS

SETTINGS 帧（类型=0x04）传达影响端点通信方式的配置参数，例如对端点行为的偏好和约束。SETTINGS 框架也用于确认收到这些设置。单独地，来自 SETTINGS 帧的配置参数被称为“设置”。

设置方式是非协商的；它们描述了发送方的特征，这些特征被接收方使用。每个对等点可以通告相同设置的不同值。例如，客户端可能会设置一个较高的初始流量控制窗口，而服务器可能会设置一个较低的值以节省资源。

SETTINGS 帧必须在连接开始时由两个端点发送，并且可以在连接生命周期内的任何其他时间由任何一个端点发送。实现必须支持本规范定义的所有设置。

SETTINGS 框架中的每个参数都会替换该参数的任何现有值。设置按照它们出现的顺序进行处理，并且 SETTINGS 帧的接收者不需要维护除了每个设置的当前值之外的任何状态。因此，SETTINGS 参数的值是接收者看到的最后一个值。

SETTINGS 帧由接收方确认。为了启用它，SETTINGS 帧定义了 ACK 标志：

确认（0x01）：设置后，ACK 标志表示此帧确认接收和应用对等方的 SETTINGS 帧。设置此位时，SETTINGS 帧的帧有效负载必须为空。收到设置了 ACK 标志且长度字段值不是 0 的 SETTINGS 帧必须被视为 FRAME_SIZE_ERROR 类型的连接错误（第 5.4.1 节）。有关详细信息，请参阅第 6.5.3 节（“设置同步”）。
SETTINGS 帧始终应用于连接，而不是单个流。SETTINGS 帧的流标识符必须为零 (0x00)。如果一个端点接收到一个 SETTINGS 帧，其 Stream Identifier 字段不是 0x00，端点必须响应一个PROTOCOL_ERROR 类型的 连接错误（第 5.4.1 节）。

SETTINGS 帧影响连接状态。格式错误或不完整的 SETTINGS 帧 必须被视为 PROTOCOL_ERROR 类型的连接错误（第 5.4.1 节）。

长度不是 6 个八位字节的倍数的 SETTINGS 帧必须被视为 FRAME_SIZE_ERROR 类型的连接错误（第 5.4.1 节）。

#### 6.5.1. SETTINGS Format

SETTINGS 帧的帧有效载荷由零个或多个设置组成，每个设置由一个无符号的 16 位设置标识符和一个无符号的 32 位值组成。

```
SETTINGS Frame {
  Length (24),
  Type (8) = 0x04,

  Unused Flags (7),
  ACK Flag (1),

  Reserved (1),
  Stream Identifier (31) = 0,

  Setting (48) ...,
}

Setting {
  Identifier (16),
  Value (32),
}
```

长度、类型、未使用标志、保留和流标识符字段在第 4 节中描述。SETTINGS 帧的帧负载包含任意数量的设置字段，每个字段包括：

- Identifier：一个 16 位的设置标识符；参见第 6.5.2 节。
- Value：设置的 32 位值。

#### 6.5.2. Defined Settings

定义了以下设置：

- SETTINGS_HEADER_TABLE_SIZE (0x01): 此设置允许发送方以八位字节为单位通知远程端点用于解码字段块的压缩表的最大大小。编码器可以通过使用特定于字段块内压缩格式的信号来选择等于或小于此值的任何大小（请参阅[ COMPRESSION ]）。初始值为 4,096 个八位字节。
- SETTINGS_ENABLE_PUSH (0x02): 此设置可用于启用或禁用服务器推送。如果服务器收到此参数设置为 0 的值，则不得发送 PUSH_PROMISE帧；参见第 8.4 节。已将此参数设置为 0 并已确认的客户端必须将PUSH_PROMISE帧的接收视为PROTOCOL_ERROR类型的连接错误（第 5.4.1 节）。SETTINGS_ENABLE_PUSH 的初始值为 1。对于客户端来说，这个值表示它愿意接收 PUSH_PROMISE 帧。对于服务器，这个初始值没有影响，等同于值 0。除 0 或 1 之外的任何值都必须被视为 PROTOCOL_ERROR类型的 连接错误（第 5.4.1 节）。服务器不得显式将此值设置为 1。服务器可以在发送 SETTINGS 帧时选择忽略此设置，但如果服务器确实包含一个值，则它必须 为 0。客户端必须将收到的 SETTINGS 帧视为SETTINGS_ENABLE_PUSH 设置为 1 作为PROTOCOL_ERROR类型的 连接错误（第 5.4.1 节）。
- SETTINGS_MAX_CONCURRENT_STREAMS (0x03): 此设置指示发送方将允许的最大并发流数。这个限制是有方向的：它适用于发送方允许接收方创建的流的数量。最初，此值没有限制。建议该值不小于100，以免不必要地限制并行度。端点不应将SETTINGS_MAX_CONCURRENT_STREAMS 的值 0视为特殊值。零值确实会阻止创建新流；但是，对于活动流耗尽的任何限制，也可能发生这种情况。服务器 应该只在短时间内设置零值；如果服务器不想接受请求，则关闭连接更为合适。
- SETTINGS_INITIAL_WINDOW_SIZE (0x04): 此设置指示发送方用于流级流量控制的初始窗口大小（以八位字节为单位）。初始值为 2 16 -1 (65,535) 个八位字节。此设置会影响所有流的窗口大小（请参阅第 6.9.2 节）。大于最大流量控制窗口大小 2 31 -1的值必须 被视为FLOW_CONTROL_ERROR类型的连接错误（第 5.4.1 节）。
- SETTINGS_MAX_FRAME_SIZE (0x05): 此设置指示发送方愿意接收的最大帧有效负载的大小，以八位字节为单位。初始值为 2 14 (16,384) 个八位字节。端点通告的值必须介于此初始值和允许的最大帧大小（2 24 -1 或 16,777,215 个八位字节）之间，包括在内。超出此范围的值 必须被视为PROTOCOL_ERROR 类型的连接错误（第 5.4.1 节）。
- SETTINGS_MAX_HEADER_LIST_SIZE (0x06): 此建议设置以八位字节为单位通知对等方发送方准备接受的最大字段部分大小。该值基于字段行的未压缩大小，包括以八位字节为单位的名称和值的长度加上每个字段行的 32 个八位字节的开销。

对于任何给定的请求，可以强制执行低于所公布的限制。此设置的初始值是无限制的。

接收到带有任何未知或不支持标识符的 SETTINGS 帧的端点 必须忽略该设置。

#### 6.5.3. Settins Synchronization

SETTINGS 中的大多数值受益于或需要了解对等方何时收到并应用更改的参数值。为了提供这样的同步时间点，未设置 ACK 标志的 SETTINGS 帧的接收者必须在收到后尽快应用更新的设置。SETTINGS 帧按照它们被接收的顺序被确认。

SETTINGS 帧中的值必须按照它们出现的顺序进行处理，值之间没有其他帧处理。必须忽略不受支持的设置。一旦处理完所有值，接收方必须立即发出一个设置了 ACK 标志的 SETTINGS 帧。在接收到设置了 ACK 标志的 SETTINGS 帧后，更改设置的发送方可以依赖已应用的最旧的未确认 SETTINGS 帧中的值。

如果 SETTINGS 帧的发送者在合理的时间内没有收到确认，它可能会发出一个 SETTINGS_TIMEOUT 类型的连接错误（第 5.4.1 节）。在设置超时时，需要为对等方的处理延迟留出一些余地；仅基于端点之间的往返时间的超时可能会导致虚假错误。

### 6.6. PUSH_PROMISE

PUSH_PROMISE 帧（类型=0x05）用于提前通知对等端点发送方打算发起的流。PUSH_PROMISE 帧包括端点计划创建的流的无符号 31 位标识符以及为流提供额外上下文的字段部分。 第 8.4 节包含对 PUSH_PROMISE 帧的使用的详尽描述。

```
PUSH_PROMISE Frame {
  Length (24),
  Type (8) = 0x05,

  Unused Flags (4),
  PADDED Flag (1),
  END_HEADERS Flag (1),
  Unused Flags (2),

  Reserved (1),
  Stream Identifier (31),

  [Pad Length (8)],
  Reserved (1),
  Promised Stream ID (31),
  Field Block Fragment (..),
  Padding (..2040),
}
```

长度、类型、未使用标志、保留和流标识符字段在第 4 节中描述。PUSH_PROMISE 帧有效负载具有以下附加字段：

- Pad 长度：一个 8 位字段，包含以八位字节为单位的帧填充长度。该字段仅在设置了 PADDED 标志时存在。
- Promised Stream ID：一个无符号的 31 位整数，用于标识由 PUSH_PROMISE 保留的流。承诺的流标识符必须是发送方发送的下一个流的有效选择（参见第 5.1.1 节中的“新流标识符” ）。
- Field Block Fragment：包含请求控制数据和标头部分的字段块片段（第4.3 节） 。
- Padding：不包含应用程序语义值的填充八位字节。发送时填充八位字节必须设置为零。接收方没有义务验证填充，但可以将非零填充视为 PROTOCOL_ERROR 类型的连接错误（第 5.4.1 节）。

PUSH_PROMISE 帧定义了以下标志：
- 填充（0x08）：设置后，PADDED 标志表示 Pad Length 字段及其描述的任何填充都存在。
- END_HEADERS (0x04): 设置时，END_HEADERS 标志指示此帧包含整个字段块（第 4.3 节）并且后面没有任何 CONTINUATION 帧。没有设置 END_HEADERS 标志的 PUSH_PROMISE 帧必须跟在同一流的 CONTINUATION 帧之后。接收方必须将任何其他类型的帧或不同流上的帧的接收视为PROTOCOL_ERROR类型的 连接错误（第 5.4.1 节）。

PUSH_PROMISE 帧必须仅在处于“打开”或“半关闭（远程）”状态的对等发起的流上发送。PUSH_PROMISE 帧的流标识符指示与其关联的流。如果流标识符字段指定值 0x00，接收者必须响应类型为 PROTOCOL_ERROR 的连接错误（第 5.4.1 节）。承诺的流不需要按照承诺的顺序使用。PUSH_PROMISE 只保留流标识符供以后使用。如果对等端点的SETTINGS_ENABLE_PUSH设置设置为 0，则不得发送PUSH_PROMISE 。已设置此设置并已收到确认的端点必须将 PUSH_PROMISE 帧的接收视为 PROTOCOL_ERROR 类型的连接错误（第 5.4.1 节） .

PUSH_PROMISE 帧的接收者可以通过将引用承诺的流标识符的 RST_STREAM 返回给 PUSH_PROMISE 的发送者来选择拒绝承诺的流 。

PUSH_PROMISE 帧以两种方式修改连接状态。首先，包含一个字段块（第 4.3 节）可能会修改为字段部分压缩维护的状态。其次，PUSH_PROMISE 还保留了一个流供以后使用，使承诺的流进入“保留（本地）”或“保留（远程）”状态。发送者不得在流上发送 PUSH_PROMISE，除非该流是“打开”或“半关闭（远程）”；发送方必须确保承诺的流是新流标识符 的有效选择（第 5.1.1 节）（即，承诺的流必须 处于“空闲”状态）。

由于 PUSH_PROMISE 保留流，忽略 PUSH_PROMISE 帧会导致流状态变得不确定。接收方必须将在既不是“打开”也不是“半关闭（本地）”的流上接收到 PUSH_PROMISE 视为类型为 PROTOCOL_ERROR 的连接错误（第 5.4.1 节）。然而，已经 在相关流上发送RST_STREAM 的端点必须处理可能在 RST_STREAM 帧被接收和处理之前创建的 PUSH_PROMISE 帧。

接收方必须将承诺非法流标识符（第 5.1.1 节）的 PUSH_PROMISE 的接收视为 PROTOCOL_ERROR 类型的 连接错误（第 5.4.1 节）。注意，非法流标识符是当前不处于“空闲”状态的流的标识符。

填充八位字节的总数由填充长度字段的值确定。如果填充的长度是帧有效载荷的长度或更大，接收方 必须将其视为PROTOCOL_ERROR类型的连接错误（第 5.4.1 节）。

注意：通过包含值为零的填充长度字段，可以将帧的大小增加一个八位字节。

### 6.7. PING

PING 帧（类型=0x06）是一种用于测量来自发送方的最小往返时间以及确定空闲连接是否仍然有效的机制。PING 帧可以从任何端点发送。

```
PING Frame {
  Length (24) = 0x08,
  Type (8) = 0x06,

  Unused Flags (7),
  ACK Flag (1),

  Reserved (1),
  Stream Identifier (31) = 0,

  Opaque Data (64),
}
```

长度、类型、未使用标志、保留和流标识符字段在第 4 节中描述。

除了帧头之外，PING 帧必须在帧有效负载中包含 8 个八位字节的不透明数据。发送方可以包含它选择的任何值并以任何方式使用这些八位字节。

不包含 ACK 标志的 PING 帧的接收者必须发送一个设置了 ACK 标志的 PING 帧作为响应，并具有相同的帧负载。PING 响应应该比任何其他帧都具有更高的优先级。

PING 帧定义了以下标志：

- 确认（0x01）： 设置后，ACK 标志指示此 PING 帧是 PING 响应。端点必须 在 PING 响应中设置此标志。端点不得响应包含此标志的 PING 帧。
PING 帧不与任何单独的流相关联。如果接收到的 PING 帧的流标识符字段值不是 0x00，则接收方必须响应 类型为 PROTOCOL_ERROR 的连接错误（第 5.4.1 节）。

收到长度字段值不是 8 的 PING 帧必须被视为 FRAME_SIZE_ERROR 类型的 连接错误（第 5.4.1 节）。

### 6.8. GOAWAY

GOAWAY 帧（类型=0x07）用于启动连接关闭或发出严重错误情况的信号。GOAWAY 允许端点优雅地停止接受新流，同时仍然完成对先前建立的流的处理。这会启用管理操作，例如服务器维护。

在开始新流的端点和发送 GOAWAY 帧的远程对等方之间存在固有的竞争条件。为了处理这种情况，GOAWAY 包含最后一个对等发起的流的流标识符，该流已经或可能在此连接的发送端点上处理。例如，如果服务器发送一个 GOAWAY 帧，则标识的流是客户端发起的编号最高的流。

一旦发送了 GOAWAY，如果流的标识符高于包含的最后一个流标识符，则发送方将忽略在接收方发起的流上发送的帧。GOAWAY 帧的接收者不得在连接上打开额外的流，尽管可以为新流建立新连接。

如果 GOAWAY 的接收者在流上发送的数据具有比 GOAWAY 帧中指示的更高的流标识符，则这些流不会或不会被处理。GOAWAY 帧的接收者可以将流视为从未创建过，从而允许稍后在新连接上重试这些流。

端点应该总是在关闭连接之前发送一个 GOAWAY 帧，以便远程对等方可以知道流是否已被部分处理。例如，如果 HTTP 客户端在服务器关闭连接的同时发送 POST，如果服务器不发送 GOAWAY 帧以指示它可能具有哪些流，则客户端无法知道服务器是否开始处理该 POST 请求采取行动。

一个端点可能会选择关闭连接而不为行为不端的对等方发送 GOAWAY。

GOAWAY 帧可能不会立即关闭连接；不再使用连接的 GOAWAY 接收者应该在终止连接之前发送一个 GOAWAY 帧。

```
GOAWAY Frame {
  Length (24),
  Type (8) = 0x07,

  Unused Flags (8),

  Reserved (1),
  Stream Identifier (31) = 0,

  Reserved (1),
  Last-Stream-ID (31),
  Error Code (32),
  Additional Debug Data (..),
}
```

长度、类型、未使用标志、保留和流标识符字段在第 4 节中描述。

GOAWAY 框架没有定义任何标志。

GOAWAY 帧适用于连接，而不是特定的流。端点必须将流标识符不是 0x00 的GOAWAY帧视为PROTOCOL_ERROR类型的 连接错误（第 5.4.1 节）。

GOAWAY 帧中的最后一个流标识符包含编号最高的流标识符，GOAWAY 帧的发送者可能已经对其采取了一些行动或可能尚未采取行动。可能已经以某种方式处理了直到并包括已识别流的所有流。如果没有流被处理，最后的流标识符可以设置为 0。

注意：在这种情况下，“已处理”意味着流中的一些数据被传递到某个更高层的软件，这些软件可能因此采取了一些行动。

如果连接在没有 GOAWAY 帧的情况下终止，则最后一个流标识符实际上是最高可能的流标识符。

在连接关闭之前未完全关闭的具有较低或相同编号标识符的流上，不可能重新尝试请求、事务或任何协议活动，但 HTTP GET、PUT 或 DELETE 等幂等操作除外。任何使用更高编号流的协议活动都可以使用新连接安全地重试。

编号小于或等于最后一个流标识符的流上的活动可能仍会成功完成。GOAWAY 帧的发送者可以通过发送 GOAWAY 帧优雅地关闭连接，将连接保持在“打开”状态，直到所有正在进行的流完成。

如果情况发生变化，端点可以发送多个 GOAWAY 帧。例如，在正常关闭期间发送带有NO_ERROR的 GOAWAY 的端点随后可能会遇到需要立即终止连接的情况。接收到的最后一个 GOAWAY 帧的最后一个流标识符指示可以对哪些流采取行动。端点不得增加它们在最后一个流标识符中发送的值，因为对等点可能已经在另一个连接上重试了未处理的请求。

无法重试请求的客户端会在服务器关闭连接时丢失所有正在进行的请求。对于可能不使用 HTTP/2 为客户端提供服务的中介来说尤其如此。试图正常关闭连接的服务器应该发送一个初始 GOAWAY 帧，其中最后一个流标识符设置为 2 31 -1 和一个NO_ERROR代码。这向客户端发出即将关闭并且禁止发起进一步请求的信号。在为任何飞行中的流创建留出时间（至少一个往返时间）之后，服务器可以 发送另一个带有更新的最后一个流标识符的 GOAWAY 帧。这确保可以干净地关闭连接而不会丢失请求。

发送 GOAWAY 帧后，发送方可以丢弃由接收方发起的流的帧，这些流的标识符高于所识别的最后一个流。但是，不能完全忽略任何改变连接状态的帧。例如， 必须最少处理HEADERS、PUSH_PROMISE和CONTINUATION帧 ，以确保为字段部分压缩维护的状态是一致的（参见第 4.3 节）；类似地，数据帧必须计入连接流控制窗口。未能处理这些帧会导致流量控制或字段部分压缩状态变得不同步。

GOAWAY 帧还包含一个 32 位错误代码（第 7 节），其中包含关闭连接的原因。

端点可以将不透明数据附加到任何 GOAWAY 帧的帧有效载荷。附加调试数据仅用于诊断目的，不具有任何语义价值。调试信息可能包含对安全或隐私敏感的数据。记录的或以其他方式持久存储的调试数据必须有足够的保护措施以防止未经授权的访问。

### 6.9. WINDOW_UPDATE

WINDOW_UPDATE帧（type=0x08）用于实现流控；有关概述，请参见第 5.2 节。

流控制在两个级别上运行：在每个单独的流上和在整个连接上。

两种类型的流量控制都是逐跳的，即仅在两个端点之间。中介不在依赖连接之间转发 WINDOW_UPDATE 帧。但是，任何接收方对数据传输的节流都会间接导致流量控制信息向原始发送方传播。

流量控制仅适用于被识别为受流量控制影响的帧。在本文档中定义的帧类型中，这仅包括数据帧。免于流量控制的帧必须被接受和处理，除非接收方无法分配资源来处理该帧。如果接收方无法接受帧，则它可以用 FLOW_CONTROL_ERROR 类型的 流错误（第 5.4.2 节）或连接错误（第 5.4.1 节）进行响应。

```
WINDOW_UPDATE Frame {
  Length (24) = 0x04,
  Type (8) = 0x08,

  Unused Flags (8),

  Reserved (1),
  Stream Identifier (31),

  Reserved (1),
  Window Size Increment (31),
}
```

长度、类型、未使用标志、保留和流标识符字段在第 4 节中描述。WINDOW_UPDATE 帧的帧有效载荷是一个保留位加上一个无符号的 31 位整数，指示发送方除了现有的流控制窗口之外还可以传输的八位字节数。流控制窗口增量的合法范围是 1 到 2 31 -1 (2,147,483,647) 个八位字节。

WINDOW_UPDATE 框架没有定义任何标志。

WINDOW_UPDATE 帧可以特定于流或整个连接。在前一种情况下，帧的流标识符指示受影响的流；在后者中，值 “0” 表示整个连接是帧的主题。

接收方必须将接收到的流控制窗口增量为 0 的 WINDOW_UPDATE 帧视为 PROTOCOL_ERROR 类型的 流错误（第 5.4.2 节）；连接流控制窗口上的错误必须被视为连接错误（第 5.4.1 节）。

WINDOW_UPDATE 可以由已发送带有 END_STREAM 标志集的帧的对等方发送。这意味着接收器可以在“半关闭（远程）”或“关闭”状态的流上接收 WINDOW_UPDATE 帧。接收方不得将此视为错误（参见第 5.1 节）。

接收流控制帧的接收者必须始终考虑其对连接流控制窗口的贡献，除非接收者将此视为连接错误（第 5.4.1 节）。即使帧出错，这也是必要的。发送方向流量控制窗口计数帧，但如果接收方不这样做，则发送方和接收方的流量控制窗口可能会变得不同。

长度不是 4 个八位字节的 WINDOW_UPDATE 帧必须被视为FRAME_SIZE_ERROR类型的 连接错误（第 5.4.1 节）。

#### 6.9.1. The Flow-Control Window

HTTP/2 中的流量控制是使用每个发送者在每个流上保留的窗口来实现的。流量控制窗口是一个简单的整数值，表示允许发送方传输多少个八位字节的数据；因此，它的大小是接收器缓冲能力的度量。

适用的流控窗口有两种：流流控窗口和连接流控窗口。发送方不得发送长度超过接收方通告的任一流量控制窗口中可用空间的流量控制帧。如果任一流控制窗口中没有可用空间，则可以发送带有 END_STREAM 标志设置的零长度帧（即空数据帧） 。

对于流量控制计算，不计算 9 字节帧头。

发送流控帧后，发送方将两个窗口中的可用空间减少所传输帧的长度。

帧的接收者发送 WINDOW_UPDATE 帧，因为它消耗数据并释放流控制窗口中的空间。为流级和连接级流量控制窗口发送单独的 WINDOW_UPDATE 帧。建议接收方采用适当的机制来避免发送增量非常小的 WINDOW_UPDATE 帧；请参阅[ RFC1122 ]的第 4.2.3.3 节。

接收 WINDOW_UPDATE 帧的发送方按照帧中指定的数量更新相应的窗口。

发送方不得允许流量控制窗口超过 2 31 -1 个八位字节。如果发送方收到导致流量控制窗口超过此最大值的 WINDOW_UPDATE，则它必须视情况终止流或连接。对于流，发送方发送错误代码为  FLOW_CONTROL_ERROR的RST_STREAM；对于连接，发送 错误代码为 FLOW_CONTROL_ERROR的GOAWAY帧。

来自发送方的流量控制帧和来自接收方的 WINDOW_UPDATE 帧彼此完全异步。此属性允许接收方积极更新发送方保留的窗口大小，以防止流停止。

#### 6.9.2. Initial Flow-Control Window Size

首次建立 HTTP/2 连接时，将创建新流，其初始流量控制窗口大小为 65,535 个八位字节。连接流量控制窗口也是 65,535 个八位字节。两个端点都可以通过在 SETTINGS 框架中包含 SETTINGS_INITIAL_WINDOW_SIZE 的值来调整新流的初始窗口大小 。只能使用 WINDOW_UPDATE 帧更改连接流控制窗口。

在收到为 SETTINGS_INITIAL_WINDOW_SIZE 设置值的 SETTINGS 帧之前，端点在发送流控帧时只能使用默认的初始窗口大小。类似地，连接流控制窗口是根据默认的初始窗口大小设置的，直到收到  WINDOW_UPDATE 帧。

除了更改尚未激活的流的流量控制窗口外， SETTINGS 帧还可以更改具有活动流量控制窗口的流的初始流量控制窗口大小（即，处于“打开”或“半”状态的流-关闭（远程）”状态）。当 SETTINGS_INITIAL_WINDOW_SIZE 的值 改变时，接收者必须通过新值和旧值之间的差异来调整它维护的所有流流控制窗口的大小。

对 SETTINGS_INITIAL_WINDOW_SIZE 的更改可能导致流量控制窗口中的可用空间变为负数。发送方必须跟踪负流量控制窗口并且不得发送新的流量控制帧，直到它收到导致流量控制窗口变为正的  WINDOW_UPDATE 帧。

例如，如果客户端在连接建立时立即发送 60 KB 并且服务器将初始窗口大小设置为 16 KB，则客户端将在收到SETTINGS帧时重新计算可用的流量控制窗口为 -44 KB 。客户端保留负流量控制窗口，直到 WINDOW_UPDATE 帧将窗口恢复为正，之后客户端可以恢复发送。

SETTINGS 框架不能改变连接流控制窗口。

端点必须将导致任何流控制窗口超过最大大小的 SETTINGS_INITIAL_WINDOW_SIZE 更改视为 FLOW_CONTROL_ERROR 类型的连接错误（第 5.4.1 节）。

#### 6.9.3. Reducing the Stream Window Size

希望使用比当前大小更小的流量控制窗口的接收者可以发送一个新的 SETTINGS 帧。但是，接收方必须准备好接收超过此窗口大小的数据，因为发送方可能会在处理 SETTINGS 帧之前发送超过下限的数据。

在发送减小初始流量控制窗口大小的设置帧后，接收方可以继续处理超过流量控制限制的流。允许流继续不会允许接收方立即减少它为流量控制窗口保留的空间。这些流的进展也可能停滞，因为 需要WINDOW_UPDATE 帧来允许发送方恢复发送。接收方可以为受影响的流发送错误代码为 FLOW_CONTROL_ERROR的RST_STREAM 。

### 6.10. CONTINUATION

CONTINUATION 帧（type=0x09）用于延续字段块片段序列（第 4.3 节）。可以发送任意数量的 CONTINUATION 帧，只要前一帧在同一流上并且是 没有设置 END_HEADERS 标志的 HEADERS、PUSH_PROMISE 或 CONTINUATION 帧。

```
CONTINUATION Frame {
  Length (24),
  Type (8) = 0x09,

  Unused Flags (5),
  END_HEADERS Flag (1),
  Unused Flags (2),

  Reserved (1),
  Stream Identifier (31),

  Field Block Fragment (..),
}
```

长度、类型、未使用标志、保留和流标识符字段在第 4 节中描述。CONTINUATION 帧有效载荷包含一个字段块片段（第 4.3 节）。

CONTINUATION 帧定义了以下标志：

END_HEADERS (0x04):
设置时，END_HEADERS 标志指示此帧结束一个字段块（第 4.3 节）。

如果未设置 END_HEADERS 标志，则该帧必须跟在另一个 CONTINUATION 帧之后。接收方必须将任何其他类型的帧或不同流上的帧的接收视为PROTOCOL_ERROR类型的连接错误（第 5.4.1 节）。

CONTINUATION 帧改变4.3 节中定义的连接状态。

CONTINUATION 帧必须与流关联。如果接收到流标识符字段为 0x00 的 CONTINUATION 帧，接收方必须响应类型为 PROTOCOL_ERROR 的连接错误（第 5.4.1 节） 。

CONTINUATION 帧之前必须有一个HEADERS、 PUSH_PROMISE或 CONTINUATION 帧，而没有设置 END_HEADERS 标志。观察到违反此规则的接收者必须响应类型为 PROTOCOL_ERROR的连接错误（第 5.4.1 节）。

## 7. Error Codes

错误代码是在 RST_STREAM 和 GOAWAY 帧中使用的 32 位字段，用于传达流或连接错误的原因。

错误代码共享一个公共代码空间。一些错误代码仅适用于流或整个连接，并且在其他上下文中没有定义的语义。

定义了以下错误代码：

- NO_ERROR (0x00): 关联的条件不是错误的结果。例如， GOAWAY可能包含此代码以指示正常关闭连接。
- PROTOCOL_ERROR (0x01): 终结点检测到一个不特定的协议错误。当更具体的错误代码不可用时使用此错误。
- INTERNAL_ERROR (0x02): 终结点遇到意外的内部错误。
- FLOW_CONTROL_ERROR (0x03): 端点检测到其对等方违反了流量控制协议。
- SETTINGS_TIMEOUT (0x04): 端点发送了一个SETTINGS帧，但没有及时收到响应。请参阅第 6.5.3 节（“设置同步”）。
- STREAM_CLOSED (0x05): 端点在流半关闭后收到一个帧。
- FRAME_SIZE_ERROR (0x06): 端点收到一个大小无效的帧。
- REFUSED_STREAM (0x07): 端点在执行任何应用程序处理之前拒绝流（ 有关详细信息，请参阅第 8.7 节）。
- CANCEL (0x08): 端点使用此错误代码来指示不再需要该流。
- COMPRESSION_ERROR (0x09): 端点无法维护连接的字段部分压缩上下文。
- CONNECT_ERROR (0x0a): 为响应CONNECT 请求（第 8.5 节）而建立的连接被重置或异常关闭。
- ENHANCE_YOUR_CALM (0x0b)：端点检测到其对等端正在表现出可能产生过载的行为。
- INADEQUATE_SECURITY (0x0c): 底层传输具有不满足最低安全要求的属性（请参阅第 9.2 节）。
- HTTP_1_1_REQUIRED (0x0d): 端点要求使用 HTTP/1.1 而不是 HTTP/2。

未知或不受支持的错误代码不得触发任何特殊行为。这些可能被实现视为等同于INTERNAL_ERROR。

## 8. Expressing HTTP Semantics in HTTP/2

HTTP/2 是 HTTP 消息抽象的实例（[ HTTP ]的第 6 节）。

### 8.1. HTTP Message Framing

#### 8.1.1. Malformed Messages

### 8.2. HTTP Fields

#### 8.2.1. Field Validity

#### 8.2.2. Connection-Specific Header Fields

#### 8.2.3. Compressing the Cookie Header Fields

### 8.3. HTTP Control Data

#### 8.3.1. Request Pseudo-Header Fields

#### 8.3.2. Response Pseudo-Header Fields

### 8.4. Server Push

#### 8.4.1. Push Requests

#### 8.4.2. Push Responses

### 8.5. The CONNECT Method

### 8.6. The Upgrade Header Field

### 8.7. Request Reliability

### 8.8. Examples

#### 8.8.1. Simple Request

#### 8.8.2. Simple Response

#### 8.8.3. Complex Request

#### 8.8.4. Response with Body

#### 8.8.5. Informational Responses

## 9. HTTP/2 Connections

### 9.1. Connection Management

#### 9.1.1. Connection Reuse

### 9.2. Use of TLS Features

#### 9.2.1. TLS 1.2 Features

#### 9.2.2. TLS 1.2 Cipher Suites

#### 9.2.3. TLS 1.3 Features
