# SIP: Session Initiation Protocol

> 原文 [https://datatracker.ietf.org/doc/html/rfc3261](https://datatracker.ietf.org/doc/html/rfc3261)

## 摘要

本文档描述了会话发起协议（SIP），这是一种应用层控制（信令）协议，用于创建、修改和终止与一个或多个参与者的会话。这些会话包括互联网电话呼叫、多媒体分发和多媒体会议。
用于创建会话的 SIP 邀请包含会话描述，允许参与者就一组兼容的媒体类型达成一致。SIP 使用称为代理服务器的元素来帮助将请求路由到用户的当前位置，对用户的服务进行身份验证和授权，实现提供商呼叫路由策略，并向用户提供功能。SIP 还提供了注册功能，允许用户上传其当前位置供代理服务器使用。SIP 运行在几种不同的传输协议之上。

## 1 Introduction

很多基于网络的应用软件都要求可以实现会话创建和管理，这里的会话可以视为是关联多个参与方交换数据的方式。实际部署这些应用软件是非常复杂的过程：用户可能在几个终端之间移动切换，用户也可能使用多个名字，用户也可能使用不同的媒体，有时还同时使用不同的媒体介质。目前，有很多不同的协议被准许在网络上运行，这些协议来传输各种形式的实时媒体会话数据，例如语音视频，文本信息。 Session Initiation Protocol (SIP) 支持以上所说的这些功能描述和相关的协议，它可以支持开启网络的用户代理来发现其他的终端，准许其他终端的某些会话属性，终端之间可以共享这些会话属性。

为了查询到期望的会话参与对象，和其他的功能，SIP 支持了网络主机设施创建（称为代理服务器），用户代理可以对会话发送注册，邀请和其他的请求。SIP 是一个敏捷，通用的工具，它用来创建，修改和结束会话，它可以不依赖于正在工作的传输协议，并且无需依赖于各种已建立的会话类型。

## 2 Overview of SIP Functionality

SIP 是一种应用层的控制协议，它可以创建，修改和结束多媒体会话（会议），例如网络电话呼叫。SIP 也可以邀请参与对象加入到已存在的会话，例如多方广播会议。它可以从当前存在的会话中再加入媒体也可以移除媒体。SIP 可以透明支持名称映射，转发服务，这些服务功能支持个人移动能力[参考链接 27]- 无论网络位置如何，用户可以在网络中保持一个对外单点可视的身份。

SIP 支持创建和结束媒体通信的五个方面的功能：

- 用户定位: 端系统的决定来支持通信；
- 用户有效性: 决定被呼叫方是否有意愿决定加入通信；
- 用户能力: 决定用户可使用的媒体和其媒体参数；
- 会话创建: "ringing"，在呼叫方和被呼叫方之间创建会话参数；
- 会话管理: 包括转发，结束会话，修改会话参数和调用服务。

SIP 不是一个单一，垂直集成度通信系统。SIP 是一个模块，它可以用来和其他的 IETF 协议集成来构建一个完整的媒体架构。 典型的架构如 ， 和实时传输协议（RTP(RFC1889[28])）配合使用实现实时数据传输，提供 QoS 反馈，使用实时媒体协议（RTSP(RFC2326[29])）来控制媒体流和媒体的发送控制，媒体网关控制协议(MEGACO)(RFC3015[30]) 来控制网关对 PSTN 网络的支持，和会话描述协议(SDP) (RFC2327 [1])来描述媒体会话。因此，SIP 应该结合其他的协议一起使用对用户提供完整的服务。但是，基本的 SIP 功能和操作不会依赖于其他任何协议。

SIP 本身不提供服务。但是，SIP 提供基本的操作，这些操作可以支持部署不同的服务。例如，SIP 可以定位一个用户，并且对当前定位发送一个不透明的对象。如果此基本操作用来支持发送一个写入 SDP 的会话描述，终端可以同意会话中的参数。如果同样的操作用来传递一张呼叫方的图片和此会话描述，那么就可以在早期部署一个 "caller ID" 服务。就像这个例子所展示的，一个单个基本操作往往被用来提供不同的服务。

SIP 不提供会议控制服务，例如发言权控制和发言，它不能对会议发出命令控制以及如何管理会议。SIP 可以用来发起一个会话，这个会话可以用来支持一些会议控制协议。因为 SIP 创建的消息和会话可以传递到完全不同的网络中，SIP 不能也不会提供任何网络资源预设的支持能力。

SIP 所提供的服务的本质使得安全性特别重要。对于对端来说，SIP 提供了一个安全服务单元，这些服务单元包括拒绝攻击防止服务，认证（包括用户对用户，代理对用户），集成保护，加密和私有服务。SIP 可以支持 IPv4 和 IPv6 两种网络环境。

## 3 Terminology

本文档中的关键词“必须”、“不得”、“必需”、“应”、“不应”、“建议”、“不建议”、“可”和“可选”在所有大写字母出现时（如图所示）应按照 BCP 14[RFC2119] [RFC8174] 所述进行解释，并且说明了遵从 SIP 部署要求级别和严格程度。读者需要根据关键词的字面意思来区分这些规则的基本和宽泛程度，尽可能最大程度对应 SIP 协议的要求。很多时候，由于开发人员，特别是对英文协议了解不够，或者对协议的理解不同，所以导致一些兼容性问题或者功能不一致等问题。

## 4 Overview of Operation

此部分使用一个简单示例介绍了 SIP 的基本操作。它实际上是一个学习指导，没有包含任何正式的说明。

第一个示例显示了 SIP 的基本功能：终端定位，希望通信的意愿，创建会话参数的协商和创建会话后会话拆线。

图表 1 显示了一个典型的介于两个用户之间的 SIP 消息交互，两个用户分别是 Alice 和 Bob。(每个消息都通过一个带字母 F 的标签来标注，文本号码说明一个标注号码)。在这个例子中，Alice 使用了一个在 PC 上运行的 SIP 应用程序（作为一个软电话）来呼叫 Bob，Bob 的电话是一个基于互联网的 SIP 电话。这个图例也同时显示了，这里有两个 SIP 代理服务器介于 Alice 和 BoB 之间来支持会话管理工作。在图例 1 中，这种典型的设置方式我们通常称之为 "SIP trapezoid"(SIP 拓扑图)。

Alice 使用自己的 SIP 身份 "呼叫" Bob，这种 SIP 身份是一种 URL 类型，我们这里称之为 SIP URL。SIP URLs 在第 19.1 章节中做了定义。它的格式和邮件的格式非常相 似 ， 一般都包括一个用户名称和主机名称 。 在这个例子中 ， 它就是 `sip:bob@biloxi.com`, 这里 `biloxi.com` 是一个 Bob 的 SIP 服务提供商。Alice 可能也具有和 Bob 的 URL 同样的类型，或点击一个超链接后进入一个地址薄。SIP 同样也提供一个安全的URL ， 被称之为 SIPS URL 。 安全 URL 的示例为 `sips:bob@biloxi.com`。通过 SIPS URL 发起的呼叫可以保证安全，加密的传输，它用来传输所有从呼叫方到被呼叫方域的所有 SIP 消息。 从这里，开始，SIP 的请求消息安全地发送到被呼叫方，但是安全机制依赖于被呼叫方域的安全策略设置。

SIP 是基于一种类似于 HTTP 形式的请求/响应事务处理模式。每个事务处理包括一个启动了特别 method 的请求，或者一个功能，和至少一个来自于服务器端的响应构成。在这个例子中，事务处理是以 Alice 的软电话开始，软电话发送一个 INVITE 请求，携带了 Bob SIP URL 地址。这里，INVITE 就是一个 SIP method ，它指定了一个执行命令，请求方（Alice）想让服务器方（Bob）接收这个请求。这个 INVITE 请求中包含了几个 header fields 字段。Header fields 被命名为属性值，这些属性值提供了关于消息的其他额外信息。在 INVITE 中的某些属性表示了呼叫的唯一身份，目的地地址，Alice 的地址，和 Alice 和 Bob 之间创建会话所期望的会话类型的信息。INVITE (F1 消息中) 可能类似于这样的流程：

```
                 atlanta.com  . . . biloxi.com
             .      proxy              proxy     .
           .                                       .
   Alice's  . . . . . . . . . . . . . . . . . . . .  Bob's
  softphone                                        SIP Phone
     |                |                |                |
     |    INVITE F1   |                |                |
     |--------------->|    INVITE F2   |                |
     |  100 Trying F3 |--------------->|    INVITE F4   |
     |<---------------|  100 Trying F5 |--------------->|
     |                |<-------------- | 180 Ringing F6 |
     |                | 180 Ringing F7 |<---------------|
     | 180 Ringing F8 |<---------------|     200 OK F9  |
     |<---------------|    200 OK F10  |<---------------|
     |    200 OK F11  |<---------------|                |
     |<---------------|                |                |
     |                       ACK F12                    |
     |------------------------------------------------->|
     |                   Media Session                  |
     |<================================================>|
     |                       BYE F13                    |
     |<-------------------------------------------------|
     |                     200 OK F14                   |
     |------------------------------------------------->|
     |                                                  |

     Figure 1: SIP session setup example with SIP trapezoid

```

```
INVITE sip:bob@biloxi.com SIP/2.0
Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bK776asdhds
Max-Forwards: 70
To: Bob <sip:bob@biloxi.com>
From: Alice <sip:alice@atlanta.com>;tag=1928301774
Call-ID: a84b4c76e66710@pc33.atlanta.com
CSeq: 314159 INVITE
Contact: <sip:alice@pc33.atlanta.com>
Content-Type: application/sdp
Content-Length: 142

(Alice's SDP not shown)

```

文本消息的第一行包含了一个方法名称 method（INVITE）。 紧接着的是几行包含一个 header 值域的列表。在这个示例中，它们包含了最少的要求设置。这些头header 简单描述如下：

- Via 包含了一个地址(pc33.atlanta.com)，Alice 希望对这个请求获得响应的地址。它也包含了一个 branch 参数来确认这个事务处理。
- To 包含了一个显示名称(Bob)和一个 SIP 或者 SIPS URL（sip:bob@biloxi.com）。Display names 在 RFC2822 [3]有介绍。
- From 也包含一个显示名称 （ Alice ） 和一个 SIP 或 SIPS URI(sip:alice@atlanta.com)，它表示这个请求的发起方。这个 header 同时还有一个一个标签 tag 参数，此标签包含了一个任意字符串（1928301774），这个字符串被添加到了软电话的 URL。此标签也是为了确认身份的目的。
- Call-ID 包含一个对这个呼叫的全局唯一确认信息，它是由一个任意字符串和软电话主机名称或 IP 地址组合而成。To tag 的组合，From tag 的组合，和 Call-ID 完整定义了一个 Alice 和 BoB 两者之间的点对点的 SIP 关系，这种关系可以看作一个dialog 对话。
- CSeq 或 Command Sequence 包含一个整数和一个 method 名称。这个 CSeq 是一个增长的数值，它是支持每一个在 dialog 里新的请求，并且是一个普通的序列号码。
- Contact 包含一个 SIP 或者 SIPS URI，它用来表示一个直接的路由去联系 Alice，通常情况下，它由一个用户名称以及它所在的全限定域名构成（FQDN）。如果使用了全限定域名（FQDN）的话，许多终端系统没有已注册的域名，因此，这里 IP 地址是允许的。Via 头告诉其他参数往哪里发送响应消息，Contact 告诉其他参数往哪里发送将来的请求消息。
- Max-Forwards 最大前转来限定一个请求到达目的地的最大跳跃（hop）数量。它是由一个整数数值构成，在经过一个跳转时会降低一个数值。
- Content-Type 包含一个信息体的描述，这里忽略。
- Content-Length 包含计算消息体长度的八位位组（字节）。

完整的 SIP 头字段集在 20 章节中有详细的定义。

会话的细节，例如媒体类型，编码，采样率等没有在 SIP 中进行描述。 这些细节而是包含在了 SIP 消息体中，它们通过编码以后以各种协议的格式出现。其中一种协议格式就是 会话描述协议 -- Session Description Protocol (SDP) (RFC2327 [1])。这个SDP 消息（没有在这里显示）示例是通过 SIP 消息来传输，传输的方式类似于电子邮件中的附件方式来传输，或类似于通过 HTTP 消息传输网页页面内容的方式。

因为软电话不知道 Bob 的地址或 biloxi.com 域名中的 SIP 服务器地址，软电话发送一个 INVITE 到 SIP 服务器端，这个 SIP 服务器支持 Alice 的域，atlanta.com。atlanta.com SIP 服务器已经配置了 Alice 的软电话，或者通过 DHCP 发现了软电话地址信息。

这个 atlanta.com SIP 服务器是一个代理服务器。代理服务器接收请求，然后作为一个请求者转发这些请求。在这个实例中，代理服务器接收到了 INVITE 请求，然后发送了一个 100 (Trying) 响应给 Alice 的软电话。这个 100 (Trying) 响应表示这个INVITE 已经被收到，代理正在通过路由设置路由这个 INVITE 到其目的地。在 SIP 中，响应消息使用一个三位数的响应码和描述短语作为回复消息。这个响应消息在 Via 中包括同样的 To，From，Call-ID，CSeq 和 branch 参数 parameter，这些参数和 INVITE 中的一样，这些参数允许 Alice 的软电话关联响应消息来发送 INVITE 消息。这个 atlanta.com 代理服务器定位到这个代理服务器在 biloxi.com，它可能执行一个特别的 DNS 查询来找到服务 biloxi.com 域的 SIP 服务器。这个部分的描述在[参考链接 4]中。 因此，它获得 biloxi.com 代理服务器的 IP 地址，然后转发或者在这里代理其 INVITE 请求。在转发这个请求之前，这个 atlanta.com 代理服务器添加另外一个 Via 头字段，这个头字段包含自己的地址（这个 INVITE 已经在第一个Via 包含了 Alice 的地址）。biloxi.com 代理服务器收到这个 INVITE 消息后，然后回复一个带 100 (Trying) 响应消息到 atlanta.com 代理服务器，表示它已经收到了这个 INVITE 消息，正在处理这个请求。代理服务器会查询一个定位服务器，我们称之为定位服务，定位服务包含当前 Bob 的 IP 地址。(我们将会在下一个部分看到如何实现数据库查询。)biloxi.com 代理服务器会添加另外一个 Via header ，并且携带自己的 IP 地址，这个地址是针对这个 INVITE 请求的，代理转发这个请求到 Bob 的 SIP 软电话。

Bob 的软电话收到这个 INVITE 消息后，对 Bob 发出提示，告诉他有从 Alice 来的电话呼叫，Bob 决定是否应答这个呼叫，这里 Bob 的软电话会产生振铃提示。Bob 的软电话提示 180 振铃，这个响应消息会路由根据相反的方向回到两个代理服务器。每个代理使用 Via header 域值来决定发送响应的地址方向，并且从顶部路由记录中删除自己的地址。因此，尽管要求 DNS 和定位服务查询 路由这个初始的 INVITE 请求，180（Ringing）响应返回到呼叫方时可以没有查询消息或没有代理服务器中所保持的状态。

这样也获得了一个合理的响应属性，每个看到 INVITE 消息的代理服务器也可以看到所有对 INVITE 的响应消息。

当 Alice 的软电话收到这个 180 (Ringing)响应后，它会传递这个信息给 Alice，传递过来的信息方式可以使用一个回铃音（ringback tone）或者在 Alice 终端屏幕显示一个消息。

在这个示例中，Bob 决定应答这个呼叫。当他拿起电话听筒时，他的 SIP 电话会发送一个 200 (OK) 响应消息来表示这个呼叫已经应答。这个 200 (OK) 包含了一个消息体，这个消息体带了这个呼叫会话的媒体描述类型，这个媒体描述中说明了 Bob 希望和 Alice 创建会话。因此，这里有一个两阶段的 SDP 消息交互过程：Alice 发送一个交互消息给 Bob，Bob 然后发送了一个交互消息给 Alice。 这个两阶段的交互提供基本的协商能力，它是基于一个简单的 offer/answer SDP 交互模式来进行的。 如果 Bob 不希望应答这个呼叫或者 Bob 电话可能被占线，他此时和其他人进行通话，那么 Bob 终端则会发送一个错误响应消息而不是 200 (OK)，这样就会导致没有媒体创建的情况。 完整的 SIP 响应码在 第 21 节中列出。Bob 发送的 200 (OK) (图例 1 中的消息 F9)可能类似于这样：

```
SIP/2.0 200 OK
Via: SIP/2.0/UDP server10.biloxi.com;branch=z9hG4bKnashds8;received=192.0.2.3
Via: SIP/2.0/UDP bigbox3.site3.atlanta.com;branch=z9hG4bK77ef4c2312983.1;received=192.0.2.2
Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bK776asdhds ;received=192.0.2.1
To: Bob <sip:bob@biloxi.com>;tag=a6c85cf
From: Alice <sip:alice@atlanta.com>;tag=1928301774
Call-ID: a84b4c76e66710@pc33.atlanta.com
CSeq: 314159 INVITE
Contact: <sip:bob@192.0.2.4>
Content-Type: application/sdp
Content-Length: 131

(Bob's SDP not shown)
```

响应消息的第一行包含了响应码(200)和响应原因短语(OK)。其余其他行消息包含 header 值域消息。Via，To， From， Call-ID，和 CSeq header 值域都是从 INVITE 请求中拷贝过来的。(注意，这里有三个 Via 头值，一个是 Alice 软电话添加的，另外一个是 atlanta.com 代理服务器添加到，还有一个是 biloxi.com 代理添加的)。Bob 的软电话已经在 header 中添加了一个 taq 标签参数 To。这个标签将会在两个终端的 dialog 中使用，也将会在此呼叫后续的请求和响应使用。

Contact 头包含了一个 URL 地址，这个 URL 就是 Bob 可以直接访问的软电话地址。 Content-Type 和 Content-Length 参考消息体（这里没有列出），这个消息包含了 Bob SDP 媒体的信息。

另外，在这个示例中，DNS 和定位查询显示代理服务器可以做一个灵活的路由决定，它可以决定往哪里发送请求。例如，如果 Bob 软电话返回一个 486 (Busy，忙状态)响应的话，biloxi.com 代理服务器可以代理这个 INVITE 到 Bob 的语音邮箱服务器。代理服务器也可以同时发送一个 INVITE 到多个地址。这种类型的并行查询方式称之为 forking（分叉复制）处理方式。

在这个示例中，200 (OK) 消息通过两个代理服务器返回到 Alice，Alice 软电话收到响应消息，软电话停止回铃音，表示呼叫已应答。最后，Alice 软电话发送一个确认消息 ACK，这个消息发送到 Bob 软电话来确认最终响应 (200 (OK))已收到。在这个示例中，这个 ACK 是通过 Alice 软电话直接被发送到了 Bob 软电话，发送过程绕开了两个代理服务器。这样处理的原因就是因为两个终端已经通过互相学习知道对方的地址，双方地址是通过 INVITE/200（OK）交互时的 Contact 头获得，当然这个地址在初始时的 INVITE 是双方都不知道的。两个代理服务器的查询服务也不需要，因此，代理服务器则会退出这个呼叫流程。这个处理过程成功实现了 INVITE/200/ACK 三方握手，并且创建了 SIP 会话。完整的关于 SIP 会话创建的细节，请参考第 13 章节。

Alice 和 Bob 之间的媒体会话启动，他们之间的软电话开始发送媒体数据包，媒体数据包的格式是他们之间的 SDP 交互互相同意支持的格式。一般来说，端对端的媒体数据通过不同的路径发送，而不是使用 SIP 信令消息的路径。

在这个会话过程中，Alice 或 Bob 任何一方都可以有权决定修改媒体会话的属性。修改会话属性是通过发送一个 re-INVITE 消息，在此消息中包含一个新的媒体描述来实现。这个 re-INVITE 涉及到了已存在的 dialog,因此其他的参与方知道这个消息是修改了现在的会话，而不是重新建立的新会话。其他方发送一个 200（ok）接受这个修改。请求方对 200（ok）发送一个 ACK。如果其他方不能接受这个修改的话，它会发生一个错误响应，例如 488 (Not Acceptable Here)，同样也接收一个 ACK 确认消息。但是，这个 re-INVITE 失败不会导致目前的呼叫失败-这个会话仍然会继续使用以前协商的属性。完整的话会修改细节，请阅读第 14 章节内容。

在呼叫结束后，Bob 首先挂机(hangs up)，并且生成一个 BYE 消息。这个 BYE 会直接路由返回到 Alice 的软电话，这里仍然绕过了代理。 Alice 确认了 BYE 接收，发送一个 200（ok），结束这个会话和 BYE 消息事务。这里没有 ACK 发送，ACK 发送仅发生在对 INVITE 请求的响应中。对于对 INVITE 特别处理的原因会在后续的章节中讨论，这里涉及了 SIP 中的可靠性机制问题，振铃应答的时间程度和分叉处理等因素。因为这个原因，SIP 中的请求处理经常被划分为 INVITE 或者 non-INVITE 两个层面，除了 INVITE method 以外，还涉及其他的所有 methods 。完整的关于会话结束的详情将在第 15 章节进行讨论。

第 24.2 章节描述了在 Figure1 的完整的消息构成。

在某些用例中，对于代理来说可能非常有用，在整个会话期间可以看到两个终端之间在 SIP 信令路径上的所有消息。例如，如果 biloxi.com 代理服务器希望保持除了初始 INVITE 以外的 SIP 消息，它对 INVITE 添加一个要求的路由 header 值，这个值我们称之为 Record-Route，用来解析主机或者代理的 IP 地址。因为 Bob 软电话（这个消息会通过 200（OK）传送回 Bob）和 Alice 软电话将会收到这个消息，在整个 dialog 过程中保存这个消息。biloxi.com 代理服务器将收到和对 BYE 代理转发这个 ACK，BYE 和 200（OK）。每个代理可以独立决定收到的后续的消息，消息将被通过所有选择接收的代理发送，这些代理来接收这个消息。这个能力经常被代理使用，代理通过这个能力可以提供 mid-call 功能或者呼叫期间的控制功能。

注册是另外一个 SIP 常用的操作。注册是一种方法，它可以使得 biloxi.com 服务器获知当前 Bob 的位置。Bob 软电话基于初始化处理，在一定周期内 Bob 软电话对在 biloxi.com 的服务器发送 REGISTER 消息，我们称之为 SIP registrar 或者 SIP 注册。REGISTER 消息关联 Bob 的 SIP 软电话或者 SIPS URI (sip:bob@biloxi.com)，这个机器是当前 Bob 写入记录的地址（它在 Contact 头中传输 SIP 或者 SIPURL）。 这个注册会写入此关联，也被称之为在数据库中的绑定或者定位服务，此定位服务可以使用在 biloxi.com 域的代理中。经常，对于一个域的注册服务器需要和这个域的代理协同工作。这里一定要注意，区分不同类型的 SIP 服务器功能概念是非常重要的，它们区别是在于逻辑处理的不同，而不是物理上，形体上的不同。

Bob 不仅仅局限于从一台设备注册。例如，Bob 的两个终端设备，一台在家里面，另外一台在办公室都发送注册消息。两台设备的消息都保存在定位服务中，允许代理执行各种对 Bob 终端的定位查询。

同样的道理，同一时间，多个用户可以注册到一台单个设备上。

定位服务仅是一个抽象概念。通常情况下，它包括一些必要的信息，它支持代理输入一个 URL，并且接收零个或多个 URL，这些 URL 告诉代理往什么地址发送请求。注册是一种方式来创建这些信息，但也不仅仅是这一种方式。任意映射功能可以通过管理员自行决定。

最后，一定要注意，在 SIP 中注册是用来路由入局的 SIP 请求的，它不能充当出局的授权请求的角色。在 SIP 中，鉴权和身份认证的处理可以基于逐一请求的方式，使用 challenge/response 机制的方式来处理，或使用更低一层的方案来处理，这种方案的讨论在第 26 章节有所描述。

完整的关于 SIP 注册的消息细节示例在第 24.1 章节讨论。

其他的 SIP 操作 ， 例如查询 SIP 服务器的能力或终端使用 OPTIONS ， 或使用 CANCEL 取消正在进行的请求等流程将会在后续章节进行讨论。

## 5 Structure of the Protocol

SIP 是按照一定的层级结构创建的协议，这表示它的行为是根据一系列各自相对独立的处理流程来实现，每个处理阶段之间是松耦合关系。协议行为描述为多个层级，这样是为了支持呈现的目的，支持标准的函数描述，这些描述涉及了单一环境的多个网元。 它不能通过任何方式来决定部署。当我们说一个网元要 “包含” 一个层级时，我们的意思是它符合一系列在这个层级所定义的规范规则。

不是每个通过协议设定的网元都包含在每个层级。进一步说，在 SIP 协议中设定的网元是逻辑网元，不是物理形态的网元。一种物理实现可以选择不同的逻辑网元来执行，也许可以基于依次事务对事务的处理方式进行。

SIP 结构的最低层是语法和解码层 。 解码是通过增强的 Backus-Naur Formgrammar (BNF) 语法来实现的。完整的 BNF 在第 25 章节有介绍。整个 SIP 消息结构的总览在第 7 章节介绍。

第二层是传输层。它定义了用户如何发送请求，如何接收响应和服务器如何通过网络接收请求和发送响应。所有 SIP 网元都包含一个传输层。传输层是在第 18 章节进行描述。

第三层是事务层。事务是 SIP 的基础核心模块。事务是一个由用户端事务对服务器端事务发送的请求，用户端使用传输层对服务器端发送事务请求，所有的服务器端事务所携带响应消息返回到客户端。事务层处理应用层的重传，对请求响应的匹配和应用层超时管理。 任何由用户代理（UAC）完成的任务通过使用一系列的事务来触发。

具体的关于事务的讨论在第 17 章有讨论。 用户代理包含了一个事务层，就像是一个状态代理。 无状态代理没有包含事务层。事务层有一个用户端模块（称之为用户事务）和一个服务器端事务模块（称之为服务器端模块），每个模块通过各自的有限状态机来呈现，状态机来处理每个特别的请求。

在事务层上面的是事务用户（TU）。每个 SIP 实体，除了无状态代理都是一个事务用户。当一个 TU 希望发送一个请求时，它会创建一个用户事务实例，然后把这个实例传递给这个请求，并且携带目的地 IP 地址，端口和传输请求。一个创建了用户事务的 TU 也可以取消这个用户事务。当用户取消了一个事务时，它会请求服务器停止进一步的处理，变换到退出的状态，这个状态是这个事务初始化前的退出状态，并且生成对这个事务生成错误响应消息。 这个处理过程是通过一个 CANCEL 请求来处理，它构成了属于自己的事务，但是仅针对这个被取消的事务（第 9 章）。

SIP 网元也就是用户代理客户端，服务器，无状态代理，有状态代理和注册。SIP 网元包含了一个核心模块，这个核心模块来对各自其网元进行区别处理。在核心网元模块中，除了无状态代理以外，其他的网元都是事务用户。这里，UAC 和 UAS 的核心处理流程由来于 method。关于 methods 支持了多种规则和定义（第 8 章）。对于 UAC 来说，这些规则控制请求的结构；对于 UAS 来说，这些规则控制请求的流程和生成响应消息。因为注册在 SIP 协议中扮演着一个非常重要的角色，一个处理注册的 UAS 会设定一个特别的名称注册。在第 10 章中描述了 UAC 和 UAS 核心的对 REGISTER method 的处理方式。第 11 章描述了 UAC 和 UAS 核心对 OPTIONS method 的处理方式，它决定 UA 的支持能力。

某些其他的请求是在 dialog 中发送。一个 dialog 是一个介于用户代理之间的 peer-to-peer SIP 关系，这种关系存在于一定时间内。 这个 dialog 支持介于用户代理之间的消息的顺序传递和正确的请求路由。在这个细节规定中，INVITE method 是唯一的方法来创建 dialog。当一个 UAC 在 dialog 中发送一个请求时，它会遵守一般的 UAC 规则，这些规则在会第 8 章加以讨论，它也会遵守 mid-dialog 请求时的规则。第 12 章讨论在 dialog 和表述它们的结构和维护流程。

在 SIP 协议中，最重要的 method 是 INVITE method，它用来创建参与方之间的会话。一个会话是参与方的汇集和它们之间通信的的媒体流交互。第 13 章讨论了如何实现会话发起，这些导致了一个或者多个 SIP dialog 生成。 第 14 章讨论了如何在一个 dialog 中通过 INVITE 用法来修改会话属性。最后，在第 15 章中讨论如何结束一个会话。

章节 8，10，11，12，13，14, 和 15 完整讨论了 UA core(第 9 章描述了取消流程，这个取消流程支持都支持 UA core 和 proxy core)。 第 16 章讨论代理的网元，这些网元支持了介于两个用户代理之间的信息路由。

## 6 Definitions

以下定义对 SIP 协议非常重要。

- **Address-of-Record**: 一个 address-of-record (AOR) 是一个 SIP 或者 SIPS URI 地址， 它指到了一个域，同时它支持定位服务。定位服务可以映射这个 URL 到其他的 URL，其他的 URL 可能绑定了用户的有效性和可用性。典型的示例是,定位服务通过注册来实现。AOR 经常被认为是一个用户的“公开地址”。
- **Back-to-Back User Agent**: 背靠背用户代理（B2BUA）是一个逻辑实体，它作为一个 UAS 来接收一个请求，处理这个请求。为了决定如何应答这个请求，它的工作方式又类似于一个 user agent client (UAC) 来生成请求。 不像代理服务器，它会保持 dialog 状态，并且必须介入到整个它所创建的 dialogs 中发送的所有请求。因为它自己本身就是一个 UAC 和 UAS 的结合体，本身并不需要特别明确的定义来定义它的行为。
- **Call**: 呼叫是一个非正式的名称，它指的是介于终端之间的通信，通常情况下创建呼叫的目的是为了多媒体的沟通。
- **Call Leg**: dialog 另外的名称[参考链接 31]；已不在此规定中使用。
- **Call Stateful**: 一个代理是有状态呼叫，它具有这样的特征。如果它保持 dialog 整个状态，这个状态一直持续从初始化 INVITE 开始到 BYE 请求结束。 一个 call stateful 代理总是一个事务状态，但是事务状态不一定是一个有状态呼叫代理。
- **Client**: 终端用户是任何一个网络的网元，它发送 SIP 请求和接收 SIP 响应。用户端可能，或不可能直接和真人用户进行互动。用户代理终端和代理是终端。
- **Conference**: 一个多媒体会话，它包含了多个参与方。
- **Core**: Core 指定了某些功能，这些功能专门针对某些 SIP 实体的参与方类型。例如，具体指定了是一个状态或者非状态代理，用户代理或者注册。除了某些非状态代理以外，所有的 core 功能都是事务用户。
- **Dialog**: dialog 是一种端对端的 SIP 关系，它介于两个 UA 之间，这两个 UA 在一定时间内维持着某种绑定关系。一个 dialog 的创建是通过 SIP 消息，例如对 INVITE请求的 2xx 响应。一个 Dialog 是通过 一 个 call identifier，local tag，和一个 remote tag 来定义的。 Dialog 以前称之为一个 call leg，call leg 在 RFC2543 定义。
- **Downstream**: 在事务内的一个消息前转的，它涉及到了一个请求流程，这个请求流程是从用户代理客户端到用户代理服务器端的处理方向。
- **Final Response**: 是一个响应消息，它结束 SIP 事务，相反的，一个 provisional response 则不会结束事务。所有 All 2xx，3xx，4xx，5xx 和 6xx responses 都是最终响应消息。
- **Header**: 头是 SIP 消息的组件，它传递消息的信息。它由一系列的头字段值构成。
- **Header Field**: 头是 SIP 消息的组件。一个头字段或者头字段可以表现为一个或多个头字段值。每一行头字段值包含头字段值名称和一个或者多个头字段值。如果有多个头字段值的话，可以通过逗号分开。一些头字段值仅有单行头字段，它总是以单行头字段出现。
- **Header Field Value**: 一个头字段或者字段是一个单个数值；它由零个或多个头字段值构成。
- **Home Domain**: 主机域对 SIP 用户提供服务。典型的解释是，这是一个域名，它出现在注册 AOR 的 URL 中。
- **Informational Response**: 类似于一个临时响应。
- **Initiator, Calling Party, Caller**: 一方发起一个会话（dialog） ，它带着一个 INVITE 请求。 一个呼叫方始终保持一个角色，这个角色从它开始发送这个初始的INVITE 开始计算，这个 INVITE 创建了一个 dialog，一直到结束这个 dialog。
- **Invitation**: 一个 INVITE 请求。
- **Invitee, Invited User, Called Party, Callee**: 一方接收一个 INVITE 请求，这个请求的目的是为了创建一个新的会话。被呼叫方始终保持这个角色，这个角色从它开始接收这个 INVITE 开始计算，一直到 dialog 结束，这个 dialog 是由那个 INVITE 创建。
- **Location Service**: 定位服务用来支持一个 SIP 重定位或代理服务器来获得关于被呼叫方可能存在的地址信息。它包含一个绑定的 address-of-record 列表数值，这些从从零个到多个 contact 地址。这个绑定关系可以通过多种方式来创建或者删除；此协议细节中定义了一个 REGISTER method 来更新绑定关系。
- **Loop**: 一个已到达代理的请求，经过前转以后，后来又返回到同样的代理。当这个请求第二次到达代理时，这个请求的 Request-URI 确认是第一次的请求，并且其他影响代理操作的头字段值不会改变，因此代理会在这个请求中做出和第一次同样的处理决定。回环的请求是一种错误，流程会检侧回环请求，通过协议本身来处理这种回环请求。
- **Loose Routing**: 如果代理遵守本规范来处理路由头字段，代理会被告知是一个松散路由。 这些流程从一系列的代理中分开了目的地请求（出现在 Request-URL 中），代理所遵守的机制被称之为松散路由。
- **Message**: 消息是在 SIP 网元之间发送的数据，它是协议的一部分。SIP 消息可以是请求或者响应消息。
- **Method**: method 是一个基本功能，一个请求在服务器端被激活。Method 在请求自己的消息中传输。常见的 methods 是 INVITE 和 BYE 请求。
- **Outbound Proxy**: 它是一个代理，负责接收从客户端发出的请求，即使它可能不是一个通过 Request-URI 解析度服务器。 通常情况下，一个 UA 可以通过 outbound proxy 手动配置，或通过自动配置协议进行学习。
- **Parallel Search**: 在并行查询中，一个代理会对可能存在的用户位置发送几个请求，这些可能存在的用户位置用来接收请求。而且，并行查询也不是发送一个请求，然后等待收到这个请求的最后响应，然后发送接下来的请求。它不会等到前面的请求响应收到以后再发送下一个请求。
- **Provisional Response**: 它是临时响应，临时响应表示服务器端的处理进程， 但是临时响应不会结束 SIP 事务。1xx 是临时响应，其他的响应是最终响应。
- **Proxy, Proxy Server**: 代理是一个中间实体，它的工作方式既是一个服务器端，又是一个客户端，作为客户端的作用是支持其他客户端发起请求。代理服务器基本功能是扮演路由的角色，它的工作就是确保请求被发送到比较接近目标用户的其他实体。代理也可以执行一些强制的策略（例如，确保用户被允许呼叫）。 代理可以解析请求消息的部分消息内容，如果必要的话，在一个请求消息被前转之前，代理可以重写请求消息的部分参数内容。
- **Recursion**: 递归处理。当用户在响应中的 Contact 头字段中产生一个或多个 URLS 的新请求时，用户会在 3xx 响应中产生递归。
- **Redirect Server**: 重定向服务器是一个用户代理服务器，它会对接收的请求产生 3xx响应，重新定向用户，让用户联系其他可选的 URL 列表中的 URI 地址。
- **Registrar**: 注册服务是一个注册服务器，它用来接受 REGISTER 请求，负责把注册服务器接受的信息保存到定位服务所支持的 domain，这个 domain 是注册服务器负责。
- **Regular Transaction**: 正常事务是任何带 method 的事务，带 INVITE，ACK，或者 CANCEL 的 method 的除外。
- **Request**: 请求是一个由用户端发送到服务器的 SIP 消息，请求的目的是触发一个特别的操作。
- **Response**: 响应是一个由服务器端发送到用户端的 SIP 消息，其目的是说明请求发送后服务器端回复的状态。
- **Ringback**: 回铃是一种信令音（回铃音），它是由呼叫方应用程序生成，用来表示被呼叫方已经被提示（被呼叫方正在振铃状态）。
- **Route Set**: 路由集是一组有序 SIP 或者 SIPS URI 的集合，它用来表示当发送一个特别的请求时所经过的代理列表。 路由集通过路由头，例如 Record-Route 或者经过配置后获得。
- **Server**: 服务器是网络中的一个网元，它用来接收请求，然后对其进行服务支持，并且对其请求返回响应消息。服务器的实例包括代理，用户终端服务器，重定位服务器和注册服务器。
- **Sequential Search**: 在顺序查询中，代理服务器按照顺序尝试查询每个 contact 地址，并且，只有当上一个查询返回最终响应后才进行下一个查询的新的处理。 2xx 或者 6xx 的最终响应总是结束顺序查询处理。
- **Session**: 在 SDP 规范中："一个媒体会话是一系列媒体发送方和媒体接收方，以及从发送方到接收方之间的媒体数据流。一个媒体会议就是一个媒体会话的举例。" (RFC2327 [1]) （对 SDP 定义的会话来说，一个会话由一个或多个 RTP 会话构成）。就像定义中的那样，对于同一会话来说，一个被呼叫方可以被不同的呼叫方多次邀请。如果使用了 SDP，会话通过 SDP 用户名称，会话 ID，网络类型，地址类型和在地址单元中的原始值域构成。
- **SIP Transaction**: 一个 SIP 事务会发生在客户端和服务器端之间，它由第一个由客户端发出的请求开始到服务器端最终响应的所有消息构成（非 1xx 消息）。如果请求是 INVITE，并且最终响应是一个非 2xx 消息的话，这个事务也会对这个响应包括一个 ACK。对于 200 OK（INVITE 的响应）的 ACK 来说，它是一个独立的事务处理。
- **Spiral**: spiral 是一种“螺旋式”处理方式，它是一个 SIP 请求，返回到代理， 然后，代理再把这个请求前转到其他的终端，但是处理的流程不同，也导致和初始的 URL 不同。通常情况下，螺旋式处理方式表示请求中的 Request-URI 和上一次抵达的请求中的 URL 是不同的。注意，螺旋式的处理流程处理不是一个错误条件， 它和 loop （回环完全不同） 。 典型的使用场景是呼叫前转的处理 。 A 用户呼叫 joe@example.com。这里的 example.com 是一个代理，它会前转到用户 Joe 的电脑终端，接下来，joe 会把这个呼叫前转继续前转到 bob@example.com。这里的请求其实又回到了同一代理 example.com。但是，这种处理方式不是 loop 环境。因为这里的请求发生了变化 ， 它触发了不同的呼叫 ，这里的 URL 是 bob@example.com，不是 joe@example.com。所以，它的处理是有效的处理流程，被认为是一种螺旋式的处理。而在 loop 中，它的处理流程和 Request-URI 是保持不变的，代理重复处理同样的流程，因此导致触发错误条件。
- **Stateful Proxy**: 状态代理是一个逻辑实体，它按照规范中请求处理的流程保持用户端和服务器端之间的事务状态机的处理状态，也就是所谓的事务状态代理。状态代理的执行在第 16 章做了进一步的说明。状态代理（事务）和呼叫状态代理是不同的。
- **Stateless Proxy**: 无状态代理是一个逻辑实体，它不会保持用户端和服务器端之间的事务状态机。无状态代理前转从下游收到的每个请求，前转从上游收到的每一个响应。
- **Strict Routing**: 如果代理被称为严格代理表示这个代理遵守 RFC2543 的路由处理规则，和一些比较早的 RFC 版本规范。当 Router 头出现时，那个规范会引起代理破坏Request-URI 的内容。严格路由的流程不在本规范中使用，本规范支持松散路由的处理。 执行严格路由的代理也被称之为严格路由器。
- **Target Refresh Request**: 目标刷新请求是在一个 dialog 中发送，这个请求可以修改 dialog 中的远端目标。
- **Transaction User (TU)**: TU 是处理协议层，它存在于事务层。TU（事务用户）包括 UAC core，UAS core 和 proxy core。
- **Upstream**: 它表示在事务中的转发消息方向，针对的是从用户代理服务器端返回到用户代理客户端的响应流程。
- **URL-encoded**: 一个通过规范 RFC2396, 章节 2.4 [5]解码的字符串。
- **User Agent Client (UAC)**: 用户代理客户端是一个逻辑实体，它创建了一个新的请求，并且使用客户端事务状态机发送请求。UAC 的角色是仅维持那个事务的时长。换句话说，UAC 是一款软件，它发起一个请求，它以 UAC 的方式工作。 如果它后续收到一个请求，它以用户代理服务器的方式来处理事务流程。
- **UAC Core**: 一系列 UAC 的请求处理功能，它在事务层和传输层以上。
- **User Agent Server (UAS)**: 用户代理服务器是一个逻辑实体，它对 SIP 请求生成一个响应。响应接受、拒绝或转发请求。它的角色是仅维持事务时长。换句话说，它是一款软件来响应请求，它以 UAS 的方式工作。如果在后续状态中收到一个请求，它以用户代理客户端的方式来处理事务流程。
- **UAS Core**: 一系列 UAS 的请求处理功能，它在事务层和传输层以上。
- **User Agent (UA)**: UA 是一个逻辑实体，它能以用户代理客户端或者用户代理服务器端的方式工作。UAC 和 UAS 的角色，代理和转发服务器都是基于事务对事务的基础上定义的。例如，用户代理以 UAC 的方式发起一个呼叫时，发送请求时，它的工作方式是 UAC；当从被呼叫方收到一个 BYE 请求时，它的工作方式是 UAS。同样的道理，同样的软件，它可以以代理服务器的方式工作来处理请求，也可以以转发服务器的方式工作来处理下一个请求。代理、定位服务器和注册服务器都是逻辑实体。在部署时，它们可以集成为一个单一的应用服务器。

## 7 SIP Messages

SIP 是基于文本的协议，使用的是 UTF-8 charset (RFC 2279 [7])。一个 SIP 消息可以是从客户端到服务器端的请求消息，也可以是服务器端到客户端的响应消息。虽然它们的语法规范和字符设置不同，请求 (第 7.1 章节)和响应 (第 7.2 章节) 消息都使用 RFC2822[3]的基本格式来处理。(例如，SIP 允许支持头字段，这些字段对 RFC2822 来说是无效的头字段)。两种类型的消息由一个起始行，一个或者多个头，一个表示头结束的空行和一个可选的消息体表示。

```
         generic-message  =  start-line
                             *message-header
                             CRLF
                             [ message-body ]
         start-line       =  Request-Line / Status-Line
```

起始行，每个消息头和空行都必须以换行符结尾。注意，即使没有消息体，空行也要显示。除了上面字符的不同以外，很多 SIP 消息和 SIP 头语法都是遵守 HTTP/1.1 的语法。于其在这里重复语法和语义的定义，这里，我们建议使用 HTTP/1.1 规范的 [HX.Y] 的部分作为参考 (RFC 2616 [8])。

但是，SIP 不是 HTTP 的拓展。

### 7.1 Requests

SIP 请求通过在起始行带一个 Request 行和其他的 method 加以区别。一个请求行包含 method 名称，一个 Request-URI，和由单空格字符分开的协议版本。请求行以换行符 CRLF 结束。可以允许无回车或换行，除了在以换行符结束的序列中。不允许在任何网元中有任意数量的空白格（LWS）存在。

```
    Request-Line  =  Method SP Request-URI SP SIP-Version CRLF
```

- Method: 此规范定义了六个方法: REGISTER 支持注册联系消息，INVITE、ACK、CANCEL 支持会话创建，BYE 支持结束会话，OPTIONS 支持对服务器的能力查询。SIP 拓展中定义了其他的方法。
- Request-URI: Request-URI 是一个 SIP 或 SIP URL 在第 19.1 章节介绍，它或者是一个标准的 URL(RFC2396[5])。它表示这个用户或这个服务被记录。Request-URI 不能包含非转义符空格或控制字符，不能以"<>"方式出现。SIP 网元中可能支持 Request-URIs，不一定是 sip 或者 sips，也可能是其他的 URL schemes 形式，例如 "tel"，这是 RFC2806 [9]的 URL schemes。SIP 网元可以在它们的处理过程中使用任何机制转译非 SIP，最终生成 SIP URI，或者其他的 scheme。
- SIP-Version: 请求和响应都包括在使用的 SIP 版本，并且遵守 [H3.1]（HTTP 替代了 SIP，HTTP/1.1 替代了 SIP/2.0），这里涉及了版本顺序，遵从要求和版本更新数量。 为了遵从此规范，应用程序发送到 SIP 消息必须包括 SIP 版本"SIP/2.0"。 此 SIP 版本字符串是大小写敏感，但是使用时必须发送大写字母。不像 HTTP/1.1，SIP 把此版本号看作为一个一般字面字符串。在实际使用时，这应该没有什么不同。

### 7.2 Responses

SIP 响应消息和请求消息不同，响应消息包含一个 Status-Line 作为一个起始 start-line。在每个网元中，一个 Status-Line 由响应版本，然后跟随一个数字类型的状态码以及其关联的文本短语，通过一个单空格字符分开。除了在最后的 CRLF 顺序中，可以允许无 CR（回车）或者 LF（换行）转义字符。

```
    Status-Line  =  SIP-Version SP Status-Code SP Reason-Phrase CRLF
```

状态码是一个三位整数的结果代码，它表示一个测试输出的响应理解，满足请求的要求。原因短语的目的是对状态码给予一个短语解释。使用状态码的目的是为了系统的自动处理，而原因短语的目的是方便用户阅读理解状态原因，具有可阅读性。用户不要求检查或显示原因短语。

这里，此规范建议使用明确的用词来表示原因短语，部署使用时可使用其他的文本。例如，在请求中的 Accept-Language 头中的语言。

状态码的第一个数字定义了响应的级别。状态码后两位没有层级的设置。因为这个原因，任何状态码介于 100 和 199 之间的响应被看作是 "1xx response"，任何状态码介于 200 和 299 的响应看作是一个 "2xx response" 响应，以此类推。以第一个数字为划分类别，SIP/2.0 支持了六个级别的状态响应码：

- 1xx: Provisional –- 请求收到的响应码，表示是临时响应，会继续处理此请求；
- 2xx: Success –- 成功收到处理流程，理解，接受了处理流程；
- 3xx: Redirection –- 需要进一步的流程处理来完成此请求；
- 4xx: Client Error –- 此请求中包含错误语法或不能满足服务器的要求；
- 5xx: Server Error –- 服务器端不能满足一个明确有效请求；
- 6xx: Global Failure -– 任何服务器都不能满足此请求流程。

第 21 章定义了这些级别和描述了其无效码。

### 7.3 Header Fields

在语法和语义方面，SIP 头和 HTTP 头非常相似。在实际应用环境中，SIP header 遵从 [H4.2] 对消息头的语法和对拓展头的规则。但是，后者通过 HTTP 定义，使用了隐藏的空格。此规范和 RFC 2234[10]是一致的，仅使用了明确的空格，并且看作为语法的一个部分。

[H4.2] 也定义了同一域名称的多个头的语法，这些值都以逗号隔离的列表，这些列表可以合并成一个头值。这个应用方式也可以支持 SIP，但是因为具体的规范有所不同。具体来说，任何 SIP 头都以下语法的形式表现

```
    header  =  "header-name" HCOLON header-value *(COMMA header-value)
```

可以支持合并同一名称的头成为一个逗号隔离的列表。此 Contact header 支持逗号隔离的列表，除非这个头的值是 "*"。

#### 7.3.1 Header Field Format

头字段域遵从标准的头格式标准，在 RFC2822 第 2.2 章节 [3] 定义。每个头由域名，然后冒号(":") 和域值构成。

```
    field-name: field-value
```

消息头顶标准语法在第 25 章定义，然后紧跟一个任意数量的空格。但是，在部署使用时应该避免基于头字段和冒号之间的空格，在值域和冒号之间使用一个单空格。

```
    Subject:            lunch
    Subject      :      lunch
    Subject            :lunch
    Subject: lunch
```

因此，以上格式都是有效的，建议使用最后的格式。

Header 头字段可以扩展为多行，实现方式是通过在每一行前添加至少一个 SP 或 HTtab 键来实现。在下一行开始前的换行符和空格被看作是一个单 SP 字符。因此，以下几种格式表达的意思是相同的：

```
    Subject: I know you're there, pick up the phone and talk to me!
    Subject: I know you're there,
            pick up the phone
            and talk to me!
```

带不同域值的头的相对顺序不是非常重要。但是规范推荐，为了支持代理处理，这些头(例如 Via、Route、Record-Route、Proxy-Require、Max-Forwards、Proxy-Authorization) 应该出现在消息体的顶部来支持代理的快速解析。头的相对顺序和其对应的名称是非常重要的。如果或只有如果那个头的域值定义为以逗号分割的列表时（第 7.3 章），具有同样名称的多个头值可以出现在消息中。它必须可以支持多行头值可能合并为一对 "field-name: field-value" 的形式，而没有改变消息的语义，首先预设每一个接下来的头值，然后以逗号分开。这个规则对 WWW-Authenticate、Authorization、Proxy-Authenticate、Proxy-Authorization 头是一个例外。

带它们名字的多头值域可能出现在消息中，但是，因为它们的语法没有遵从第 7.3 章节的标准格式，它们不允许合并为单头行域值。

使用时必须可以处理同样名称的多头值，无论是每行单值合并的头或是逗号分隔的方式。

以下各组头值是有效，相等的：

```
    Route: <sip:alice@atlanta.com>
    Subject: Lunch
    Route: <sip:bob@biloxi.com>
    Route: <sip:carol@chicago.com>

    Route: <sip:alice@atlanta.com>, <sip:bob@biloxi.com>
    Route: <sip:carol@chicago.com>
    Subject: Lunch

    Subject: Lunch
    Route: <sip:alice@atlanta.com>, <sip:bob@biloxi.com>,
           <sip:carol@chicago.com>
```

每个组的值是有效的，但是又表达各自不同含义：

```
    Route: <sip:alice@atlanta.com>
    Route: <sip:bob@biloxi.com>
    Route: <sip:carol@chicago.com>

    Route: <sip:bob@biloxi.com>
    Route: <sip:alice@atlanta.com>
    Route: <sip:carol@chicago.com>

    Route: <sip:alice@atlanta.com>,<sip:carol@chicago.com>,
           <sip:bob@biloxi.com>
```

头的名称格式是通过每个头名称来定义的。它总是是 UTF8 文本八位字节不确定度顺序出现或空格，标志符，分隔符和带引号的字符出现。许多存在的头会附加到通过标准规范值，通过分号的方式，分隔参数名称，参数值，具体格式为：

```
    field-name: field-value *(;parameter-name=parameter-value)
```

虽然任意数目的参数可以附加到头上，但是，任何已给定的参数名称不能出现第二次。

当对比头值时，头名称总是大小写不敏感的。要不然，这个头是一个指定的头，它已经声明了值域名称，参数名称和参数值是大小写不敏感的头。标记符总是大小写不敏感的字符。除非，这个标记符已经声明其属性，否则，被引号标注的字符值是大小写敏感的值。例如，

```
    Contact: <sip:alice@atlanta.com>;expires=3600
```

等同于

```
    CONTACT: <sip:alice@atlanta.com>;ExPiReS=3600
```

和

```
    Content-Disposition: session;handling=optional
```

等同于

```
    content-disposition: Session;HANDLING=OPTIONAL
```

以下这两组是不相同的：

```
    Warning: 370 devnull "Choose a bigger pipe"
    Warning: 370 devnull "CHOOSE A BIGGER PIPE"
```

#### 7.3.2 Header Field Classification

一些头字段仅在请求或者在响应中有一定的合理性。它们被称之为 request header fields 和 response header fields。如果一个头字段出现在消息体中，没有匹配任何头的层级（例如，请求的头出现在响应的消息体中），它则必须被忽略掉。 第 20 章定义了头字段的各种层级类别。

#### 7.3.3 Compact Form

SIP 提供了一种机制以压缩的形式来表达普通的头。当传输很大的消息体的消息内容时，这种方式也比较有用，例如当使用 UDP 传输时，如果内容数据超过 MTU 极限后，使用压缩的格式就可以满足最大 MTU 支持。压缩格式在第 20 章定义。压缩格式可以在任何时候在没有改变消息语义时替换为比较长的格式。

头字段值可以以比较长的格式或者压缩格式出现在同样的消息体中。在使用时每个头都必须支持比较长的格式和压缩格式。

### 7.4 Bodies

除非另外提示，Requests(请求)可能包括消息体，这种请求包括一个新请求，新请求在本规范的新拓展中定义。消息体解析依赖于请求方式 method。

对响应消息来说，请求方式和响应状态码决定消息体类型和消息解析。所有的响应可能包括在一个消息体。

#### 7.4.1 Message Body Type

消息体的网络媒体类型必须通过 Content-Type 头给定。如果消息体已经处理过编码流程，例如压缩，那么必须通过 Content-Encoding 头声明；否则，必须忽略Content-Encoding。如果可行的话，声明消息体字符串为 Content-Type 头的一个部分。

在 RFC 2046 [11] 定义的 "multipart" MIME 类型可以在消息体中使用。在使用中，如果远端部署方请求通过了一个 Accept 头，这个头没有包含 multipart，那么，发送的请求中包含多方消息体必须发送一个会话描述作为一个非 multipart 消息体 。

SIP 消息可以包含二进制消息体或消息体的部分。当发送方没有提供明确的字符参数设置时，被定义的 text 的媒体子类型有一个默认字符设置值 "UTF-8"。

#### 7.4.2 Message Body Length

以 bytes 为单位的消息体长度是由 Content-Length 头提供。第 20.14 章描述了头内容的具体细节。

HTTP/1.1 中的分块传输编码不能在 SIP 中使用。（注意:为了以一系列的传输来分块数据，分块传输编码修改了消息体，每一个块都有各自的大小指示）

### 7.5 Framing SIP Messages

不像 HTTP，SIP 部署使用了 UDP 或其他的不可信赖的数据包协议。每个数据包传输一个请求或者响应。参考第 18 章介绍了使用非可靠性传输的限定。

通过以数据流方式传输方式来处理 SIP 消息的机制必须在 start-line 之前忽略掉任何回车换行字符 [H4.1]。

> Content-Length header 头的值用来定位数据流中的每个 SIP 消息结束位置。当 SIP 消息是通过数据方式传输时，它总是出现在这里。

## 8 General User Agent Behavior

一个用户代理表示一个最终的系统架构。它包含一个用户代理客户端（UAC）用来产生请求，和一个用户代理服务器端用来对请求产生响应反馈。UAC 用户代理客户端具备产生请求的能力，UAC 产生请求是由外部刺激和驱动的流程而产生（例如，用户点击了一个按钮和 PSTN 线路上的一个信号），并且对响应进行处理。一个 UAS 代理客户端可以接收一个请求，并且基于用户输入，外部驱动刺激，程序执行结果或者其他机制所产生一个响应。

当一个 UAC 发送一个请求时，这个请求会经过几个代理服务器，这些代理服务器将前转这个请求到 UAS。当 UAS 生成响应时，这个响应会返回到 UAC。

UAC 和 UAS 的处理流程完全依赖于两个因素。首先，这个流程取决于这个请求或响应是否在 dialog 里面还是外面，其次，流程还取决于请求的 method。Dialogs 的讨论将会在第 12 章进行；它们表示一种介于用户代理之间的点对点的关系，这个关系是通过具体的 SIP methods 创建的，例如 INVITE。

在本部分内容中，我们讨论 UAC 和 UAS 的执行处理规则，这个规则是完全独立于 method 的，当处理请求时，这些请求是在 dialog 的外面。这里当然也包括请求自己创建的 dialog。

关于 dialog 外部的对请求和响应的安全处理流程的描述在第 26 章进行。 具体来说，介于 UAS 和 UAC 存在的机制是互相验证的过程。通过消息体使用 S/MIME 加密的方式实现一系列私有功能支持。

### 8.1 UAC Behavior

这部分讨论 UAC 的外面 dialog 的运行状态。

#### 8.1.1 Generating the Request

一个有效的被 UAC 规范化的 SIP 请求必须最低包括以下几个头字段：To、From、CSeq、Call-ID、Max-Forwards、Via；对所有 SIP 请求来说，这些头字段是强制支持的。

这六个头字段是构建一个 SIP 消息的基础结构，因为它们联合起来为 SIP 通过了最基本的和最重要的路由服务，消息地址，响应路由，限定消息扩展，消息顺序和事务的唯一身份。

这些头字段另外包含了 method，Request-URI，和 SIP version。运行在 dialog 外面的请求发送示例包括了一个 INVITE，它用来创建一个会话 (第 13章) 和一个 OPTIONS，它用来查询能力支持(第 11 章)。

##### 8.1.1.1 Request-URI

消息的初始 Request-URI 应该在 To 头中设置为 URL 的值。一个需要注意的例外就是 REGISTER method；REGISTER 的 Request-URI 设置方式在第 10 章中讨论。对于安全原因或便利性来说，它可能也不是太方便来设置这些值域为同样的值（特别是，如果在转换期间，初始的 UA 希望 Request-URI 可以被修改的环境中）。

在某些特定的环境中，一个已存在的 route 状态可以影响 Request-URI 的消息。 一个已存在的路由系列是一系列有序 URIs，这些 URLs 确认服务器链，UAC 将会发送出去的请求，这些请求是 dialog 外部的请求。 通常情况下，这些 URL 在 UA 端通过一个用户或服务商手动配置，或者通过其他的非 SIP 机制来配置。当服务商希望配置 UA 支持一个 outbound proxy 时，规范还是推荐需要提供一个已存在的路由系列，设置为一个单 URI 作为一个 outbound proxy。

当出现了一个预先存在的路由表时，如在 12.2.1.1 所描述的中，映射 Request-URL 和 Router 头值的处理流程必须被遵守（即使没有 dialog），使用所期望的 Request-URI 作为远端的目标 URL。

##### 8.1.1.2 To

首先 To 头也是最重要设定了期望的请求逻辑，或者用户的 address-of-record，或者是一个请求目标资源。 这可能是或者不是最终请求接收方。To 头可能包含一个SIP 或者 SIPS URL，但是，如果在其他所要求的场景中，它也可以使用其他的 URL schemes (例如，tel URL (RFC 2806 [9]))。所有的 SIP 部署必须支持此 SIP URI scheme。任何支持 TLS 部署的，必须也支持 SIPS URI scheme。To 头支持一个显示名称。

UAC 可以通过多种方式学习如何对一个特别的请求映射 To 头。通常情况下，用户建议通过人机界面输入 To 头，也许通过人工输入 URL 或从地址薄中选择其地址。 很多情况下，用户没有输入完整的 URL 地址，而是输入一个数字字符串或者字母（例如，“Bob”）。这是 UA 的自定义的输入方式，用户自己解析这个输入结果。 使用字符构建 SIP URL 的用户部分应用在 UA 期望名字可以被解析为一种域名格式，植入到 SIP URL 中的 @ 符号前（例如，sip:bob@example.com）。使用字符构建 SIPS 的用户部分应用在用户希望通信在安全状态，名称可以被域名解析。右侧域名经常是请求者的主机名称，支持主机域处理出局的请求。对于某些功能来说非常有用，例如，“快速拨号功能”。快速拨号功能要求解析主机域名的用户部分内容。tel URL 可以使用在某些环境中，UA 不需要设定域名，只是解析用户已输入的电话号码。更准确地说，每个请求通过的 domain 都会有这样的机会。举例，一个在机场的用户可能登录系统，通过一个 outbound proxy 发送请求。如果他输入号码是 “411” 的话（这个号码是美国当地号码查询系统），这个号码需要解析，然后通过在机场的 outbound proxy 做进一步处理，而不是用户的主机 domain 处理。这种情况下，tel:411 就是一个正确的选择路由。

一个在 dialog 外面的 请求不能包含一个 To tag; 请求中的 To 来确认 dialog 的 peer。因为没有创建 dialog，因此也没有 tag 出现。关于 To 头字段的进一步介绍，请参阅第 20.39 章节。以下是一个有效的 To 头字段的示例：

```
    To: Carol <sip:carol@chicago.com>
```

##### 8.1.1.3 From

From 指示初始请求的逻辑实体，可能是用户 address-of-record 地址。就像 To 头值一样，它包含一个 URL 地址和可选显示名称。 它被 SIP 网元用来决定一个请求所需要的处理规则（例如，自动拒绝呼叫）。这是非常重要的规则处理，在一个正在运行的 UA 中，From 头不能包含 IP 地址和这个主机的 FQDN，因为它们都不是逻辑名称。

From 头支持一个显示名称。除了正确的语法以外，一个 UAC 应该使用这个显示名称 "Anonymous"，如果客户实体是隐藏状态，则是一个无实际意义的 URL（例如，sip:thisis@anonymous.invalid）。

通常情况下，在一个指定 UA 生成的请求中，其 From 头的值是由用户或者用户本地域名管理员预设临时值。如果一个指定的 UA 用来支持多个用户的话，它可能带有一个可切换到属性设置，这个属性设置文件包括一个 URL，这个 URL 和其用户属性实体文件相对应。请求接收方能验证请求的发起方身份，以便确认它们在 From 报头的身份声明（第 22 章规范了更多关于验证的机制设定）。

From 报头必须包含一个由 UAC 选择的新的 “tag” 参数。具体选择细节查看第 19.3 章。

更多关于 From 头字段细节，参考第 20.20 章。

例如：

```
    From: "Bob" <sips:bob@biloxi.com> ;tag=a48s
    From: sip:+12125551212@phone2net.com;tag=887s
    From: Anonymous <sip:c8oqz84zk7z@privacy.org>;tag=hyh8
```

##### 8.1.1.4 Call-ID

Call-ID 头字段的工作方式类似于一个唯一的标识符，它用来成组一系列的消息。在一个 dialog 处理过程中，任何一方 UA 发送的所有请求和响应都必须包含相同的Call-ID。每个 UA 注册中的 Call-ID 应该是相同的。

在一个外部 dialog 由 UAC 创建的请求中，Call-ID 头必须由 UAC 选择，在整个处理和时间段上，它可以作为一个全局的唯一标识，除非其他设定的 methods 处理流程修改它。所有 SIP UA 必须有其含义来确保这个它们生成的 Call-ID 头不会被其他 UA 不经意生成一个新的 Call-ID。 注意，当获取到请求时，对于某些失败响应处理时，这些失败响应针对此请求要求一个重新修正（例如，认证流程），这些获取到的请求不会认为是一个新的请求，因此，它们不需要一个新的 Call-ID。

具体细节规范请参考第 8.1.3.5 章。

规范推荐使用 cryptographically random identifiers (RFC1750 [12]) 来生成 Call-ID。部署格式可以使用此格式 "localid@host"。Call-ID 是大小写敏感的，可以进行一比特一比特的简单对比。

使用 cryptographically random identifiers 提供了对会话的保护，防止被黑客篡改，同时也降低了唯一 Call-ID 的相似度冲突。

对于请求来说，不能通过配置或者界面来提供 Call-ID 头选项选择。

关于更多 Call-ID 头的说明，参考第 20.8 章。

示例：

```
    Call-ID: f81d4fae-7dec-11d0-a765-00a0c91e6bf6@foo.bar.com
```

##### 8.1.1.5 CSeq

CSeq 头的目的是对事务确认和排序。它由一个序列号和一个 method 构成。这个 method 必须匹配请求的 method。对于 dialog 之外的非注册请求，此序列号码是一个任意值。这个序列号码必须是一个可表达的值，此值是一个 32-bit unsigned 整数，并且它必须少于 2^31。只要它遵守以上指南，客户端可以使用任意机制选择 CSeq 头。

第 12.2.1.1 章节讨论了在 dialog 中 CSeq 的构成方式。

例如：

```
    CSeq: 4711 INVITE
```

##### 8.1.1.6 Max-Forwards

Max-Forwards 头支持一个有限的跃点数，此跃点数是一个请求从此路径开始的初始点到传输到最终目的地经过的跃点。它有一个整数构成，每经过一个跃点，跃点数会自动减少一个数字。如果这个 Max-Forwards 值在抵达请求的最终目的地前降低到 0，它将会被拒绝，同时返回一个 483(Too Many Hops) 错误响应。

UAC 必须在每个请求中插入一个 Max-Forwards 头，发起的请求中初始的这个值应该是 70。 这个数值已经足够大，可以保证在一个 SIP 网络环境中没有环路时请求不会被丢弃，但是有时环路发生的时候可能也没有消耗很多的代理资源。用户可以选择比较低的值设置，但是一定要注意，UA 需要了解此网络拓扑环境。

##### 8.1.1.7 Via

Via 头值表示一个传输方式，这个传输方式实际上是响应消息发送到地址，这个地址是针对事务和确认来说的。只有下一跳的传输选择以后，Via 头才能被添加（参考使用流程[参考链接 4]）。

当 UAC 创建一个请求后，它必须在请求中插入一个 Via。协议名称和协议版本必须是 SIP 和 2.0。Via 头必须包含一个 branch 参数。这个参数用来确认被这个请求创建的事务。这个参数支持客户端和服务器端。

无论是从空间和时间角度来看，branch 参数在这个 UA 发送的所有请求中具有唯一性。这个规则对 CANCEL 和 non-2xx 响应的 ACK 是例外。就像我们在下面讨论的一样，CANCEL 请求的 branch 参数和这个请求被取消的参数是一样的。同样，在 17.1.1.3 章节的讨论中，一个对 non-2xx 响应的 ACK 响应也有同样的 branch ID，这个 ID 和 INVITE 响应它的一样。

branch ID 参数的唯一属性帮助它作为事务 ID 来使用，它不是 RFC2543 的一个部分。

branch ID 必须按照规范的格式来处理，它必须以字符 "z9hG4bK" 开头。这七个字符是比较神奇的处理方式（ 7 被认为可以支持足够的资源，以便保证和旧规范 RFC2543 兼容，旧规范没有选择这个数值，所以不会导致冲突），因此，收到这个请求的服务器端可以决定通过这种方式来构建 branch ID。

Via 头的 maddr，ttl，和其他请求将在传输层处理（参考第 18 章）。

对于代理来说，Via 处理方式在 6.6 章节的 Item 8 和 6.7 章节 Item 3 说明。

##### 8.1.1.8 Contact

Contact 头提供一个 SIP 或 SIPS URL，这个 URL 用来联系指定的 UA 示例的后续的请求。这个头必须是现存状态，并且在请求中包含完整的 SIP 或者 SIPS URL，可以支持 dialog 创建。在此规范中定义的 methods，它们仅包括 INVITE 请求。对于这些请求来说，Contact 的范围是全局的。这也表示，Contact 头值包含一个 URL，UA 通过这个 URL 接收请求，并且这个 URL 必须是有效的，甚至可以使用在后续的请求中，这些请求已经不在 dialog 范围内的请求。

如果 Request-URI 或最顶部的 Route 头值中包含了一个 SIPS URL，这个 Contact也必须包含一个 SIPS。

关于更多 Contact 头字段的说明，参考第 20.10 章节。

##### 8.1.1.9 Supported and Require

如果 UAC 支持拓展功能的话，服务器端可以支持对此的响应，UAC 应该在请求中列出一个可选标签 tags 来表示可支持的拓展功能，可选择并且参考（第 19.2 章节）。

列出的可选标签必须来源于在标准规范 RFC 中定义的拓展。这样做的目的是服务器端防止客户端强制使用非标准的，或厂家定义的功能接收服务。在一个请求中，测试类的和信息类的 RFC 拓展明确说明不能使用在 Supported 头中，因此，我们经常看到使用由厂家定义的拓展。

如果 UAC 希望坚持让服务器理解这个拓展功能，UAC 坚持使用这个拓展的话，UAC必须在请求中插入一个 Require 头，这个头在可选标签中列出来表示需要服务器端支持这个拓展。

如果 UAC 希望在代理中坚持使用这个拓展功能的话，并且需要在代理路径理解这个拓展的话，UAC 必须在请求可选标签列表中插入一个 Proxy-Require 头表示需要代理支持的拓展。

就像刚才在 Supported 头使用说明的一样，在 Require 和 Proxy-Require 头中的可选标签所支持的拓展必须来自于标准 RFC 定义的拓展。

##### 8.1.1.10 Additional Message Components

在一个新的请求创建以后，前面提到的那些头字段已经被构建。添加任何额外的可选头字段，需要指定具体的 method。

SIP 请求可以包含一个 MIME 解码的信息体。无论在请求中包含什么样的消息体，某些头字段必须进行规范化处理，进行内容中的字符整合。更多关于这些头字段的说明，参考章节从 20.11 到 20.15。

#### 8.1.2 Sending the Request

请求的目的地是通过计算获得的。除非在发送请求的路径存在一个逻辑策略强制操作，否则请求目的地必须是通过 DNS 处理流程来处理，具体处理描述参考 [4]。如果在 route set 的第一个网元表示是严格路由的话（导致重构请求，具体描述在 12.2.1.1 中讨论），这个处理流程也必须使用在请求的 Request-URI 中。否则，这个流程使用在请求中的第一个 Route 头中（如果存在的话）或如果当前没有 Route 的时候，使用在请求的 Request-URI。这些流程产生了按序的设置组，包括了地址，端口和参数方式。在处理流程中，URL 作为输入数据，他们的处理流程[4]不依赖于 URL 本身，如果 Request-URI 设置了一个 SIPS 的源，UAC 必须遵从处理流程[4]，输入的 URL 是一个 SIPS URI。

本地策略可以设定一系列可选的目的地地址。如果 Request-URI 包含一个 SIPS URI，任何可选目的地地址必须支持 TLS 连接。除此之外，如果请求中没有包含 Route 头的话，对可选目的地没有任何限定设置。对于已存在的 route set 来说，通过这样的方式，它可以提供一个简单可选 方式来设定一个 outbound proxy 代理。但是，不推荐使用那种方式来设置一个 outbound proxy；应该通过一个单 URL 使用一个已存在的 route set 替代设置方式。 如果一个请求中包含一个 Route 头的话，这个请求应该被发送到最顶部的 Route 地址，但是这个请求也可以被发送到任何服务器，只要 UA 认可其身份，其身份设置是通过 Route 和 Request-URI 策略设定的。具体的策略设定在此规范中（相反的规范设置 RFC 2543）。尤其是一个 UAC 配置了 outbound proxy，它应该尝试发送请求到一个地址，这个地址应该是第一个Route 头字段地址 ，而不是调整发送策略， 这个策略发送所有消息到这个 outbound proxy。

> 这样做的目的可以确保 outbound proxies 不添加 Record-Route 头字段值，这些头值将会被丢出后续的请求路径。它允许不能解析第一个 Route URI 的终端对 outbound proxy 代表执行任务。

UAC 应该遵从对 stateful 网元定义的处理流程，这个流程在[参考链接 4]有具体的定义，UAC 应该一直尝试每个地址直到连接到一个服务器地址。 每个尝试连接都构成一个新的事务，并且因此每个携带最顶部 Via 头值的传输都会有一个新的 branch 参数值。进一步说，在 Via 头中的传输值被设置为传输方式设定的值。无论这个值怎么设置，这个值是传输方式针对目的地服务器决定的。

#### 8.1.3 Processing Responses

响应消息首先是通过传输层进行处理，然后在传输到事务层。事务层执行自己的处理流程，然后再传递回 TU 处理。在 TU 中的大部分响应处理流程是和具体的 method 相关的。但是，一些基本的处理方式不依赖于 methods 本身。

##### 8.1.3.1 Transaction Layer Errors

在一些情况下，一些由事务层返回的响应消息不是 SIP 消息，是一个事务层错误。当从事务层收到一个超时错误时，它必须被作为一个 408 错误。如果由传输层报告了一个致命的传输错误（通常情况下，是因为一个 UDP 中的致命 ICMP 错误或 TCP 的连接错误），这种状态必须被视为一个 503 错误代码（服务不可用）。

##### 8.1.3.2 Unrecognized Responses

UAC 必须处理任何无类别等级的最终响应消息，并且 UAC 也必须可以处理任何 x00 类别的响应消息。例如，如果一个 UAC 收到一个无类别响应代码是 431 的响应消息，此 UAC 可安全地认为可能在请求中有什么错误发生。一个 UAC 必须视临时响应消息是不同于 100 响应的，它也不会被视为 183 响应消息。UAC 必须能够处理 100 响应和 183 响应消息。

##### 8.1.3.3 Vias

如果在响应消息中出现了一个以上的 Via 头字段值，此 UAC 应该丢弃这个消息。

> 多个出现的 Via 头字段值是请求发起方置入的值，这些消息是错误设置或者配置文件损害导致。

##### 8.1.3.4 Processing 3xx Responses

对于转发协议的处理上（例如，301 协议状态码），客户端应该基于转发请求，在 Contact 头中使用 URL(s) 重新构建一个或多个新的请求。 这个过程类似于代理对 3xx 类别响应的递归处理，具体的细节参考第 16.5 和第 16.6 章节。客户端启动时携带初始的目标地址列表，其中包含完整的 URL。这是初始请求的 Request-URI。 如果客户端希望基于 3xx 重构新的请求，它会置入这些 URLs 在目标列表中。在此规范中，对象的限制是，一个客户端可以选择哪个 URLs 可以置入到目标组设置。当代理递归发生时，客户端处理 3xx 类别响应时，它一定不能再次添加任何已给定的 URL到目标组中。 如果初始的请求已经在 Request-URL 中有一个 SIPS URL，客户端可以选择递归到一个非-SIPS URI，但是应该通知转发用户，这是一个不安全的 URL。

> 任何新请求可以接收 3xx 响应，这些响应自己包含初始的 URL，这些 URL 作为 contact。可以配置两个地址互相转发。在目标地址组置入一个给定的 URL，其目的是防止无限转发环路发生。

当目的地组设置增加时，客户端可以以任何顺序对 URLs 生成新的请求。一般的机制是在 Contact 头中设置一个 "q" 参数值来表示顺序。对 URL 生成的请求可以是并行方式或连续生成方式。一种方式是通过连续方式处理递减的 q 值组，并且以并行方式处理在每个 q 值组的 URL。另外一种方式是按照递减的 q 值顺序，仅执行连续处理，在相同 q 值的 contacts 之间任意选择一个值。

如果连接在列表中的 contact 失败，继续连接列表中的下一个地址，直到列表地址连接全部失败。如果地址连接全部失败的话，那么这个请求就已经失败。

失败结果应该通过失败响应码来检测（响应码高于 399）；对网络错误来说，客户端事务层将会对事务层用户报告传输层所发生的错误。注意，一些响应码（详情参见8.1.3.5）表示请求可被重新获取；重新发送到请求不应该被认为是失败响应。

当收到针对某个特定 contact 地址的失败时，客户端应该尝试下一个 contact 地址。这样就会导致针对发送的新请求创建一个新客户事务。

为了在 3xx 响应中基于一个 contact 地址创建一个请求，除了 “method-param” 和 “header” URI（参考 19.1.1 章节对参数的定义）以外，UAC 必须从目标组中拷贝所有 URL 到 Request-URI。它使用 “header” 参数为新请求创建 header 头值，覆盖和转发请求中相关的头字段值，具体操作规范参考 19.1.5 章节

注意，在一些例子中，在 contact 地址中，已经构成通信关系的头可以替换追加到已存在的请求的头中，这些请求的头是在初始转发请求中的头。作为一个一般规则，如果头字段可以接受以逗号隔离的域值列表，那么新的头值可以追加到初始转发到请求中。如果头字段不能接受支持追加多个值的话，初始转发请求中的值可以被在contact 地址中已经构成通信关系的头字段值覆盖。例如，如果返回的 contact 地址携带了如下值的话：

```
    sip:user@host?Subject=foo&Call-Info=<http://www.foo.com>
```

那么，在初始转发请求中的 Subject 头可以被覆盖，但是这个 HTTP URL 很少被追加到任何已存在的 Call-Info 头值中。

规范推荐 UAC 重用在初始转发请求中同样的 To，From 和 Call-ID，但是 UAC 例如也可以选择更新 Call-ID 支持新的请求。最后，一旦一个新的请求生成以后，新请求使用一个新客户端事务发送这个请求，因此，它必须在最顶部的 Via 头中生成一个新的 branch ID。关于这一讨论，参考 8.1.1.7 章节。

从其他角度所期望的，转发响应接收方发送到请求应该重用初始请求的头字段和消息体。

在一些例子中，Contact 头字段值可能在 UAC 端被临时或永久缓冲保存，这取决于收到的状态码和内部超时设置状态。查看 21.3.2 和 21.3.3 章节介绍。

##### 8.1.3.5 Processing 4xx Responses

某些 4xx 响应码要求 UA 有特定的处理流程，这取决于 method 本身。

如果收到一个 401 (Unauthorized) 或 407 (Proxy Authentication Required) 响应时，UAC 应该遵从认证部分的处理流程第 22.2 章节和第 22.3 章节重新通过请求获取安全消息。

如果收到一个 413 (Request Entity Too Large) 响应（21.4.11），这个请求包含的消息体大于 UAS 愿意接收的消息体时。如果可能的话，UAC 应该重发这个请求，忽略这个消息体或者重发一个小一点的消息体。

如果收到 415 (Unsupported Media Type) 响应（第 21.4.13 章），这个请求中包含一个 UAS 不支持的媒体类型。UAC 应该重发这个请求，这次仅使用在响应消息中列表支持的 content 类型，这些列出的支持类型在 Accept-Encoding 头中，或者在 Accept-Language 的 languages 列表中。

如果收到一个 416 (Unsupported URI Scheme)响应（第 21.4.14 章），表示服务器端不支持此 Request-URI 使用的 URI scheme。客户端应该重发请求，这次的请求使用 SIP URI。

如果收到一个 420 (Bad Extension) 响应（第 21.4.15 章 ），表示这个请求在 option-tag 标签所支持的功能中包含了一个 Require 或者 Proxy-Require 头值，这个标签所支持的功能是 proxy 或 UAS 不能支持的。UAC 应该重发这个请求，在响应中忽略任何不支持的拓展头字段。

在以上的例子中，请求重发都是通过创建一个新的请求，在新请求中需要做一定的必要的修改才能满足协商机制。这个新请求重构了一个新的事务，并且也应该和前面的请求具有同样的 Call-ID 和 To 头值，但是 CSeq 应该包含一个新的序列号码，这个新的序列号码高于前面的号码。

对于其他的 4xx 响应，还有其他没有被定义的响应，重发请求可能或者也不可能发生，这依赖于使用的 method 和用户使用场景。

### 8.2 UAS Behavior

当 UAS 处理一个处于 dialog 外部的请求（outside of a dialog），规范规定了一系列的处理流程，这些流程独立于 method。第 12 章给出了一个指导，指导说明了 UAS 如何通知请求是一个内部的还是 outside of a dialog。注意，这里的请求处理是非常恒定的。具体来说，如果接受了这样的请求，所有和此请求绑定的状态修改必须执行。如果拒绝了此请求，所有和此请求绑定的状态修改不能执行。UASs 应该根据以下步骤处理请求（开始认证处理，检查 method，头字段和以及本章节其他部分处理）。

#### 8.2.1 Method Inspection

一旦请求完成认证流程（或者跳过认证），UAS 必须检查请求的 method。如果 UAS 已经识别到 method，但是不能支持请求的 method 的话，它必须生成一个 405（Method Not Allowed）响应消息。生成此响应消息的处理流程在第 8.2.6 章节有介绍。UAS 也必须对这个 405 响应消息增加一个 Allow 头。这个 Allow 头必须增加一个列表来表示 UAS 能够支持的 methods 列表。 Allow 头的讨论在第 20.5 章节有讨论。

如果服务器端可以支持其中一个 method，则处理流程继续进行。

#### 8.2.2 Header Inspection

如果 UAS 不能理解请求中的一个头的话（规范中没有定义这个头字段或规范不支持这个拓展头），服务器必须忽略这个头，继续处理消息。如果出现异常的头字段，UAS 应该忽略异常的头字段值，这些头值对于进一步处理请求是没有必要的。

##### 8.2.2.1 To and Request-URI

To 头字段定义请求的初始接收方，这里的请求是由在 From 头字段中定义的用户发起。 因为可能有呼叫前转或其他代理的操作，初始接收方可能是或不是正在处理此请求的 UAS。当这里的 To 头字段不是 UAS 的确认身份时，UAS 可以使用任何策略来决定它是否接受请求。

但是，规范推荐，UAS 接受请求，即使它们不能识别 To 头字段中的 URI scheme（例如，一个 tel:URL）, 或如果 To 头字段不能处理这个 UAS 的已知的或当前用户。如果，在另一方面，UAS 决定拒绝这个请求，UAS 应该生成一个响应消息和其响应状态码 403 (Forbidden)，并且返回这个响应码到服务器事务层的传输。

如果，Request-URI 定义这个 UAS，它来处理这个请求。 如果 Request-URI 使用的一个 scheme 不是这个 UAS 所支持的 scheme，它应该拒绝这个请求，并且返回一个 416 (Unsupported URI Scheme) 响应消息。如果 Request-URI 没有定义一个地址，这个地址是 UAS 愿意为这个请求所接受的地址，它应该拒绝这个请求，并且返回一个 404 (Not Found) 响应消息。 典型环境下 ， 一个 UA 会使用 REGISTER method 绑定它自己的 address-of-record（aor）到一个具体的 contact 地址上，contact 地址可以是多个地址形式。UA 将会看到请求中的 Request-URI 地址和contact 地址相同。接收 Request-URIs 的其他潜在地址源包括请求的 Contact 头和由 UA 发送到响应地址源，这个响应地址源是创建或刷新 dialogs 的地址。

##### 8.2.2.2 Merged Requests

如果请求中的 To 头字段中没有 tag 标签，UAS core 必须对比检查请求的将要处理的事务。如果 From tag、Call-ID、CSeq 完全和将要处理的事务所关联的匹配，但是请求事务的话（匹配规则参见第 17.2.3 章节），UAS core 应该生成一个 482（Loop Detected）响应消息，然后把这个响应传递给这个服务器的事务层。

> 如果同样的请求，这些请求抵达 UAS 多于一次以上的话，这些请求是来自于不同的路径的话，原因可能是进行了分叉 forking 处理。这里的 UAS 处理第一个这样的请求，然后对其他请求返回响应 482（Loop Detected）。

##### 8.2.2.3 Require

假设 UAS 决定处理请求中的符合规则的参数网元，如果 Require 头出现在当前的消息中，它会检查这个 Require 头字段。

Require 头的作用是 UAC 用来通知 UAS 关于 SIP 拓展的消息，UAC 期望 UAS 支持这些 SIP 拓展，UAS 能够正确处理这些请求中的 SIP 拓展。Require 头的格式在第20.32 章节中有进一步的描述。如果 UAS 不能理解 Require 头中列出的 option-tag 列表的话，UAS 必须返回一个生成的响应状态码 420（Bad Extension）。UAS 必须添加一个 Unsupported 头，在这个 Unsupported 头中列出 UAS 不能支持的拓展，这些拓展是请求中的 Require 头所列出的拓展。

注意，Require 和 Proxy-Require 不能使用在 SIP CANCEL 请求中或 ACK 请求，这里的 ACK 请求是发送给 non-2xx 响应消息的。如果这些头值出现在这些请求中时，它们必须要被忽略掉。

一个针对 2xx 响应的 ACK 请求必须仅包含那些出现在初始请求中的 Require 和 Proxy-Require 值。例如：

```
    UAC->UAS:   INVITE sip:watson@bell-telephone.com SIP/2.0
                Require: 100rel

    UAS->UAC:   SIP/2.0 420 Bad Extension
                Unsupported: 100rel
```

> 客户端和服务器端能够互相理解双方所有可选参数值，规范所定义的流程可以确保客户端和服务器端的交互将会快速处理，无任何时延。如果双方参数中，一方不能理解对方的拓展时，处理流程放缓，例如上面的示例。因此，对于客户端和服务器端所支持的拓展都能完全匹配的场景中，交互处理流程会相对较快。如果需要保存一个双向处理，通常需要协商机制来完成。另外，当客户端需要支持的功能，但是服务器端不能理解此拓展功能的话，此头可以移除一些带歧义的拓展功能支持，例如呼叫处理方面的功能，这些功能可能仅是呼叫流程末端系统感兴趣的功能。

#### 8.2.3 Content Processing

假设 UAS 理解所有客户端请求的拓展功能，然后 UAS 检查消息体的内容和头字段。如果其中任何消息的类型（由 Content-Type 表 示），语言（由 Content-Language 表示）或者编码（由 Content-Encoding 表示）不能被支持，并且 body 部分不是一个可选的值（由 Content-Disposition 头表示），UAS 必须拒绝这个请求，返回错误状态响应码 415（Unsupported Media Type） 响应。这个响应必须包含一个 Accept 头的列表，列表表示 UAS 可以理解的消息体类型，在事件中包含UAS 不能理解的消息体类型。如果 UAS 不能理解请求做包含的内容解码，UAS 响应中必须包含一个 UAS 可接受的 Accept-Encoding 头列表，列表中列出 UAS 所支持的解码方式。如果 UAS 不能理解请求的头中列出的支持的内容语言，响应中必须包含一个 Accept-Language 头，这个头列出 UAS 所支持的语言。除了检查以上这些类型以外，消息体处理还依赖于 method 和类型。更多关于具体内容头的处理，参考第 7.4 章节，还有从第 20.11 到 20.15。

#### 8.2.4 Applying Extensions

当生成响应消息时，UAS 不能直接期望使用拓展功能，除非在请求中的 Supported 头中已经表示支持了这个拓展。如果所希望的拓展不能被支持的话，服务器应该仅依赖基本的 SIP 和其他客户端所支持的拓展来处理。在极少情况下，服务器没有拓展的话就不能处理请求，这个服务器可以发送一个 421（ExtensionRequired）响应消息。这个响应消息表示，如果没有具体的拓展功能，服务器端不能生成一个规范的响应。这些服务器端所需要支持的拓展必须包括在响应消息中的 Require 头中。规范不推荐这种操作方式，因为，一般情况下，因为它会破坏流程的兼容性处理。

任何在 non-421 响应中列出的拓展功能必须包含在响应消息的 Require 头列表中。当然，服务器端也不能使用没有在请求的 Supported 头中列出的拓展。因此，响应消息中的 Require 头就会只能包含在标准 RFCs 中多定义的可选标签。

#### 8.2.5 Processing the Request

假设前面讨论的所有子章节都通过的话，UAS 的处理就会进入到和 method 相关的处理流程。 第 10 章节涵盖 REGISTER 请求，第 11 章节涵盖 OPTIONS 请求，第13 涵盖 INVITE 请求，最后，第 15 章节涵盖 BYE 请求。

#### 8.2.6 Generating the Response

当 UAS 希望对请求构建一个响应时，UAS 必须遵守一般的处理流程。这些处理流程会在下面的子章节中进行说明。另外，对于一些非常具体的响应码的处理问题，这里没有规范具体的细节，也可不做要求。

一旦所有和创建响应消息所关联的流程完成以后，UAS 负责返回到服务器事务层，这里是它收到请求的地址。

##### 8.2.6.1 Sending a Provisional Response

对生成响应来说，一个主要的不具体到某个 method 的原则是，UASs 对非 INVITE不应该发送临时响应消息。相反，UASs 应该尽快对非 INVITE 请求生成一个最终响应消息。

当生成 100（Trying）响应时，重新在在请求中的任何 Timestamp 头必须拷贝到这个 100 （Trying）响应中。如果在生成响应时有延迟，UAS 应该在 Timestamp 头中添加一个延迟数值。这个延迟数值必须包含响应发送时间值和接收请求时间值，此值以秒为单位。

##### 8.2.6.2 Headers and Tags

响应消息中的 From 必须和请求中的 From 头相同。响应中的 Call-ID 头必须和请求中的 Call-ID 相同。响应中的 CSeq 必须和请求中的 CSeq 相同。响应中的 Via 头必须和请求中的 Via 头相同，而且保持相同的顺序。

如果在请求中包含了一个 To tag 标签，响应中的 To 必须和请求中的 To 头相同。但是，如果在请求中没有包含 To 头值，在响应中回复中，To 头中的 URL 必须和请求中 To 头的 URL 相同；另外，在响应回复中，UAS 必须在 To 标签中增加一个标签（支持 100（trying）异常响应）。这样处理的目的是确认 UAS 正在响应处理，也可能因为这个异常响应会生成一个 dialog ID 组件。同样的标签使用在此请求的所有响应中，包括最终响应和临时响应（除了 100（trying 以外））。对此标签生成的流程在中第 19.3 章定义。

#### 8.2.7 Stateless UAS Behavior

无状态 UAS 是一种不保存事务状态的 UAS。它通常会转发请求，而且协议发送后会丢弃 UAS 的状态消息。 如果一个无状态 UAS 收到请求重发，此 UAS 会重新生成响应，重新发送响应，就像它对第一个请求回复一样。一个 UAS 不能是无状态模式，除非这个 method 的请求处理总导致同样的响应（如果请求是确认的）。无状态注册不遵守此规则。无状态 UASs 不涉及事务层；UASs 直接收到传输层请求后，直接对传输层返回响应。

无状态 UAS 的基本功能是处理无需验证的请求，这些请求面对响应问题。如果无验证请求是通过有状态 UAS 来处理的话，那么就会导致这些无验证请求产生大量的事务状态，这些事务状态数据会导致在 UAS 侧呼叫处理速度放慢，影响 UAS 处理性能，可能立刻生成了拒绝攻击服务的条件。

更多关于拒绝攻击服务的内容，查阅第 26.1.5 章。

无状态 UAS 的最重要处理方式包括以下几个方面：

- 无状态 UAS 一定不能发送临时响应(1xx)。
- 无状态 UAS 一定不能重回响应消息。
- 无状态 UAS 必须忽略 ACK 请求。
- 无状态 UAS 必须忽略 CANCEL 请求。
- 响应中的 To 头字段值必须以一种无状态的方式生成，这种生成方式对同样的请求生成。
- 同样的标签，此方式的目的是保持标签的一致性。更多关于标签构成，参考第19.3 章。Section 19.3 关于其他方面的处理规范，无状态 UAS 和有状态 UAS 是一样的。对每个新请求来说，UAS 可以以有状态方式或无状态方式操作。

### 8.3 Redirect Servers






## 9 Canceling a Request

### 9.1 Client Behavior

### 9.2 Server Behavior

## 10 Registrations

### 10.1 Overview

### 10.2 Constructing the REGISTER Request

#### 10.2.1 Adding Bindings

##### 10.2.1.1 Setting the Expiration Interval of Contact

##### 10.2.1.2 Preferences among Contact Addresses

#### 10.2.2 Removing Bindings

#### 10.2.3 Fetching Bindings

#### 10.2.4 Refreshing Bindings

#### 10.2.5 Setting the Internal Clock

#### 10.2.6 Discovering a Registrar

#### 10.2.7 Transmitting a Request

#### 10.2.8 Error Responses

### 10.3 Processing REGISTER Requests

## 11 Querying for Capabilities

### 11.1 Construction of OPTIONS Request

### 11.2 Processing of OPTIONS Request

## 12 Dialogs

### 12.1 Creation of a Dialog

#### 12.1.1 UAS behavior

#### 12.1.2 UAC Behavior

### 12.2       Requests within a Dialog

#### 12.2.1 UAC Behavior

##### 12.2.1.1 Generating the Request

##### 12.2.1.2 Processing the Responses

#### 12.2.2 UAS Behavior

### 12.3 Termination of a Dialog

## 13 Initiating a Session

### 13.1 Overview

### 13.2 UAC Processing

#### 13.2.1 Creating the Initial INVITE

#### 13.2.2 Processing INVITE Responses

##### 13.2.2.1 1xx Responses

##### 13.2.2.2 3xx Responses

##### 13.2.2.3 4xx, 5xx and 6xx Responses

##### 13.2.2.4 2xx Responses

###  13.3 UAS Processing

#### 13.3.1 Processing of the INVITE

##### 13.3.1.1 Progress

##### 13.3.1.2 The INVITE is Redirected

##### 13.3.1.3 The INVITE is Rejected

##### 13.3.1.4 The INVITE is Accepted

## 14 Modifying an Existing Session

### 14.1 UAC Behavior

### 14.2 UAS Behavior

## 15 Terminating a Session

### 15.1 Terminating a Session with a BYE Request

#### 15.1.1 UAC Behavior

#### 15.1.2 UAS Behavior

## 16 Proxy Behavior

### 16.1 Overview

### 16.2 Stateful Proxy

### 16.3 Request Validation

### 16.4 Route Information Preprocessing

### 16.5 Determining Request Targets

### 16.6 Request Forwarding

### 16.7 Response Processing

### 16.8 Processing Timer C

### 16.9 Handling Transport Errors

### 16.10 CANCEL Processing

### 16.11 Stateless Proxy

### 16.12 Summary of Proxy Route Processing

#### 16.12.1 Examples

##### 16.12.1.1 Basic SIP Trapezoid

##### 16.12.1.2 Traversing a Strict-Routing Proxy

##### 16.12.1.3 Rewriting Record-Route Header Field Values

## 17 Transactions

### 17.1 Client Transaction

#### 17.1.1 INVITE Client Transaction

##### 17.1.1.1 Overview of INVITE Transaction

##### 17.1.1.2 Formal Description

##### 17.1.1.3 Construction of the ACK Request

#### 17.1.2 Non-INVITE Client Transaction

##### 17.1.2.1 Overview of the non-INVITE Transaction

##### 17.1.2.2 Formal Description

#### 17.1.3 Matching Responses to Client Transactions

#### 17.1.4 Handling Transport Errors

### 17.2 Server Transaction

#### 17.2.1 INVITE Server Transaction

#### 17.2.2 Non-INVITE Server Transaction

#### 17.2.3 Matching Requests to Server Transactions

#### 17.2.4 Handling Transport Errors

## 18 Transport

### 18.1 Clients

#### 18.1.1 Sending Requests

#### 18.1.2 Receiving Responses

### 18.2 Servers

#### 18.2.1 Receiving Requests

#### 18.2.2 Sending Responses

### 18.3 Framing

### 18.4 Error Handling

## 19 Common Message Components

### 19.1 SIP and SIPS Uniform Resource Indicators

#### 19.1.1 SIP and SIPS URI Components

#### 19.1.2 Character Escaping Requirements

#### 19.1.3 Example SIP and SIPS URIs

#### 19.1.4 URI Comparison

#### 19.1.5 Forming Requests from a URI

#### 19.1.6 Relating SIP URIs and tel URLs

### 19.2 Option Tags

### 19.3 Tags

## 20 Header Fields

### 20.1 Accept

### 20.2 Accept-Encoding

### 20.3 Accept-Language

### 20.4 Alert-Info

### 20.5 Allow

### 20.6 Authentication-Info

### 20.7 Authorization

### 20.8 Call-ID

### 20.9 Call-Info

### 20.10 Contact

### 20.11 Content-Disposition

### 20.12 Content-Encoding

### 20.13 Content-Language

### 20.14 Content-Length

### 20.15 Content-Type

### 20.16 CSeq

### 20.17 Date

### 20.18 Error-Info

### 20.19 Expires

### 20.20 From

### 20.21 In-Reply-To

### 20.22 Max-Forwards

### 20.23 Min-Expires

### 20.24 MIME-Version

### 20.25 Organization

### 20.26 Priority

### 20.27 Proxy-Authenticate

### 20.28 Proxy-Authorization

### 20.29 Proxy-Require

### 20.30 Record-Route

### 20.31 Reply-To

### 20.32 Require

### 20.33 Retry-After

### 20.34 Route

### 20.35 Server

### 20.36 Subject

### 20.37 Supported

### 20.38 Timestamp

### 20.39 To

### 20.40 Unsupported

### 20.41 User-Agent

### 20.42 Via

### 20.43 Warning

### 20.44 WWW-Authenticate

## 21 Response Codes

### 21.1 Provisional 1xx

#### 21.1.1 100 Trying

#### 21.1.2 180 Ringing

#### 21.1.3 181 Call Is Being Forwarded

#### 21.1.4 182 Queued

#### 21.1.5 183 Session Progress

### 21.2 Successful 2xx

#### 21.2.1 200 OK

### 21.3 Redirection 3xx

#### 21.3.1 300 Multiple Choices

#### 21.3.2 301 Moved Permanently

#### 21.3.3 302 Moved Temporarily

#### 21.3.4 305 Use Proxy

#### 21.3.5 380 Alternative Service

### 21.4 Request Failure 4xx

#### 21.4.1 400 Bad Request

#### 21.4.2 401 Unauthorized

#### 21.4.3 402 Payment Required

#### 21.4.4 403 Forbidden

#### 21.4.5 404 Not Found

#### 21.4.6 405 Method Not Allowed

#### 21.4.7 406 Not Acceptable

#### 21.4.8 407 Proxy Authentication Required

#### 21.4.9 408 Request Timeout

#### 21.4.10 410 Gone

#### 21.4.11 413 Request Entity Too Large

#### 21.4.12 414 Request-URI Too Long

#### 21.4.13 415 Unsupported Media Type

#### 21.4.14 416 Unsupported URI Scheme

#### 21.4.15 420 Bad Extension

#### 21.4.16 421 Extension Required

#### 21.4.17 423 Interval Too Brief

#### 21.4.18 480 Temporarily Unavailable

#### 21.4.19 481 Call/Transaction Does Not Exist

#### 21.4.20 482 Loop Detected

#### 21.4.21 483 Too Many Hops

#### 21.4.22 484 Address Incomplete

#### 21.4.23 485 Ambiguous

#### 21.4.24 486 Busy Here

#### 21.4.25 487 Request Terminated

#### 21.4.26 488 Not Acceptable Here

#### 21.4.27 491 Request Pending

#### 21.4.28 493 Undecipherable

### 21.5 Server Failure 5xx

#### 21.5.1 500 Server Internal Error

#### 21.5.2 501 Not Implemented

#### 21.5.3 502 Bad Gateway

#### 21.5.4 503 Service Unavailable

#### 21.5.5 504 Server Time-out

#### 21.5.6 505 Version Not Supported

#### 21.5.7 513 Message Too Large

### 21.6 Global Failures 6xx

#### 21.6.1 600 Busy Everywhere

#### 21.6.2 603 Decline

#### 21.6.3 604 Does Not Exist Anywhere

#### 21.6.4 606 Not Acceptable

## 22 Usage of HTTP Authentication

### 22.1 Framework

### 22.2 User-to-User Authentication

### 22.3 Proxy-to-User Authentication

### 22.4 The Digest Authentication Scheme

## 23 S/MIME

### 23.1 S/MIME Certificates

### 23.2 S/MIME Key Exchange

### 23.3 Securing MIME bodies

### 23.4 SIP Header Privacy and Integrity using S/MIME: Tunneling SIP

#### 23.4.1 Integrity and Confidentiality Properties of SIP Headers

##### 23.4.1.1 Integrity

##### 23.4.1.2 Confidentiality

#### 23.4.2 Tunneling Integrity and Authentication

#### 23.4.3 Tunneling Encryption

## 24 Examples

### 24.1 Registration

### 24.2 Session Setup

## 25 Augmented BNF for the SIP Protocol

### 25.1 Basic Rules

## 26 Security Considerations: Threat Model and Security Usage Recommendations

### 26.1 Attacks and Threat Models

#### 26.1.1 Registration Hijacking

#### 26.1.2 Impersonating a Server

#### 26.1.3 Tampering with Message Bodies

#### 26.1.4 Tearing Down Sessions

#### 26.1.5 Denial of Service and Amplification

#### 26.2 Security Mechanisms

#### 26.2.1 Transport and Network Layer Security

#### 26.2.2 SIPS URI Scheme

#### 26.2.3 HTTP Authentication

#### 26.2.4 S/MIME

### 26.3 Implementing Security Mechanisms

#### 26.3.1 Requirements for Implementers of SIP

#### 26.3.2 Security Solutions

##### 26.3.2.1 Registration

##### 26.3.2.2 Interdomain Requests

##### 26.3.2.3 Peer-to-Peer Requests

##### 26.3.2.4 DoS Protection

### 26.4 Limitations

#### 26.4.1 HTTP Digest

#### 26.4.2 S/MIME

#### 26.4.3 TLS

#### 26.4.4 SIPS URIs

### 26.5 Privacy

## 27 IANA Considerations

### 27.1 Option Tags

### 27.2 Warn-Codes

### 27.3 Header Field Names

### 27.4 Method and Response Codes

### 27.5 The "message/sip" MIME type.

### 27.6 New Content-Disposition Parameter Registrations

## 28 Changes From RFC 2543

### 28.1 Major Functional Changes

### 28.2 Minor Functional Changes

## 29 Normative References

## 30 Informative References

## A Table of Timer Values


