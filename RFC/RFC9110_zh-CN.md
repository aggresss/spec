# HTTP Semantics

> 原文 [https://www.rfc-editor.org/rfc/rfc9110](https://www.rfc-editor.org/rfc/rfc9110)

## 摘要

超文本传输协议 (HTTP) 是一种用于分布式、协作的超文本信息系统的无状态应用层协议。本文档描述了 HTTP 的整体架构，建立了通用术语，并从协议中所有版本共享的层面进行定义。在这个定义中包括核心协议元素、可扩展性机制以及 "http" 和 "https" 统一资源标识符 (URI) 方案。

本文档更新了RFC 3864，废止了 RFC 2818、7231、7232、7233、7235、7538、7615、7694 和 7230 的部分内容。

## 1. Introduction

### 1.1. Purpose

Hypertext Transfer Protocol (HTTP) 是一系列无状态、应用层、基于请求/响应的协议，它们共享通用接口、可拓展语义和自描述信息，以实现与基于网络的超文本信息系统的灵活交互。

HTTP 通过向客户端提供独立于所提供资源类型的统一接口，隐藏了服务如何实现的细节。同样，服务端不需要知道每个客户端的目的:可以孤立地考虑请求，而不是与特定类型的客户端或预定的应用程序步骤序列相关联。这允许在许多不同的上下文中有效地使用通用实现，降低交互复杂性，并支持随着时间的推移而独立地发展。

HTTP 还被设计为用作中介协议，其中代理和网关可以将非 HTTP 信息系统转换为更通用的接口。

这种灵活性的一个后果是协议不能根据接口背后发生的事情来定义。相反，我们被限制在定义通信的语法、接收到的通信的意图和接收方的预期行为。如果孤立地考虑通信，那么成功的操作应该反映在服务器提供的可观察接口的相应更改中。然而，由于多个客户端可能并行操作，并且可能出于不同的目的，我们不能要求这些更改在单个响应的范围之外是可观察到的。

### 1.2. History and Evolution

HTTP 自 1990 年引入以来一直是万维网的主要信息传输协议。它最初是一种用于低延迟请求的简单机制，使用一个 GET 方法请求传输由给定路径名标识的假定超文本文档。随着 Web 的发展，HTTP 得到了扩展，可以在消息中包含请求和响应，使用类似 MIME 的媒体类型传输任意数据格式，并通过中介路由请求。这些协议最终定义为 HTTP/0.9 和 HTTP/1.0 (参见 [HTTP/1.0])。

HTTP/1.1 旨在改进协议的功能，同时保持与现有的基于文本的消息语法的兼容性，提高其在互联网上的互操作性、可伸缩性和健壮性。这包括：

- 用于固定和动态(分块)内容的基于长度的数据分隔符
- 用于内容协商的一致框架
- 用于条件请求的不透明验证器
- 用于更好的缓存一致性的缓存控件
- 用于部分更新的范围请求
- 默认持久连接。

HTTP/1.1 于 1995 年引入，1997 年在 Standards Track 上发布 [RFC2068]， 1999 年修订 [RFC2616]，并于 2014 年再次修订 ([RFC7230] 至 [RFC7235])。

HTTP/2 ([HTTP/2]) 在现有 TLS 和 TCP 协议的基础上引入了一个多路复用会话层，用于通过高效的字段压缩和服务器推送来交换并发 HTTP 消息。

HTTP/3 ([HTTP/3]) 通过使用 基于 UDP 的 QUIC 作为安全多路传输协议，而不是 TCP，为并发消息提供了更大的独立性。

HTTP 的三个主要版本都依赖于本文档定义的语义。它们并没有互相淘汰，因为每一种都有特定的好处和限制，这取决于使用的环境。具体实现应该为其特定的上下文选择最合适的传输和消息传递语法。

当前的 HTTP 修订文档从 HTTP/1.1 消息传递语法 ([HTTP/1.1]) 中分离了语义(本文档)和缓存 ([CACHING]) 的定义，以允许每个主要协议版本在引用相同的核心语义的同时独立发展。

### 1.3. Core Semantics

HTTP 通过发送操作或传输表示的消息 (第3.2节)，提供了与资源交互的统一接口 (第3.1节) —— 无论其类型、性质或实现如何。

每条消息要么是请求，要么是响应。客户端构造用于传递其意图的请求消息，并将这些消息路由到已识别的源服务器。服务器侦听请求，解析接收到的每个消息，解释与已识别的目标资源相关的消息语义，并用一个或多个响应消息响应该请求。客户端检查收到的响应，以确定其意图是否被执行，并根据收到的状态代码和内容确定下一步要做什么。

HTTP 语义包括每个请求方法定义的意图 (第9节)、可能在请求头字段中描述的语义扩展、描述响应的状态代码 (第15节) 以及可能在响应字段中给出的其他控制数据和资源元数据。

HTTP 语义还包括描述接收者打算如何解释内容的表示元数据、可能影响内容选择的请求报头字段以及统称为“内容协商”的各种选择算法 (第12节)。

### 1.4. Specifications Obsoleted by This Document

Title | Reference | See
--|--|--
HTTP Over TLS | [RFC2818] | B.1
HTTP/1.1 Message Syntax and Routing [*] | [RFC7230] | B.2
HTTP/1.1 Semantics and Content | [RFC7231] | B.3
HTTP/1.1 Conditional Requests | [RFC7232] | B.4
HTTP/1.1 Range Requests | [RFC7233] | B.5
HTTP/1.1 Authentication | [RFC7235] | B.6
HTTP Status Code 308 (Permanent Redirect) | [RFC7538] | B.7
HTTP Authentication-Info and Proxy-Authentication-Info Response Header Fields | [RFC7615] | B.8
HTTP Client-Initiated Content-Encoding | [RFC7694] | B.9

[*] 本文档仅废弃了 RFC7230 中独立于 HTTP/1.1 消息传递语法和连接管理的部分; RFC7230 的剩余部分由 "HTTP/1.1"[HTTP/1.1] 废止。

## 2. Conformance

### 2.1. Syntax Notation

本规范使用[RFC5234]的 Augmented Backus-Naur Form (ABNF)，扩展了[RFC7405]中定义的字符串区分大小写的表示法。

它还使用了在第 5.6.1 节中定义的列表扩展，允许使用 "#" 操作符 (类似于 "*" 操作符表示重复)紧凑地定义逗号分隔的列表。附录 A 显示了收集到的语法，其中所有列表操作符扩展为标准 ABNF 表示法。

按照惯例，ABNF 规则名前缀为 "obs-" 表示由于历史原因而出现的过时语法规则。

参考 [RFC5234] 附录 B.1 定义的核心规则包括: ALPHA(字母)、CR(回车)、CRLF(CR LF)、CTL(控制符)、DIGIT(十进制0-9)、DQUOTE(双引号)、HEXDIG(十六进制0-9/A-F/a-f)、HTAB(水平制表符)、LF(换行)、OCTET(任何8位数据序列)、SP(空格)、VCHAR(任何可见的 US-ASCII 字符)。

第 5.6 节定义了字段值的一些通用语法组件。

本规范使用了 [RFC6365] 中定义的术语 “字符”、“字符编码方案”、“字符集”和“协议元素”。

### 2.2. Requirements Notation

本文档中的关键词“必须”、“不得”、“必需”、“应”、“不应”、“建议”、“不建议”、“可”和“可选”在所有大写字母出现时（如图所示）应按照 BCP 14 [RFC2119] [RFC8174] 所述进行解释。

该规范根据 HTTP 通信中参与者的角色确定一致性标准。因此，需求被放在发送者、接收者、客户端、服务器、用户代理、中介体、原始服务器、代理、网关或缓存上，这取决于需求所约束的行为。当实现、资源所有者和协议元素注册超出单个通信的范围时，会对它们提出额外的要求。

当需求只应用于创建协议元素的实现，而不是向下游转发接收到的元素的实现时，使用动词 "generate" 而不是 "send"。

如果一个实现符合与它在 HTTP 中所扮演的角色相关的所有需求，那么它就被认为是符合的。

发送方绝对不能生成与相应 ABNF 规则定义的语法不匹配的协议元素。在给定的消息中，发送方绝对不能生成仅允许由其他角色(即发送方没有该消息的角色)的参与者生成的协议元素或语法替代方案。

对 HTTP 的一致性既包括对所使用协议版本的特定消息传递语法的一致性，也包括对所发送的协议元素的语义的一致性。例如，一个客户端声称符合 HTTP/1.1，但未能识别 HTTP/1.1 接收方所需的功能，将无法与根据这些声明调整响应的服务器进行互操作。反映用户选择的特性，如内容协商和用户选择的扩展，可以影响超出协议流的应用程序行为;发送不准确反映用户选择的协议元素将使用户感到困惑并抑制选择。

当实现在语义一致性上失败时，该实现的消息的接收者最终将开发变通方法来相应地调整其行为。如果解决办法仅限于发生故障的实现，接收方可以在保持符合本协议的情况下采用此类解决办法。例如，服务器经常扫描 User-Agent 字段值的一部分，而用户代理经常扫描 Server 字段值，以根据已知的错误或选择不当的默认值调整自己的行为。

### 2.3. Length Requirements

接收方应该防御性地解析接收到的协议元素，只期望该元素符合其 ABNF 语法并适合合理的缓冲区大小。

HTTP对它的许多协议元素没有特定的长度限制，因为合适的长度可能会有很大的不同，这取决于部署上下文和实现的目的。因此，发送方和接收方之间的互操作性取决于对每个协议元素的合理长度的共同期望。此外，在过去 30 年的 HTTP 使用过程中，通常理解的一些协议元素的合理长度已经发生了变化，并且预计在未来还会继续发生变化。

至少，接收方必须能够解析和处理协议元素长度，这些长度至少与它在其他消息中为这些相同的协议元素生成的值相同。例如，将很长的 URI 引用发布到其自身资源的源服务器需要在接收到目标 URI 时能够解析和处理这些相同的引用。

许多接收到的协议元素只在识别和向下游转发该元素所需的范围内进行解析。例如，中介可能将接收到的字段解析为其字段名和字段值组件，但随后转发该字段，而无需在字段值内部进一步解析。

### 2.4. Error Handing

接收方必须根据本规范为其定义的语义(包括本规范的扩展)解释接收到的协议元素，除非接收方(通过经验或配置)确定发送方错误地实现了这些语义所暗示的内容。例如，如果对 User-Agent 报头字段的检查表明某个特定的实现版本在接收到某些内容编码时失败，那么源服务器可能会忽略接收到的 Accept-Encoding 报头字段的内容。

除非另有说明，接收方可以尝试从无效的构造中恢复可用的协议元素。HTTP 不定义特定的错误处理机制，除非这些机制对安全性有直接影响，因为协议的不同应用程序需要不同的错误处理策略。例如，Web 浏览器可能希望从 Location 报头字段没有根据 ABNF 解析的响应中透明地恢复，而系统控制客户端可能认为任何形式的错误恢复都是危险的。

在底层连接失败的情况下，一些请求可以被客户端自动重试，如 9.2.2 节所述。

### 2.5. Protocol Version

HTTP的版本号由 "." 分隔的两个十进制数字组成。(句号或小数点)。第一个数字(主要版本)表示消息语法，而第二个数字(次要版本)表示发送方符合(能够理解以便将来通信)的主要版本中最高的次要版本。

虽然 HTTP 的核心语义在协议版本之间不会改变，但它们的表达式可能会改变，因此当对有线格式进行不兼容的更改时，HTTP版本号也会改变。此外，HTTP允许对协议进行增量的、向后兼容的更改，而无需通过使用定义的扩展点更改其版本 (第16节)。

协议版本作为一个整体表明发送方是否符合该版本对应规范中规定的要求集。例如，"HTTP/1.1" 版本是由本文档的 "HTTP缓存"[Caching] 和 "HTTP/1.1"[HTTP/1.1] 的组合规范定义的。

当引入不兼容的消息语法时，HTTP 的主版本号会增加。当对协议所做的更改增加消息语义或暗示发送方的额外功能时，次要编号将增加。

即使发送方只使用向后兼容的协议子集，次要版本也会公布发送方的通信能力，从而让接收方知道可以在响应(服务器)或未来的请求(客户端)中使用更高级的功能。

当 HTTP 的主版本没有定义任何次要版本时，暗示次要版本 "0"。"0" 用于在需要次要版本标识符的元素中引用该协议。

## 3. Terminology and Core Concepts

HTTP 是为万维网 (WWW) 架构而创建的，并随着时间的推移不断发展，以支持全球超文本系统的可伸缩性需求。该体系结构的大部分内容反映在用于定义 HTTP 的术语中。

### 3.1. Resources

HTTP 请求的目标称为“资源”。HTTP 不限制资源的性质；它仅仅定义了一个可能用于与资源交互的接口。大多数资源由统一资源标识符 (Uniform Resource Identifier, URI) 标识，如第4节所述。

HTTP 的一个设计目标是将资源标识与请求语义分离，这可以通过在请求方法 (第9节) 和一些请求修改头字段中嵌入请求语义来实现。资源不能以与请求方法的语义不一致的方式处理请求。例如，尽管资源的 URI 可能意味着不安全的语义，但客户端可以期望资源在使用安全方法处理请求时避免不安全的操作 (参见章节9.2.1)。

HTTP 依赖统一资源标识符(Uniform Resource Identifier, URI) 标准[URI] 来指示目标资源(章节7.1)和资源之间的关系。

### 3.2. Representations

“表示” 是旨在反映给定资源的过去、当前或期望状态的信息，其格式可以通过协议随时进行通信。一个表示由一组表示元数据和一个潜在的无界表示数据流组成(第8节)。

HTTP 允许“信息隐藏”在其统一的接口后面，通过定义与资源状态的可传输表示相关的通信，而不是传输资源本身。这允许URI标识的资源是任何东西，包括时间函数，如“拉古纳海滩的当前天气”，同时潜在地提供在消息生成时表示该资源的信息[REST]。

统一接口类似于一个窗口，通过这个窗口，人们只能通过将消息传递给另一边的独立行动者来观察事物并对其采取行动。在我们的通信中，需要一个共享的抽象来表示(“取代”)该事物的当前或期望状态。当一个表示是超文本时，它既可以提供资源状态的表示，也可以提供帮助指导接收者未来交互的处理指令。

目标资源可能提供或能够生成多个表示，每个表示旨在反映资源的当前状态。通常基于内容协商(第12节)的算法将用于从这些表示中选择最适用于给定请求的一种。这个“选定的表示”为评估条件请求(第13节)提供了数据和元数据，并为GET的200 (OK)、206(部分内容)和304(未修改)响应构造内容(第9.3.1节)。

### 3.3. Connections, Clients, and Servers

HTTP 是一个在可靠的传输层或会话层“连接”上运行的客户端/服务器协议。

HTTP “客户端”是为了发送一个或多个 HTTP 请求而与服务器建立连接的程序。HTTP “服务器”是一个接受连接的程序，通过发送HTTP响应来服务HTTP请求。

术语客户端和服务器仅指这些程序为特定连接执行的角色。同一个程序可能在某些连接上充当客户端，在其他连接上充当服务器。

HTTP被定义为无状态协议，这意味着可以孤立地理解每个请求消息的语义，并且连接和其中的消息之间的关系对这些消息的解释没有影响。例如，一个CONNECT请求(章节9.3.6)或一个带有Upgrade报头字段的请求(章节7.8)可以在任何时候发生，而不仅仅是在连接的第一条消息中。许多实现依赖于HTTP的无状态设计，以便在多个服务器之间重用代理连接或动态负载平衡请求。

因此，服务器绝对不能假定同一连接上的两个请求来自同一个用户代理，除非连接是安全的并且特定于该代理。一些非标准的HTTP扩展(例如，[RFC4559])已经被发现违反了这一要求，导致了安全性和互操作性问题。

### 3.4. Messages

HTTP 是一种无状态的请求/响应协议，用于在连接之间交换“消息”。术语“发送方”和“接收方”分别指发送或接收给定消息的任何实现。

客户端以带有方法(第9节)和请求目标(第7.1节)的“请求”消息的形式向服务器发送请求。请求还可能包含用于请求修饰符、客户端信息和表示元数据的报头字段(章节6.3)、用于按照方法处理的内容(章节6.4)以及用于在发送内容时传递收集到的信息的尾字段(章节6.5)。

服务器通过发送一个或多个“响应”消息来响应客户机的请求，每个“响应”消息包括一个状态码(第15节)。响应还可能包含用于服务器信息的报头字段、资源元数据和表示元数据、根据状态代码解释的内容，以及用于在发送内容时传递收集到的信息的尾部字段。

### 3.5. User Agents

术语“用户代理”指的是发起请求的各种客户机程序。

最常见的用户代理形式是通用 Web 浏览器，但这只占实现的一小部分。其他常见的用户代理包括 spider (穿越网络的机器人)、命令行工具、广告牌屏幕、家用电器、秤、灯泡、固件更新脚本、移动应用程序和各种形状和大小的通信设备。

作为用户代理并不意味着在请求时有一个人类用户直接与软件代理交互。在许多情况下，用户代理被安装或配置为在后台运行，并保存其结果以供以后检查(或仅保存那些可能有趣或错误的结果的子集)。例如，通常会给 spider 一个起始 URI，并将其配置为在以超文本图的形式在 Web 上爬行时遵循某些行为。

许多用户代理不能(或选择不)向用户提供交互式建议，或就安全或隐私问题提供足够的警告。在少数情况下，该规范要求向用户报告错误，这种报告只能在错误控制台或日志文件中可见，这是可以接受的。同样地，在继续之前由用户确认自动操作的需求可以通过预先配置选择、运行时选项或简单地避免不安全操作来满足;如果用户已经做出了选择，确认并不意味着任何特定的用户界面或正常处理的中断。

### 3.6. Origin Server

术语“源服务器”是指可以为给定的目标资源发起权威响应的程序。

最常见的原始服务器形式是大型公共网站。然而，就像用户代理被等同于浏览器一样，很容易被误导，认为所有的原始服务器都是一样的。常见的原始服务器还包括家庭自动化单元、可配置的网络组件、办公机器、自主机器人、新闻源、交通摄像头、实时广告选择器和视频点播平台。

大多数 HTTP 通信由一个检索请求 (GET) 组成，该请求用于 URI 标识的某些资源的表示。在最简单的情况下，这可以通过用户代理 (UA) 和源服务器 (O) 之间的单个双向连接 (===) 来完成。

```
         request   >
    UA ======================================= O
                                <   response
```

### 3.7. Intermediaries

HTTP 允许使用中介体通过连接链来满足请求。HTTP “中介”有三种常见形式: 代理、网关和隧道。在某些情况下，单个中介可能充当原始服务器、代理、网关或隧道，根据每个请求的性质切换行为。

```
         >             >             >             >
    UA =========== A =========== B =========== C =========== O
               <             <             <             <
```

上图显示了用户代理和原始服务器之间的三个中介(A、B和C)。在整个链中传递的请求或响应消息将通过四个独立的连接。有些 HTTP 通信选项可能只应用于与最近的非隧道邻居的连接，只应用于链的端点，或者应用于链上的所有连接。尽管图是线性的，但是每个参与者可能同时进行多个通信。例如，在处理 A 的请求的同时，B 可能正在接收来自除 A 以外的许多客户机的请求，并且/或将请求转发到除 C 以外的服务器。同样，以后的请求可能通过不同的连接路径发送，通常基于负载平衡的动态配置。

术语“上游”和“下游”用于描述与消息流相关的定向需求:所有消息都从上游流向下游。术语“入站”和“出站”用于描述与请求路由相关的定向需求:入站意味着“指向源服务器”，而出站意味着“指向用户代理”。

“代理”是一种消息转发代理，通常由客户端通过本地配置规则选择，用于接收某些类型的绝对 URI 请求，并试图通过 HTTP 接口的转换来满足这些请求。有些转换是最小的，例如 “http” uri的代理请求，而其他请求可能需要转换到完全不同的应用程序级协议。代理通常用于通过公共中介对组织的 HTTP 请求进行分组，以实现安全服务、注释服务或共享缓存。有些代理被设计为在转发消息或内容时对选定的消息或内容应用转换，如第7.7节所述。

一个“门户”(又名“门户”)。“反向代理”)是一种中介，充当出站连接的源服务器，但转换接收到的请求并将它们转发到另一个或多个服务器。网关通常用于封装遗留或不受信任的信息服务，通过“加速器”缓存来提高服务器性能，并支持跨多台机器对HTTP服务进行分区或负载平衡。

适用于源服务器的所有HTTP要求也适用于网关的出站通信。网关使用它想要的任何协议与入站服务器通信，包括超出本规范范围的HTTP私有扩展。但是，希望与第三方HTTP服务器进行互操作的 HTTP-to-HTTP 网关需要符合网关入站连接上的用户代理要求。

“隧道”在不改变消息的情况下充当两个连接之间的盲中继。一旦激活，隧道就不被视为 HTTP 通信的一方，尽管隧道可能是由 HTTP 请求发起的。当中继连接的两端关闭时，隧道即停止存在。隧道用于通过中介扩展虚拟连接，例如当传输层安全(TLS， [TLS13])用于通过共享防火墙代理建立机密通信时。

上述中介类别仅考虑充当 HTTP 通信参与者的中介。还有一些中介体可以作用于网络协议栈的较低层，在消息发送方不知情或不允许的情况下过滤或重定向 HTTP 流量。网络中介体(在协议级别上)与路径上的攻击者难以区分，由于错误地违反 HTTP 语义，通常会引入安全缺陷或互操作性问题。

例如，“拦截代理”[RFC3040](通常也称为“透明代理”[RFC1919])与HTTP代理不同，因为它不是由客户端选择的。相反，拦截代理过滤或重定向传出的 TCP 端口 80 包(偶尔还有其他常见端口流量)。拦截代理通常出现在公共网络接入点上，作为在允许使用非本地Internet服务之前强制帐户订阅的一种手段，并在公司防火墙内强制执行网络使用策略。

### 3.8. Caches

“缓存”是以前响应消息的本地存储，以及控制其消息存储、检索和删除的子系统。缓存存储可缓存的响应，以减少未来等效请求的响应时间和网络带宽消耗。任何客户端或服务器都可以使用缓存，但缓存不能在充当隧道时使用。

缓存的效果是，如果链上的一个参与者有一个适用于该请求的缓存响应，那么请求/响应链就会缩短。如果 B 有一个未被 UA 或 A 缓存的请求的 O(通过 C ) 早期响应的缓存副本，则如下所示的结果链。

```
            >             >
       UA =========== A =========== B - - - - - - C - - - - - - O
                  <             <
```

如果允许缓存存储响应消息的副本以用于响应后续请求，则响应是“可缓存的”。即使响应是可缓存的，客户机或源服务器也可能对何时可以将缓存的响应用于特定请求设置额外的约束。缓存行为和可缓存响应的HTTP要求在[CACHING]中定义。

在万维网上和大型组织内部部署了各种各样的缓存体系结构和配置。其中包括全国层次结构的代理缓存，以节省带宽和降低延迟，使用网关缓存优化流行站点的区域和全球分布的内容交付网络，广播或组播缓存条目的协作系统，在脱机或高延迟环境中使用的预取缓存条目的存档，等等。

### 3.9. Example Message Exchange

下面的例子说明了一个典型的 HTTP/1.1 消息交换，用于 URI "http://www.example.com/hello.txt" 上的 GET 请求(章节9.3.1):

Client request:

```
GET /hello.txt HTTP/1.1
User-Agent: curl/7.64.1
Host: www.example.com
Accept-Language: en, mi
```

Server response:

```
HTTP/1.1 200 OK
Date: Mon, 27 Jul 2009 12:28:53 GMT
Server: Apache
Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
ETag: "34aa387-d-1568eb00"
Accept-Ranges: bytes
Content-Length: 51
Vary: Accept-Encoding
Content-Type: text/plain

Hello World! My content includes a trailing CRLF.
```

## 4. Identifiers in HTTP

统一资源标识符 (URI) [URI]在整个 HTTP 中用作标识资源的手段(章节3.1)。

### 4.1. URI References

URI 引用用于定位请求、指示重定向和定义关系。

“URI-reference”、“absolute-URI”、“relative-part”、“authority”、“port”、“host”、“path-abempty”、“segment”、“query” 等定义均采用 URI 泛型语法。为可以包含非空路径组件的协议元素定义了“绝对路径”规则。(此规则与 RFC3986 中的 path-abempty 规则略有不同，后者允许使用空路径，而path-absolute规则不允许以 “//” 开头的路径。) “partial-URI” 规则是为可以包含相对 URI 但不包含片段组件的协议元素定义的。

```
  URI-reference = <URI-reference, see [URI], Section 4.1>
  absolute-URI  = <absolute-URI, see [URI], Section 4.3>
  relative-part = <relative-part, see [URI], Section 4.2>
  authority     = <authority, see [URI], Section 3.2>
  uri-host      = <host, see [URI], Section 3.2.2>
  port          = <port, see [URI], Section 3.2.3>
  path-abempty  = <path-abempty, see [URI], Section 3.3>
  segment       = <segment, see [URI], Section 3.3>
  query         = <query, see [URI], Section 3.4>

  absolute-path = 1*( "/" segment )
  partial-URI   = relative-part [ "?" query ]
```

HTTP 中允许 URI 引用的每个协议元素都将在其 ABNF 生成中指示该元素是否允许任何形式的引用 (URI-reference)、是否只允许绝对形式的 URI (absolute-URI)、是否只允许路径和可选查询组件(partial-URI)，或以上几种类型的某种组合。除非另有说明，否则URI引用将相对于目标URI进行解析(章节7.1)。

建议所有发送方和接收方至少支持协议元素中长度为8000字节的uri。注意，这意味着某些结构和在线表示(例如，HTTP/1.1中的请求行)在某些情况下必然会更大。

### 4.2. HTTP-Related URI Schemes

IANA在 <https://www.iana.org/assignments/uri-schemes/> 维护 URI 方案 [BCP35] 的注册表。尽管请求可能针对任何URI方案，但以下方案是HTTP服务器固有的:

URI Scheme | Description | Section
--|--|--
http | Hypertext | Transfer Protocol | 4.2.1
https | Hypertext Transfer Protocol Secure | 4.2.2

请注意，“http” 或 “https” URI的存在并不意味着始终有一个 http 服务器在标识的原点侦听连接。任何人都可以创建 URI，无论服务器是否存在，以及服务器当前是否将该标识符映射到资源。注册名称和 IP 地址的委托性质将创建一个联邦名称空间，无论是否存在 HTTP 服务器。

#### 4.2.1. http URI Scheme

这里定义了 “http” URI方案，用于在分层命名空间内创建标识符，该命名空间由侦听给定端口上 TCP ([TCP]) 连接的潜在 http 源服务器所治理。

```
http-URI = "http" "://" authority path-abempty [ "?" query ]
```

“http”URI的源服务器由授权组件标识，它包括一个主机标识符([URI]，章节3.2.2)和可选端口号([URI]，章节3.2.3)。如果端口子组件为空或没有给出，TCP端口80(为WWW服务预留的端口)是默认的。原点决定了谁有权权威地响应以已标识资源为目标的请求，如第4.3.2节所定义。

发送方绝对不能生成带有空主机标识符的“http”URI。处理此类URI引用的接收方必须将其视为无效而拒绝。

分层路径组件和可选查询组件在源服务器的名称空间中标识目标资源。

#### 4.2.2. https URI Scheme

这里定义了 “https” URI 方案，用于在分层命名空间内创建标识符，该命名空间由潜在的源服务器管理，侦听给定端口上的 TCP 连接，并能够建立已为 HTTP 通信提供安全保护的TLS ([TLS13])连接。在这种情况下，“安全的”具体指的是服务器已经被认证为代表所识别的授权机构，并且与该服务器的所有HTTP通信都具有客户机和服务器都可接受的机密性和完整性保护。

```
 https-URI = "https" "://" authority path-abempty [ "?" query ]
```

“https” URI 的源服务器由授权组件标识，它包括一个主机标识符([URI]，章节3.2.2)和可选端口号([URI]，章节3.2.3)。如果端口子组件为空或未给出，则 TCP 端口 443 (HTTP over TLS的预留端口) 是默认值。原点决定了谁有权权威地响应以标识资源为目标的请求，如第 4.3.3 节中定义的那样。

发送方绝对不能生成带有空主机标识符的 “https” URI。处理此类 URI 引用的接收方必须将其视为无效而拒绝。

分层路径组件和可选查询组件在源服务器的名称空间中标识目标资源。

客户端必须确保其对 “https” 资源的 HTTP 请求在通信之前是安全的，并且它只接受对这些请求的安全响应。请注意，客户端和服务器可以接受的加密机制的定义通常是协商的，并且可以随着时间的推移而改变。

通过 “https” 方案提供的资源与 “http” 方案没有共享标识。它们是具有独立名称空间的不同起源。然而，对 HTTP 的扩展被定义为应用于具有相同主机的所有源，例如 Cookie 协议[Cookie]，允许一个服务设置的信息影响与匹配主机域中的其他服务的通信。这种扩展的设计应该非常谨慎，以防止从安全连接获得的信息在不安全的上下文中被无意地交换。

#### 4.2.3. http(s) Normalization and Comparison

带有 “http” 或 “https” 方案的 URI 根据[URI]第 6 节中定义的方法进行规范化和比较，并使用上述每种方案的默认值。

HTTP 不需要使用特定的方法来确定等价性。例如，缓存键可以作为一个简单的字符串进行比较，在基于语法的归一化之后，或者在基于方案的归一化之后。

“http” 和 “https” URI 的基于方案的规范化([URI]第6.2.3节)涉及以下附加规则:

- 如果端口等于某个方案的默认端口，一般形式是省略端口子组件。
- 当不被用作 OPTIONS 请求的目标时，空路径组件相当于“/”的绝对路径，因此正常形式是提供 “/” 的路径。
- scheme 和 host 不区分大小写，通常以小写形式提供；所有其他组件都以区分大小写的方式进行比较。
- 除“保留”集中的字符外，其他字符等效于它们的百分比编码的八字节:正常形式是不编码它们(参见[URI]的2.1和2.2节)。

例如，以下三个uri是等价的:

```
   http://example.com:80/~smith/home.html
   http://EXAMPLE.com/%7Esmith/home.html
   http://EXAMPLE.com:/%7esmith/home.html
```

可以假设规范化(使用任何方法)后等价的两个 HTTP uri 标识相同的资源，并且任何 HTTP 组件都可以执行规范化。因此，不同的资源不应该被标准化后等效的 HTTP URI 标识(使用[URI]章节6.2中定义的任何方法)。

#### 4.2.4. Deprecation of userinfo in http(s) URIs

授权的 URI 通用语法还包括 userinfo 子组件([URI]， Section 3.2.1)，用于在 URI 中包含用户身份验证信息。在该子组件中，不建议使用 “user:password” 格式。

有些实现将 userinfo 组件用于身份验证信息的内部配置，例如在命令调用选项、配置文件或书签列表中，尽管这种使用可能会暴露用户标识符或密码。

当在消息中生成 “http” 或 “https” URI 引用作为目标 URI 或字段值时，发送方绝对不能生成 userinfo 子组件(及其“@”分隔符)。

在使用来自不可信源的 “http” 或 “https” URI 引用之前，接收方应该解析 userinfo 并将其作为错误处理;这很可能是为了网络钓鱼攻击而被用来绕过授权。

#### 4.2.5. http(s) References with Fragment Identifiers

片段标识符允许间接标识辅助资源，独立于URI方案，如[URI]第3.5节所定义。一些引用URI的协议元素允许包含片段，而另一些则不允许。它们通过使用ABNF规则来区分允许分段的元素;否则，将使用排除片段的特定规则。

> 注意:片段标识符组件不是 URI 方案定义的一部分(参见[URI]第4.3节)，因此没有出现在上面 “http” 和 “https” URI 方案的 ABNF 定义中。

### 4.3 Authoritative Access

授权访问指的是以客户端认为是授权的(由资源所有者控制)的方式取消对给定标识符的引用，以便访问已标识的资源。决定是否授予访问权的过程由 URI 方案定义，并且通常使用 URI 组件中的数据，例如在使用泛型语法时使用授权组件。然而，授权访问并不局限于所识别的机制。

第 4.3.1 节将源站的概念定义为对这些用途的辅助，随后的子节解释了如何确定对等体具有代表源站的权限。

有关建立权限的安全考虑，请参见 17.1 节。

#### 4.3.1. URI Origin

给定URI的“源”是 scheme、host 和 port 的三元组，将 scheme 和 host 规范化为小写，并将 port 规范化以删除前导的零。如果在URI中省略了 port，则使用该方案的默认端口。例如，URI:

```
 https://Example.Com/happy.js
```

源站三元组为：

```
{ "https", "example.com", "443" }
```

这也可以被描述为始终存在端口的规范化URI前缀:

```
https://example.com:443
```

每个源定义自己的命名空间，并控制该命名空间中的标识符如何映射到资源。反过来，随着时间的推移，源如何响应有效的请求，决定了用户将与 URI 关联的语义，而这些语义的有用性最终将这些机制转换为供用户将来引用和访问的资源。

如果两个源在方案、主机或端口上不同，则它们是不同的。即使可以验证同一个实体控制两个不同的源，这些源下的两个命名空间也是不同的，除非授权该源的服务器显式指定别名。

Origin 也用于 HTML 和相关的 Web 协议中，超出了本文档的范围，如[RFC6454]所述。

#### 4.3.2. http Origins

虽然 HTTP 独立于传输协议，但 “HTTP” 方案(第4.2.1节)特定于将授权机构与控制源服务器的任何人关联起来，源服务器侦听授权机构组件中标识的任何主机的指定端口上的 TCP 连接。这是一种非常弱的权威感，因为它依赖于特定于客户端的名称解析机制和通信，而通信可能不会受到路径攻击者的保护。尽管如此，对于将“http”标识符绑定到源服务器以在受信任的环境中进行一致的解析来说，这是一个足够的最低要求。

如果提供的主机标识符是一个 IP 地址，则源服务器是该 IP 地址上指定的 TCP 端口上的侦听器(如果有的话)。如果 host 是一个已注册的名称，则已注册的名称是一个间接标识符，用于与名称解析服务(如DNS)一起使用，以查找适当的源服务器的地址。

当使用 “http” URI 访问指定的资源时，客户端可以尝试通过将主机标识符解析为 IP 地址，在指定的端口上建立到该地址的 TCP 连接，并通过该连接发送一个 http 请求消息，其中包含与客户端目标 URI 匹配的请求目标(章节7.1)。

如果服务器用非临时 HTTP 响应消息响应这样的请求(如第15节所述)，则该响应被认为是对客户端请求的权威响应。

但请注意，上述并不是获得权威响应的唯一方法，也并不意味着权威响应总是必要的(参见[缓存])。例如，Alt-Svc 头字段[ALTSVC]允许源服务器识别同样是该源授权的其他服务。对“http”标识资源的访问也可能由本文档范围之外的协议提供。

#### 4.3.3. https Origins

“https” 方案(章节4.2.2)基于服务器使用私钥的能力来关联授权机构，该私钥对应于客户端认为对已识别的源服务器是可信的证书。客户端通常依赖于一条信任链(由一些预先安排或配置的信任锚点传递)来认为证书是可信的(第4.3.4节)。

在 HTTP/1.1 及更早版本中，只有当客户端通过成功建立并安全的特定于 URI 源主机的连接进行通信时，才会将权限授予服务器。连接建立和证书验证被用作权威的证明。

在 HTTP/2 和 HTTP/3 中，当客户端通过成功建立且安全的连接进行通信时，如果 URI 来源的主机与服务器证书中存在的任何主机相匹配，并且客户端相信它可以为该 URI 打开到该主机的连接，则将权限授予服务器。在实际应用中，客户端会发起 DNS 查询，以检查源主机的 IP 地址与已建立连接的服务器 IP 地址相同。这个限制可以通过源服务器发送一个等效的源帧[RFC8336]来消除。

请求目标的主机和端口值在每个 HTTP 请求中传递，用于标识源，并将其与可能由同一台服务器控制的其他命名空间区分开来(第7.2节)。来源有责任确保提供的任何控制其证书私钥的服务同样负责管理相应的 “https” 命名空间，或至少准备拒绝看似被误导的请求(7.4节)。

源服务器可能不愿意处理对某些目标 uri 的请求，即使它们有这样做的权限。例如，当一台主机在不同的端口(例如 443 和 8000)上运行不同的服务时，检查源服务器上的目标 URI 是必要的(即使在连接已经安全之后)，因为网络攻击者可能会导致一个端口的连接被其他端口接收。如果无法检查目标URI，攻击者可能会将对一个目标 URI 的响应(例如 "https://example.com/foo") 替换为看似权威的来自另一个端口的响应(例如 “https://example.com:8000/foo”)。

请注意，“https” 方案不依赖于 TCP 和连接的端口号来关联授权机构，因为两者都在安全通信之外，因此不能作为确定可信的。因此，HTTP 通信可以在 4.2.2 节定义的任何安全通道上进行，包括不使用 TCP 的协议。

当在要求访问指定资源的上下文中使用 “https” URI 时，客户端可以通过以下方式尝试访问:将主机标识符解析为IP地址，在指定的端口上建立到该地址的 TCP 连接，通过在 TCP 上成功发起具有机密性和完整性保护的 TLS 来保护端到端连接，并通过该连接发送包含与客户端目标 URI 匹配的请求目标的 HTTP 请求消息(章节7.1)。

如果服务器用非临时 HTTP 响应消息响应这样的请求(如第15节所述)，则该响应被认为是对客户端请求的权威响应。

但请注意，上述并不是获得权威响应的唯一方法，也并不意味着权威响应总是必要的(参见[缓存])。

#### 4.3.4. https Certificate Verification

要建立安全连接以解引用 URI，客户端必须验证服务的标识是否与 URI 的源服务器匹配。证书验证用于防止路径攻击者或控制名称解析的攻击者冒充服务器。这个过程要求客户端配置一组信任锚点。

通常情况下，客户端必须使用 [RFC6125] 第 6 节中定义的验证过程来验证服务标识。客户端必须从服务的主机构建一个引用标识:如果主机是一个字面的 IP 地址(第4.3.5节)，引用标识是一个 IP-ID，否则主机是一个名称，引用标识是一个 DNS-ID。

客户端不能使用类型为 CN-ID 的引用标识。如[RFC6125]的6.2.1节所述，旧的客户端可能会使用类型为 CN-ID 的引用标识。

客户端可能经过特殊配置，以接受另一种形式的服务器身份验证。例如，一个客户端可能连接到一个地址和主机名都是动态的服务器，期望该服务提供一个特定的证书(或一个与某些外部定义的引用标识匹配的证书)，而不是一个与目标URI的来源匹配的证书。

在特殊情况下，客户端可以简单地忽略服务器的身份，但必须理解这将使连接对主动攻击敞开大门。

如果证书对目标 URI 的来源无效，则用户代理必须在继续操作之前获得用户的确认(参见3.5节)，或者因证书错误而终止连接。自动化客户端必须将错误记录到适当的审计日志中(如果有的话)，并且应该终止连接(因为证书错误)。自动化客户端可以提供禁用此检查的配置设置，但必须提供启用此检查的设置。

#### 4.3.5. IP-ID Reference Identity

使用 “https” URI 的 “host” 字段中的 IP 地址字面值标识的服务器具有 IP-ID 类型的引用标识。一个 IPv4 的地址使用 “IPv4address” ABNF规则，一个IPv6 的地址使用 “IP-literal” 产生的“IPv6address” 选项;参见 [URI]的3.2.2 节。IP-ID 的引用标识包含IP地址的解码字节。

IP版本4的地址是4个字节，IP版本6的地址是16个字节。没有为任何其他IP版本定义 IP-ID 的使用。证书 subjectAltName 扩展中的 iPAddress 选项没有显式地包括 IP 版本，因此依赖于地址的长度来区分版本;参见[RFC5280]的 4.2.1.6 节。

如果地址与证书的 subjectAltName 扩展名的 iPAddress 值相同，则匹配 IP-ID 类型的引用标识。

## 5. Fields

HTTP使用“字段”以可扩展的名称/值对的形式提供具有注册密钥名称空间的数据。字段在消息的头和尾部分中发送和接收(第6节)。

### 5.1. Field Names

字段名将对应的字段值标记为具有由该名称定义的语义。例如，Date 报头字段在第 6.6.1 节中定义为包含它出现的消息的起源时间戳。

```
  field-name     = token
```

字段名不区分大小写，应该在“超文本传输协议(HTTP)字段名注册表”中注册;参见 16.3.1 节。

一个字段的解释在相同的主HTTP版本的次要版本之间不会改变，尽管在缺少这样一个字段时，接收方的默认行为可能会改变。除非另有指定，否则字段将为所有 HTTP 版本定义。特别是，Host 和 Connection 字段应该被所有 HTTP 实现所识别，无论它们是否宣称符合 HTTP/1.1。

如果定义的语义允许不识别它们的接收者安全地忽略它们，则可以在不改变协议版本的情况下引入新字段;参见 16.3 节。

代理必须转发无法识别的报头字段，除非字段名列在 Connection 报头字段中(章节7.6.1)，或者代理被专门配置为阻塞或转换此类字段。其他收件人应忽略未识别的头和尾字段。遵循这些要求可以在不更新或删除已部署的中介的情况下扩展 HTTP 的功能。

### 5.2. Field Lines and Combined Field Value

字段段由任意数量的“字段行”组成，每一行都有一个“字段名”(见章节5.1)来标识该字段，以及一个“字段行值”来传达该字段实例的数据。

当一个字段名在一个节中只出现一次时，该字段的组合“字段值”由相应的字段行值组成。当一个字段名在一个节中重复时，它的组合字段值由该节中相应的字段行值列表组成，按顺序连接，每个字段行值用逗号分隔。

例如，这一节:

```
Example-Field: Foo, Bar
Example-Field: Baz
```

包含两个字段行，字段名都是“Example-Field”。第一个字段行值为“Foo, Bar”，而第二个字段行值为“Baz”。Example-Field 的字段值是列表“Foo, Bar, Baz”。

### 5.3. Field Order

接收方可以将字段段内具有相同字段名的多个字段行合并到一个字段行中，而不改变消息的语义，方法是将每个后续字段行值按顺序附加到初始字段行值，用逗号(“，”)和可选的空白符(OWS，定义于章节5.6.3)分隔。为了保持一致性，请使用逗号 SP。

因此，接收具有相同名称的字段行的顺序对于字段值的解释很重要;代理在转发消息时绝对不能改变这些字段行值的顺序。

这意味着,除了著名的例外下面提到的,发送者不能生成多个具有相同名称的电场线的一条消息中(无论是在标题或预告片)或附加字段线当一个字段已经存在相同名称的信息,除非该字段的定义允许多个字段行被重组为一个以逗号分隔值(也就是说,至少有一个替代字段定义允许一个逗号分隔的列表,例如在章节5.6.1中定义的#(值)的ABNF规则)。

> 注意:在实际操作中，“Set-Cookie”报头字段([COOKIE])经常跨多个字段行出现在响应消息中，并且不使用列表语法，违反了上述对多个字段行具有相同字段名的要求。由于它不能组合成一个单独的字段值，收件人在处理字段时应该把“Set-Cookie”作为一个特殊情况来处理。(详见[Kri2001]附录A.2.3。)

在一个节中接收具有不同字段名的字段行的顺序并不重要。但是，最好先发送包含额外控制数据的报头字段，例如请求上的 Host 和响应上的 Date，这样实现就可以尽早决定什么时候不处理消息。

服务器在收到完整的请求头部分之前绝对不能向目标资源应用请求，因为后面的头字段行可能包括条件、身份验证凭据或故意误导的重复头字段，这些可能会影响请求处理。

### 5.4. Field Limits

HTTP 不会对每个字段行、字段值的长度或头或尾部分的长度进行预定义限制，如第2节所述。在实践中可以发现对单个长度的各种临时限制，通常取决于特定字段的语义。

服务器接收到一个请求头字段行、字段值或一组大于它希望处理的字段时，必须响应一个适当的 4xx(客户端错误)状态码。忽略这样的报头字段会增加服务器对请求走私攻击的脆弱性([HTTP/1.1]第11.2节)。

如果字段语义可以在不改变消息帧或响应语义的情况下安全忽略所丢弃的值，则客户端可以丢弃或截断接收到的比客户端希望处理的字段行大的字段行。

### 5.5. Field Values

HTTP 字段值由字段语法定义的格式的字符序列组成。每个字段的语法通常使用ABNF ([RFC5234])定义。

```
  field-value    = *field-content
  field-content  = field-vchar
                   [ 1*( SP / HTAB / field-vchar ) field-vchar ]
  field-vchar    = VCHAR / obs-text
  obs-text       = %x80-FF
```

字段值不包括前导或尾随空格。当特定版本的 HTTP 允许在消息中出现此类空白时，字段解析实现必须在计算字段值之前排除此类空白。

字段值通常被限制为 US-ASCII 字符的范围[USASCII]。需要更大范围字符的字段可以使用一种编码，例如[RFC8187]中定义的编码。历史上，HTTP 允许包含 ISO-8859-1 字符集[ISO-8859-1]文本的字段内容，仅通过使用[RFC2047]编码支持其他字符集。新定义字段的规范应该将其值限制为可见的 US-ASCII字节(VCHAR)、SP 和 HTAB。接收方应该将字段内容中其他允许的八字节(即obs-text)视为不透明数据。

包含 CR、LF 或 NUL 字符的字段值是无效和危险的，因为实现可能以不同的方式解析和解释这些字符;字段值中的 CR、LF 或 NUL 的接收者必须在进一步处理或转发该消息之前，要么拒绝该消息，要么用SP替换这些字符。包含其他CTL字符的字段值也是无效的;然而，当这些字符出现在一个安全的上下文中(例如，一个应用程序特定的带引号的字符串，不会被任何下游HTTP解析器处理)，出于健壮性的考虑，接收方可以保留这些字符。

只期望一个成员作为字段值的字段称为“单例字段”。

允许多个成员作为字段值的字段被称为“基于列表的字段”。第5.6.1节的列表操作符扩展被用作定义可以包含多个成员的字段值的通用符号。

因为逗号(“，”)被用作成员之间的分隔符，所以如果允许它们作为成员中的数据，则需要小心对待它们。对于基于列表的字段和单例字段都是如此，因为单例字段可能会错误地发送多个成员，检测此类错误可以提高互操作性。希望在成员中包含逗号的字段，例如在 HTTP-date 或 URI-reference 元素中，应该在该元素周围定义分隔符，以区分该数据中的任何逗号与潜在的列表分隔符。

例如，文本日期和URI(其中任何一个都可能包含逗号)可以安全地包含在基于列表的字段值中，如下所示:

```
Example-URIs: "http://example.com/a.html,foo",
              "http://without-a-comma.example.com/"
Example-Dates: "Sat, 04 May 1996", "Wed, 14 Sep 2005"
```

注意，双引号分隔符几乎总是用于带引号的字符串(第5.6.4节);在双引号内使用不同的语法可能会引起不必要的混淆。

许多字段(如Content-Type，在章节8.3中定义)使用一种通用的参数语法，允许参数值使用不带引号(token)和带引号(quote-string)语法(章节5.6.6)。使用通用语法允许接收者重用现有的解析器组件。当允许两种形式时，参数值的含义应该是相同的，无论它是作为一个标记还是一个带引号的字符串接收。

> 注意:为了定义字段值语法，本规范使用一个以字段名命名的 ABNF 规则来定义该字段值的允许语法(在从底层消息传递语法中提取该值并将多个实例组合到一个列表之后)。

### 5.6. Common Rules for Defining Field Values

#### 5.6.1. Lists (#rule ABNF Extension)

对 [RFC5234] 的 ABNF 规则的 #rule 扩展用于提高一些基于列表的字段值定义的可读性。

定义了一个结构 “#”，类似于 “*”，用于定义以逗号分隔的元素列表。完整形式为 "<n>#<m>element"，表示至少<n>，最多<m>元素，每个元素由单个逗号(",")和可选的空格(OWS，定义于章节5.6.3)分隔。

##### 5.6.1.1. Sender Requirements

在任何使用列表结构的产品中，发送方绝对不能生成空列表元素。换句话说，发送方必须生成满足以下语法的列表:

```
  1#element => element *( OWS "," OWS element )
```

或者

```
  #element => [ 1#element ]
```
对于 n >= 1 并且 m > 1:

```
  <n>#<m>element => element <n-1>*<m-1>( OWS "," OWS element )
```

附录 A 显示了列表结构展开后为发送者收集的 ABNF。

##### 5.6.1.2. Recipient Requirements

空元素不影响当前元素的计数。接收方必须解析并忽略合理数量的空列表元素:足够处理发送方合并值时的常见错误，但又不能过多到可以用作拒绝服务机制的程度。换句话说，接收方必须接受满足以下语法的列表:

```
  #element => [ element ] *( OWS "," OWS [ element ] )
```

请注意，由于可能存在空列表元素，RFC 5234 ABNF不能强制列表元素的基数，因此所有情况的映射就像没有指定基数一样。

例如，给定这些 ABNF 结果:

```
  example-list      = 1#example-list-elmt
  example-list-elmt = token ; see Section 5.6.2
```

下面是 example-list 的有效值(不包括双引号，双引号仅用于定界):

```
  "foo,bar"
  "foo ,bar,"
  "foo , ,bar,charlie"
```

相反，以下值将无效，因为示例列表生成至少需要一个非空元素:

```
  ""
  ","
  ",   ,"
```

#### 5.6.2. Tokens

令牌是不包括空格或分隔符的短文本标识符。

```
  token          = 1*tchar

  tchar          = "!" / "#" / "$" / "%" / "&" / "'" / "*"
                 / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
                 / DIGIT / ALPHA
                 ; any VCHAR, except delimiters
```

许多 HTTP 字段值是使用通用语法组件定义的，由空格或特定的分隔字符分隔。分隔符从令牌中不允许的 US-ASCII 可视字符集中选择 (DQUOTE 和 "()，/:;<=>?@[\]{}")。

#### 5.6.3. Whitespace

该规范使用三个规则来表示线性空白的使用: OWS(可选空白)、RWS(必需空白) 和 BWS(“坏”空白)。

OWS 规则用于可能出现零个或多个线性空白八位字节的地方。对于协议元素，可选的空白是为了提高可读性，发送方应该生成可选的空白作为单个 SP; 否则，发送方不应该生成可选的空白，除非在消息过滤过程中需要覆盖无效或不需要的协议元素。

当至少需要一个线性空白字节来分隔字段令牌时，使用 RWS 规则。发送方应该将 RWS 生成为单个 SP。

OWS 和 RWS 与单个 SP 具有相同的语义。任何已知定义为 OWS 或 RWS 的内容都可以在解释或向下游转发消息之前被单个 SP 替换。

BWS 规则用于仅由于历史原因而允许可选空格的语法。发送方绝对不能在消息中生成 BWS。在解释协议元素之前，接收方必须解析这种糟糕的空白并将其删除。

BWS 没有语义。任何已知定义为 BWS 的内容都可以在解释它或向下游转发消息之前删除。

```
  OWS            = *( SP / HTAB )
                 ; optional whitespace
  RWS            = 1*( SP / HTAB )
                 ; required whitespace
  BWS            = OWS
                 ; "bad" whitespace
```

#### 5.6.4. Quoted Strings

如果使用双引号引用文本字符串，则将其解析为单个值。

```
  quoted-string  = DQUOTE *( qdtext / quoted-pair ) DQUOTE
  qdtext         = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text
```

反斜杠("\")可以在引用字符串和注释结构中用作单字节引用机制。处理带引号字符串值的接收方必须处理带引号对，就像它被反斜杠后面的字节所取代一样。

```
  quoted-pair    = "\" ( HTAB / SP / VCHAR / obs-text )
```
发送方不应该在带引号的字符串中生成带引号对，除非需要在该字符串中引用 DQUOTE 和 反斜杠字节。发送方不应该在注释中生成引号对，除非需要引用括号["("和")]以及注释中出现的反斜杠字节。

#### 5.6.5. Comments

注释可以通过用圆括号括起注释文本来包含在某些 HTTP 字段中。注释只允许在字段值定义中包含 “comment” 的字段中使用。

```
  comment        = "(" *( ctext / quoted-pair / comment ) ")"
  ctext          = HTAB / SP / %x21-27 / %x2A-5B / %x5D-7E / obs-text
```

#### 5.6.6. Parameters

参数是名称/值对的实例;它们通常用于字段值中，作为向项附加辅助信息的通用语法。每个参数通常由紧接在前面的分号分隔。

```
  parameters      = *( OWS ";" OWS [ parameter ] )
  parameter       = parameter-name "=" parameter-value
  parameter-name  = token
  parameter-value = ( token / quoted-string )
```
参数名称不区分大小写。参数值可能区分大小写，也可能不区分大小写，这取决于参数名称的语义。参数和一些等效形式的例子可以在媒体类型(章节8.3.1)和Accept报头字段(章节12.5.1)中看到。

与生成的令牌匹配的参数值可以作为令牌传输，也可以在引号字符串中传输。加引号和不加引号的值是等价的。

> 注意:参数不允许 “=” 字符周围有空格(甚至是“坏”空格)。

#### 5.6.7. Date/Time Formats

在 1995 年之前，服务器通常使用三种不同的格式来通信时间戳。为了与旧的实现兼容，这里定义了这三个实现。首选格式是 Internet 消息格式 [RFC5322] 使用的日期和时间规范的固定长度和单区域子集。

```
  HTTP-date    = IMF-fixdate / obs-date
```

一个首选格式的例子:

```
  Sun, 06 Nov 1994 08:49:37 GMT    ; IMF-fixdate
```

两种过时格式的例子:

```
  Sunday, 06-Nov-94 08:49:37 GMT   ; obsolete RFC 850 format
  Sun Nov  6 08:49:37 1994         ; ANSI C's asctime() format
```

解析 HTTP 字段中的时间戳值的接收方必须接受所有三种 HTTP-date 格式。当发送方生成一个包含一个或多个定义为 HTTP-date 的时间戳的字段时，发送方必须以 IMF-fixdate 格式生成这些时间戳。

HTTP-date 值将时间表示为协调世界时(UTC)的一个实例。前两种格式用格林尼治标准时间的三个字母缩写 “GMT” 表示 UTC，这是 UTC 名称的前身; asctime 格式的值被假定为 UTC。

“时钟” 是一种能够提供合理的 UTC 当前时刻近似值的实现。时钟实现应该使用 NTP ([RFC5905]) 或一些类似的协议来与 UTC 同步。

首选格式：

```
  IMF-fixdate  = day-name "," SP date1 SP time-of-day SP GMT
  ; fixed length/zone/capitalization subset of the format
  ; see Section 3.3 of [RFC5322]

  day-name     = %s"Mon" / %s"Tue" / %s"Wed"
               / %s"Thu" / %s"Fri" / %s"Sat" / %s"Sun"

  date1        = day SP month SP year
               ; e.g., 02 Jun 1982

  day          = 2DIGIT
  month        = %s"Jan" / %s"Feb" / %s"Mar" / %s"Apr"
               / %s"May" / %s"Jun" / %s"Jul" / %s"Aug"
               / %s"Sep" / %s"Oct" / %s"Nov" / %s"Dec"
  year         = 4DIGIT

  GMT          = %s"GMT"

  time-of-day  = hour ":" minute ":" second
               ; 00:00:00 - 23:59:60 (leap second)

  hour         = 2DIGIT
  minute       = 2DIGIT
  second       = 2DIGIT

```

过时的格式：

```
  obs-date     = rfc850-date / asctime-date
```

```
  rfc850-date  = day-name-l "," SP date2 SP time-of-day SP GMT
  date2        = day "-" month "-" 2DIGIT
               ; e.g., 02-Jun-82

  day-name-l   = %s"Monday" / %s"Tuesday" / %s"Wednesday"
               / %s"Thursday" / %s"Friday" / %s"Saturday"
               / %s"Sunday"
```

```
  asctime-date = day-name SP date3 SP time-of-day SP year
  date3        = month SP ( 2DIGIT / ( SP 1DIGIT ))
               ; e.g., Jun  2
```

HTTP-date 区分大小写。注意，[CACHING] 的 4.2 节对缓存接收者放宽了限制。

发送方绝对不能在 HTTP-date 中生成除语法中明确包含的 SP 之外的额外空白。日-名称、日、月、年和时间的语义与具有相应名称的 Internet Message Format 构造的语义相同([RFC5322]，章节 3.3)。

接收到 rfc850-date 格式的时间戳值(使用两位数年份)的接收者必须将看起来超过 50 年的时间戳解释为表示过去最近的年份，并且具有相同的后两位数字。

除非字段定义另有限制，否则鼓励时间戳值的接收者健壮地解析时间戳。例如，消息有时会通过 HTTP 从非 HTTP 源转发，该源可能生成 Internet 消息格式定义的任何日期和时间规范。

> 注意:HTTP 对时间戳格式的要求只适用于它们在协议流中的使用。实现不需要在用户表示、请求日志记录等方面使用这些格式。

## 6. Message Abstraction

HTTP 的每个主要版本都定义了自己的通信语法。本节基于这些消息特征、公共结构和传递语义的能力的泛化，为 HTTP 消息定义了一个抽象数据类型。此抽象用于定义独立于 HTTP 版本的发送方和接收方的需求，以便一个版本的消息可以在不改变其含义的情况下通过其他版本进行转发。

一个“消息”由以下部分组成:

- 控制数据来描述和路由消息；
- 一个名称/值对的头查找表，用于扩展控制数据并传递关于发送者、消息、内容或上下文的附加信息；
- 一个潜在的无限内容流；
- 一个名称/值对的 trailer 查找表，用于通信在发送内容时获得的信息；

首先发送帧(Framing)和控制数据，然后是包含 headers 表字段的 header 部分。当消息包含内容时，内容将在header部分之后发送，可能随后是一个 trailer 部分，其中可能包含预告片表的字段。

消息被期望作为流进行处理，其中流的目的及其继续处理在读取时显示出来。因此，控制数据描述了接收者需要立即知道的内容，首部字段描述了在接收内容之前需要知道的内容，内容(在存在时)可能包含接收者想要或需要实现消息语义的内容，而 trailer 字段提供了在发送内容之前未知的可选元数据。

消息的目的是“自描述”:在解码或重组传输中被压缩或省略的部分后，接收者需要知道的关于消息的一切都可以通过查看消息本身来确定，而不需要了解发送者当前的应用程序状态(通过之前的消息建立)。然而，客户端必须在解析、解释或缓存相应的响应时保留请求的信息。例如，HEAD 方法的响应看起来就像 GET 响应的开头，但不能以相同的方式解析。

请注意，这种消息抽象是跨多个 HTTP 版本的泛化，包括某些版本可能没有的功能。例如，trailer 字段是在 HTTP/1.1 分块传输编码中引入的，作为内容之后的附加部分。在 HTTP/2 和 HTTP/3 中，终止每个流的首部块中也存在一个等效的特性。

### 6.1. Framing and Completeness

消息分帧指示每个消息如何开始和结束，以便将每个消息与同一连接上的其他消息或噪声区分开来。HTTP 的每个主要版本都定义了自己的分帧机制。

HTTP/0.9 和 HTTP/1.0 的早期部署使用了关闭底层连接来结束响应。为了向后兼容，HTTP/1.1 也允许这种隐式分帧。然而，如果连接提前关闭，隐式分帧可能无法区分不完整的响应。因此，几乎所有现代实现都以长度定界的消息数据序列的形式使用显式分帧。

当一个消息的帧表示的所有字节都可用时，该消息被认为是“完成的”。请注意，如果没有显式使用分帧，则底层连接关闭后结束的响应消息被认为是完整的，即使它可能与不完整的响应无法区分，除非传输层错误表明它不完整。

### 6.2. Control Data

消息以描述其主要用途的控制数据开始。请求消息控制数据包括请求方法(第 9 节)、请求目标(第 7.1 节)和协议版本(第 2.5 节)。响应消息控制数据包括状态码(第 15 节)、可选原因短语和协议版本。

在 HTTP/1.1 ([HTTP/1.1]) 及更早版本中，控制数据作为消息的第一行发送。在 HTTP/2 ([HTTP/2]) 和 HTTP/3 ([HTTP/3]) 中，控制数据以带有 保留名称前缀 的 伪首部字段 形式发送(例如，":authority")。

每个 HTTP 消息都有一个协议版本。根据使用的版本，它可以在消息中明确标识，也可以由接收消息的连接推断。接收方使用该版本信息来确定日后与该发送方通信的限制或潜力。

当消息被一个中介转发时，协议版本被更新以反映该中介使用的版本。Via 头字段(章节 7.6.3 )用于在转发的消息中通信上游协议信息。

客户端发送的请求版本应该等于符合要求的最高版本，且主版本不高于服务器支持的最高版本(前提是知道这一点)。客户端不能发送不符合的版本。

如果客户端知道服务器没有正确地实现 HTTP 规范，则可以发送低版本的请求。但只有在客户端尝试了至少一个正常的请求，并从响应状态码或首部字段(例如 server )中确定服务器没有正确地处理高版本的请求之后，才会发送低版本的请求。

服务器发送的响应版本应该等于与服务器一致的最高版本，且主版本小于或等于请求中接收到的版本。服务器不能发送与之不一致的版本。如果服务器出于任何原因希望拒绝客户端主要协议版本的服务，则可以发送 505 (HTTP Version Not Supported) 响应。

接收到具有其实现的主版本号和高于其实现的次版本号的消息的收件人应该处理该消息，就好像该消息属于该收件人符合的主版本中最高的次版本一样。当发送给尚未表示支持更高版本的接收方时，接收方可以假定具有更高次版本的消息具有足够的向后兼容性，可以由相同主版本的任何实现安全地处理。

### 6.3. Header Fields

在内容之前发送或接收的字段(第5节)称为 “报头字段” (通俗地说，就是“报头”)。

消息的“标题部分”由一系列标题字段行组成。每个头字段可以修改或扩展消息语义、描述发送者、定义内容或提供额外的上下文。

> 注意:当命名字段只允许在 header 部分发送时，我们将其特别称为 “header 字段”。

### 6.4. Content

HTTP 消息通常以消息“内容”的形式传输完整或部分表示:由字节组成的流，在消息的首部部分之后发送，由消息帧描述。

内容的抽象定义反映了从消息框架中提取出来的数据。例如，一个HTTP/1.1 消息体([HTTP/1.1]第 6 节) 可能包含一个用分块传输编码编码的数据流，一个数据块序列，一个零长度的块和一个 trailer 字段，而同一消息的内容只包括传输编码解码后的数据流;它不包括块长度、分块分帧语法，也不包括 trailer 字段(第6.5节)。

注意:有些字段名有 "Content-" 前缀。这是一个非正式的惯例；正如上文定义的，其中一些字段引用消息的内容，而其他字段则仅限于所选择的表示形式(第 3.2 节)。请参阅各个字段的定义以消除歧义。

#### 6.4.1. Content Semantics

请求内容的目的由方法语义(第9节)定义。

例如，PUT 请求内容中的表示(章节 9.3.4)表示成功应用请求后目标资源的期望状态，而 POST 请求内容中的表示(章节9.3.3)表示目标资源要处理的信息。

在响应中，内容的用途由请求方法、响应状态码(第15节)和描述该内容的响应字段定义。例如，对 GET 的 200 (OK) 响应的内容(章节 9.3.1)表示在消息发起日期时观察到的目标资源的当前状态(章节 6.6.1)，而对 POST 的响应中的相同状态码的内容可能表示处理结果或应用处理后目标资源的新状态。

要获取的 206(Partial Content) 响应的内容要么包含所选表示的单个部分，要么包含该表示的多个部分的多部分消息体，如 15.3.7 节所述。

带有错误状态码的响应消息通常包含表示错误条件的内容，这样内容就描述了错误状态和解决错误的建议步骤。

对 HEAD 请求方法的响应(章节9.3.2)从不包含内容；相关的响应头字段只表明如果请求方法是 GET(章节9.3.1)，它们的值会是什么。

2xx(Successful) 响应对应 CONNECT 请求，将连接切换到隧道模式。

所有 1xx (Informational)、204(No content) 和 304(Not Modified) 响应都不包含内容。

所有其他响应都包含内容，尽管该内容的长度可能为 0。

#### 6.4.2. Identifying Content

当完整或部分表示作为消息内容传输时，通常希望发送方提供或接收方确定与该特定表示相对应的资源的标识符。例如，客户端向资源发出 GET 请求，请求 “当前天气报告”，可能需要一个特定于返回内容的标识符(例如，“拉古纳海滩 20210720T1711 的天气报告”)。这对于共享或标记资源内容很有用，这些资源的表示形式预计会随着时间的推移而变化。

对于请求消息:

- 如果请求有 Content-Location 头字段，那么发送方断言内容是由 Content-Location 字段值标识的资源的表示。但是，这样的断言是不可信的，除非它可以通过其他方法进行验证(本规范没有定义)。这些信息对于修订历史链接可能仍然有用。
- 否则，内容将无法被 HTTP 识别，但内容本身可能提供更具体的标识符。

对于响应消息，按顺序应用以下规则，直到找到匹配项:

1. 如果请求方法为 HEAD，或者响应状态码为 204(No Content) 或 304(Not Modified)，则响应中没有内容。
2. 如果请求方法是 GET，响应状态码是 200 (OK)，则内容是目标资源的表示(章节 7.1)。
3. 如果请求方法是 GET，响应状态码是 203(Non-Authoritative)，则内容是由中介提供的目标资源的潜在修改或增强表示。
4. 如果请求方法是 GET，响应状态码是 206(Partial content)，则内容是目标资源表示的一个或多个部分。
5. 如果响应具有 Content-Location 头字段，并且其字段值是对与目标 URI 相同的 URI 的引用，则内容是目标资源的表示。
6. 如果响应有一个 Content-Location 头字段，并且它的字段值是对一个不同于目标 URI 的 URI 的引用，那么发送方断言内容是由 Content-Location 字段值标识的资源的表示。但是，这样的断言是不可信的，除非它可以通过其他方法进行验证(本规范没有定义)。
7. 否则，内容将无法被 HTTP 识别，但内容本身可能提供更具体的标识符。

### 6.5. Trailer Fields

位于 trailer seciton 中的字段(第5节)被称为 "trailer fields"(通俗地说，就是 “trailers”)。trailer 字段对于提供消息完整性检查、数字签名、交付度量或后处理状态信息非常有用。

Trailer 字段应该与 header 部分的字段分开处理和存储，以避免在 header 部分完成时已知的消息语义相互矛盾。某些首部字段的存在或缺失可能会影响在接收到 trailer fields 之前对整个消息进行路由或处理的选择；这些选择不能被后来发现的 trailer 字段所撤销。

#### 6.5.1. Limitations on Use of Trailers

只有在当前使用的 HTTP 版本支持并通过显式分帧机制启用的情况下，才可能出现 trailer 字段。例如，HTTP/1.1 中的分块传输编码允许在内容之后发送 trailer 字段 ([HTTP/1.1]的 7.1.2 节)。

许多字段不能在首部部分之外处理，因为在接收内容之前必须对它们进行评估，例如那些描述消息分帧、路由、身份验证、请求修饰符、响应控制或内容格式的字段。发送方必须不生成 trailer 字段，除非发送方知道相应的头字段名称的定义允许该字段以 trailer形式发送。

trailer 字段很难被从一个协议版本转发到另一个协议版本的中介体处理。如果在传输过程中可以缓冲整个消息，一些中间设备可以在转发消息之前将 trailer 字段合并到 header 部分(视情况而定)。然而，在大多数情况下，trailer 会被直接丢弃。除非收件人理解相应的头字段定义，并且该定义明确允许并定义如何安全地合并 trailer 字段值，否则不得将 trailer 字段合并到头部分。

关键字 "trailers" 出现在一个请求的 TE 头字段(章节10.1.4)中，表明客户端愿意接受 trailer 字段，代表自己和任何下游客户。对于来自中介体的请求，这意味着所有下游客户端都愿意接受转发的响应中的 trailer 字段。注意，"trailers" 的存在并不意味着客户端会处理响应中任何特定的 trailer 字段；只有 trailer 部分不会被任何客户端删除。

因为 trailer 字段可能会在传输过程中被丢弃，所以服务器不应该生成它认为用户代理需要接收的 trailer 字段。

#### 6.5.2. Processing Trailer Fields

可以发送 "Trailer" 头字段(章节6.6.2)来表示可能在 Trailer 部分发送的字段，这允许接收方在处理内容之前准备接收。例如，如果字段名表明在接收到内容时应该计算动态校验和，然后在收到 trailer 字段值后立即检查，那么这可能很有用。

与头字段一样，具有相同名称的 trailer 字段按照接收到的顺序进行处理;具有相同名称的多个 trailer 字段行具有等价于将多个值附加为成员列表的语义。即使每个成员值在接收到的字段行中只处理一次，也必须将在消息期间可能生成多次的尾部字段定义为基于列表的字段。

在消息的结尾，收件人可以将接收到的 trailer 字段集视为名称/值对的数据结构，类似于(分离的)首部字段。额外的处理期望，如果有，可以在字段规范中定义用于 trailer 字段。

### 6.6. Message Metadata

描述消息本身的字段，例如消息是何时以及如何生成的，可以出现在请求和响应中。

#### 6.6.1. Date

"Date" 报头字段表示消息产生的日期和时间，与 [RFC5322] 节 3.6.1 中定义的起源日期字段(orig-date)具有相同的语义。该字段的值是 HTTP-date 类型，定义在 5.6.7 节中。

```
  Date = HTTP-date
```
示例：

```
Date: Tue, 15 Nov 1994 08:12:31 GMT
```

生成日期头字段的发送方应将其字段值生成为生成消息的日期和时间的最佳近似值。理论上，日期应该表示生成消息内容之前的时刻。实际上，发送者可以在消息发起过程中的任何时间生成日期值。

带有时钟的源服务器(如 5.6.7 节所定义)必须在所有 2xx(Successful)、3xx(Redirection) 和 4xx(Client Error) 响应中生成一个日期头字段，并且可能在 1xx(Informational) 和 5xx(Server Error) 响应中生成一个日期头字段。

没有时钟的源服务器不能生成日期头字段。

具有时钟的接收方在接收没有日期头字段的响应消息时，必须记录接收到的时间，如果消息被缓存或转发到下游，则将相应的日期头字段附加到消息的头部分。

具有时钟的收件人在收到具有无效日期头字段值的响应时，可以将该值替换为接收响应的时间。

用户代理可以在请求中发送日期头字段，但通常不会这样做，除非它被认为可以向服务器传递有用的信息。例如，如果希望服务器根据用户代理和服务器时钟之间的差异调整其对用户请求的解释，自定义HTTP应用程序可能会传递一个日期。

#### 6.6.2. Trailer

"Trailer" 报头字段提供了一个字段名称列表，发送方希望在该消息中作为 trailer 字段发送。这允许接收方在开始处理内容之前准备接收指定的元数据。

```
  Trailer = #field-name
```
例如，发送者可能表示将在流式内容时计算签名，并以 trailer 字段的形式提供最终签名。这允许接收方在接收内容时执行相同的检查。

打算在消息中生成一个或多个 trailer 字段的发送者应该在该消息的 header 部分生成一个 trailer 头字段，以指示哪些字段可能出现在预告片中。

如果一个中介体在传输过程中丢弃了 trailer 部分，那么 trailer 字段可以提供元数据丢失的提示，尽管不能保证 trailer 的发送方总是会发送命名字段。

## 7. Routing HTTP Messages

HTTP 请求消息路由由每个客户机根据目标资源、客户机的代理配置和入站连接的建立或重用确定。对应的响应路由遵循相同的连接链返回客户端。

### 7.1. Determining the Target Resource

虽然很多应用程序都使用 HTTP，但大多数客户端依赖与通用 Web 浏览器相同的资源标识机制和配置技术。即使通信选项硬编码在客户端配置中，我们也可以把它们组合起来的效果看作 URI 引用(4.1节)。

URI 引用被解析为其绝对形式，以便获得“目标 URI”。目标 URI排除引用的片段组件(如果有的话)，因为片段标识符是为客户端处理保留的([URI]，第3.5节)。

要对“目标资源”执行操作，客户端发送一个请求消息，其中包含其已解析的目标 URI 的足够组件，以使接收者能够识别相同的资源。由于历史原因，解析后的目标 URI 组件，合称“请求目标”，在消息控制数据和主机首部字段中发送(章节7.2)。

有两种不常见的情况，请求目标组件是特定于方法的形式。

- 对于 CONNECT (章节 9.3.6)，请求目标是隧道目的端的主机名和端口号，用冒号分隔。
- 对于 OPTIONS (章节9.3.7)，请求目标可以是一个星号(“*”)。

有关详细信息，请参阅相应的方法定义。这些表单不能与其他方法一起使用。

在收到客户端请求后，服务器根据接收到的组件的本地配置和传入的连接上下文重构目标 URI。这种重构是每个主协议版本特有的。例如，[HTTP/1.1] 的 3.3 节定义了服务器如何确定 HTTP/1.1 请求的目标 URI。

> 注意:以前的规范将重新组合的目标 URI 定义为一个不同的概念，即“有效请求URI”。

### 7.2. Host and :authority

请求中的 "Host" 头字段提供来自目标 URI 的主机和端口信息，使源服务器在为多个主机名的请求提供服务时能够区分资源。

在 HTTP/2 [HTTP/2] 和 HTTP/3 [HTTP/3] 中，Host 报头字段在某些情况下被请求控制数据的 ":authority" 伪报头字段所取代。

```
  Host = uri-host [ ":" port ] ; Section 4
```

目标 URI 的权限信息对于处理请求非常重要。用户代理必须在请求中生成 Host 报头字段，除非它以 ":authority" 伪报头字段的形式发送该信息。发送 Host 的用户代理应该将它作为请求头部分的第一个字段发送。

例如，对源服务器 <http://www.example.org/pub/WWW/> 的 GET 请求将以以下方式开始:

```
GET /pub/WWW/ HTTP/1.1
Host: www.example.org
```

由于主机和端口信息扮演着应用层路由机制的角色，它经常成为恶意软件的攻击目标，试图毒害共享缓存或将请求重定向到非预期的服务器。如果拦截代理依赖主机和端口信息将请求重定向到内部服务器，或者用作共享缓存中的缓存键，而没有首先验证被拦截的连接是否针对该主机的有效 IP 地址，那么它特别容易受到攻击。

### 7.3. Routing Inbound Requests

#### 7.3.1. To a Cache

#### 7.3.2. To a Proxy

#### 7.3.3. To the Origin

### 7.4. Rejecting Misdirected Requests

### 7.5. Response Correlation

### 7.6. Message Forwarding

#### 7.6.1. Connection

#### 7.6.2. Max-Forwards

#### 7.6.3. Via

### 7.7. Message Transformations

### 7.8. Upgrade

## 8. Representation Data and Metadata

### 8.1. Representation Data

### 8.2. Representation Metadata

### 8.3. Content-Type

#### 8.3.1. Media Type

#### 8.3.2. Charset

#### 8.3.3. Multipart Types

### 8.4. Content-Encoding

#### 8.4.1. Content Codings

##### 8.4.1.1. Compress Coding

##### 8.4.1.2. Deflate Coding

##### 8.4.1.3. Gzip Coding

### 8.5. Content-Language

#### 8.5.1. Language Tags

### 8.6. Content-Length

### 8.7. Content-Location

### 8.8. Validator Fields

#### 8.8.1. Weak versus Strong

#### 8.8.2. Last-Modified

##### 8.8.2.1. Generation

##### 8.8.2.2. Comparison

#### 8.8.3. ETag

##### 8.8.3.1. Generation

##### 8.8.3.2. Comparison

##### 8.8.3.3. Example: Entity Tags Varying on Content-Negotiated Resources

## 9. Methods

### 9.1. Overview

### 9.2. Common Method Properties

#### 9.2.1. Safe Methods

#### 9.2.2. Idempotent Methods

#### 9.2.3. Methods and Caching

### 9.3. Method Definitions

#### 9.3.1. GET

#### 9.3.2. HEAD

#### 9.3.3. POST

#### 9.3.4. PUT

#### 9.3.5. DELETE

#### 9.3.6. CONNECT

#### 9.3.7. OPTIONS

#### 9.3.8. TRACE

## 10. Message Context

### 10.1. Request Context Fields

#### 10.1.1. Expect

#### 10.1.2. From

#### 10.1.3. Referer

#### 10.1.4. TE

#### 10.1.5. User-Agent

### 10.2. Response Context Fields

#### 10.2.1. Allow

#### 10.2.2. Location

#### 10.2.3. Retry-After

#### 10.2.4. Server

### 11. HTTP Authentication

#### 11.1. Authentication Scheme

#### 11.2. Authentication Parameters

#### 11.3. Challenge and Response

#### 11.4. Credentials

#### 11.5. Establishing a Protection Space (Realm)

#### 11.6. Authenticating Users to Origin Servers

##### 11.6.1. WWW-Authenticate

##### 11.6.2. Authorzation

##### 11.6.3. Authentication-Info

#### 11.7. Authencating Clients to Proxies

##### 11.7.1. Proxy-Authenticate

##### 11.7.2. Proxy-Authorization

##### 11.7.3. Proxy-Authentication-Info

## 12. Content Negotiation

### 12.1. Proactive Negotiation

### 12.2. Reactive Negotiation

### 12.3. Request Content Negotiation

### 12.4. Content Negotitation Field Features

#### 12.4.1. Absence

#### 12.4.2. Quality Values

#### 12.4.3. Wildcard Values

### 12.5. Content Negotiation Fields

#### 12.5.1. Accept

#### 12.5.2. Accept-Charset

#### 12.5.3. Accept-Encoding

#### 12.5.4. Accept-Language

#### 12.5.5. Vary

## 13. Conditional Requests

### 13.1. Preconditions

#### 13.1.1. If-Match

#### 13.1.2. If-None-Match

#### 13.1.3. If-Modified-Since

#### 13.1.4. If-Unmodified-Since

#### 13.1.5. If-Range

## 14. Range Requests

### 14.1. Range Units

#### 14.1.1. Range Specifiers

#### 14.1.2. Byte Ranges

### 14.2. Range

### 14.3. Accept-Ranges

### 14.4. Content-Range

### 14.5. Partial PUT

### 14.6. Media Type multipart/byteranges

## 15. Status Codes

### 15.1. Overview of Status Codes

### 15.2. Infomational 1xx

#### 15.2.1. 100 Continue

#### 15.2.2. 101 Switching Protocols

### 15.3. Successful 2xx

#### 15.3.1. 200 OK

#### 15.3.2. 201 Created

#### 15.3.3. 202 Accepted

#### 15.3.4. 203 Non-Authoritative Information

#### 15.3.5. 204 No Content

#### 15.3.6. 205 Reset Content

#### 15.3.7. 206 Partial Content

##### 15.3.7.1. Single Part

##### 15.3.7.2. Multiple Parts

##### 15.3.7.3. Combining Parts

### 15.4. Redirection 3xx

#### 15.4.1. 300 Multiple Choices

#### 15.4.2. 301 Moved Permanently

#### 15.4.3. 302 Found

#### 15.4.4. 303 See Other

#### 15.4.5. 304 Not Modified

#### 15.4.6. 305 Use Proxy

#### 15.4.7. 306 (Unused)

#### 15.4.8. 307 Temporary Redirect

#### 15.4.9. 308 Permanent Redirect

### 15.5. Client Error 4xx

#### 15.5.1 400 Bad Request

#### 15.5.2 401 Unauthorized

#### 15.5.3 402 Payment Required

#### 15.5.4 403 Forbidden

#### 15.5.5 404 Not Found

#### 15.5.6 405 Method Not Allowed

#### 15.5.7 406 Not Acceptable

#### 15.5.8 407 Proxy Authentication Required

#### 15.5.9 408 Request Timeout

#### 15.5.10 409 Conflict

#### 15.5.11 410 Gone

#### 15.5.12 411 Length Required

#### 15.5.13 412 Precondition Failed

#### 15.5.14 413 Content Too Large

#### 15.5.15 414 URI Too Long

#### 15.5.16 415 Unsupported Media Type

#### 15.5.17 416 Range Not Satisfiable

#### 15.5.18 417 Expectation Failed

#### 15.5.19 418 (Unused)

#### 15.5.20 421 Misdirected Request

#### 15.5.21 422 Unprocessalbe Content

#### 15.5.22 426 Upgrade Required

### 15.6. Server Error 5xx

#### 15.6.1. 500 Internal Server Error

#### 15.6.2. 501 Not Implemented

#### 16.6.3. 502 Bad Gateway

#### 16.6.4. 503 Service Unavailable

#### 16.6.5. 504 Gateway Timeout

#### 16.6.6. 505 HTTP Version Not Supported

## 16. Extending HTTP

### 16.1. Method Extensibility

#### 16.1.1. Method Registry

#### 16.1.2. Considerations for New Methods

### 16.2. Status Code Extensibility

#### 16.2.1. Status Code Registry

#### 16.2.2. Considerations for New Status codes

### 16.3. Field Extensibility

#### 16.3.1. Field Name Registry

#### 16.3.2. Considerations for New Field Names

##### 16.3.2.1. Considerations for New Field Names

##### 16.3.2.2. Considerations for New Field Values

### 16.4. Authentication Scheme Extensibility

#### 16.4.1. Authentication Scheme Registry

#### 16.4.2. Consierations for New Authentication Schemes

### 16.5. Range Unit Extensibility

#### 16.5.1. Range Unit Registry

#### 16.5.2. Considerations for New Range Units

### 16.6. Content Coding Extensibility

#### 16.6.1. Content Coding Registry

#### 16.6.2. Considerations for New Content Codings

### 16.7. Upgrade Token Registry

## 17. Security Considerations

### 17.1. Establishing Authority

### 17.2. Risks of Intermediaries

### 17.3. Attacks Based on File and Path Names

### 17.4. Attacks Based on Command, Code, or Query Injection

### 17.5. Attacks via Protocol Element Length

### 17.6. Attacks Using Shared-Dictionary Compression

### 17.7. Disclosure of Personal Information

### 17.8. Privacy of Server Log Information

### 17.9. Disclosure of Personal Information

### 17.10. Privacy of Server Log Information

### 17.11. Disclosure of Fragment after Redirects

### 17.12. Disclosure of Product Information

### 17.13. Browser Fingerprinting

### 17.14. Validator Retention

### 17.15. Denial-of-Service Attacks Using Range

### 17.16. Authetication Considerations

#### 17.16.1. Confidentiality of Credentials

#### 17.16.2. Credentials and Idle Clients

#### 17.16.3. Protection Spaces

#### 17.16.4. Additional Response Fields

## 18. IANA Considerations

### 18.1. URI Scheme Registration

### 18.2. Method Registration

### 18.3. Status Code Registration

### 18.4. Field Name Registration

### 18.5. Authentication Scheme Registration

### 18.6. Content Coding Registration

### 18.7. Range Unit Registration

### 18.8. Media Type Registration

### 18.9. Port Registration

### 18.10. Upgrade Token Registration

## 19. References

## Appendix A. Collected ABNF
