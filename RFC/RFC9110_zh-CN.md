# HTTP Semantics

> 原文 [https://www.rfc-editor.org/rfc/rfc9110](https://www.rfc-editor.org/rfc/rfc9110)

## 摘要

超文本传输协议 (HTTP) 是一种用于分布式、协作的超文本信息系统的无状态应用层协议。本文档描述了 HTTP 的整体架构，建立了通用术语，并从协议中所有版本共享的层面进行定义。在这个定义中包括核心协议元素、可扩展性机制以及 "http" 和 "https" 统一资源标识符 (URI) 方案。

本文档更新了RFC 3864，废止了 RFC 2818、7231、7232、7233、7235、7538、7615、7694 和 7230 的部分内容。

## 1. Introduction

### 1.1. Purpose

Hypertext Transfer Protocol (HTTP) 是一系列无状态、应用层、基于请求/响应的协议，它们共享通用接口、可拓展语义和自描述信息，以实现与基于网络的超文本信息系统的灵活交互。

HTTP 通过向客户端提供独立于所提供资源类型的统一接口，隐藏了服务如何实现的细节。同样，服务端不需要知道每个客户端的目的:可以孤立地考虑请求，而不是与特定类型的客户端或预定的应用程序步骤序列相关联。这允许在许多不同的上下文中有效地使用通用实现，降低交互复杂性，并支持随着时间的推移而独立地发展。

HTTP 还被设计为用作中介协议，其中代理和网关可以将非 HTTP 信息系统转换为更通用的接口。

这种灵活性的一个后果是协议不能根据接口背后发生的事情来定义。相反，我们被限制在定义通信的语法、接收到的通信的意图和接收方的预期行为。如果孤立地考虑通信，那么成功的操作应该反映在服务器提供的可观察接口的相应更改中。然而，由于多个客户端可能并行操作，并且可能出于不同的目的，我们不能要求这些更改在单个响应的范围之外是可观察到的。

### 1.2. History and Evolution

HTTP 自 1990 年引入以来一直是万维网的主要信息传输协议。它最初是一种用于低延迟请求的简单机制，使用一个 GET 方法请求传输由给定路径名标识的假定超文本文档。随着 Web 的发展，HTTP 得到了扩展，可以在消息中包含请求和响应，使用类似 MIME 的媒体类型传输任意数据格式，并通过中介路由请求。这些协议最终定义为 HTTP/0.9 和 HTTP/1.0 (参见 [HTTP/1.0])。

HTTP/1.1 旨在改进协议的功能，同时保持与现有的基于文本的消息语法的兼容性，提高其在互联网上的互操作性、可伸缩性和健壮性。这包括：

- 用于固定和动态(分块)内容的基于长度的数据分隔符
- 用于内容协商的一致框架
- 用于条件请求的不透明验证器
- 用于更好的缓存一致性的缓存控件
- 用于部分更新的范围请求
- 默认持久连接。

HTTP/1.1 于 1995 年引入，1997 年在 Standards Track 上发布 [RFC2068]， 1999 年修订 [RFC2616]，并于 2014 年再次修订 ([RFC7230] 至 [RFC7235])。

HTTP/2 ([HTTP/2]) 在现有 TLS 和 TCP 协议的基础上引入了一个多路复用会话层，用于通过高效的字段压缩和服务器推送来交换并发 HTTP 消息。

HTTP/3 ([HTTP/3]) 通过使用 基于 UDP 的 QUIC 作为安全多路传输协议，而不是 TCP，为并发消息提供了更大的独立性。

HTTP 的三个主要版本都依赖于本文档定义的语义。它们并没有互相淘汰，因为每一种都有特定的好处和限制，这取决于使用的环境。具体实现应该为其特定的上下文选择最合适的传输和消息传递语法。

当前的 HTTP 修订文档从 HTTP/1.1 消息传递语法 ([HTTP/1.1]) 中分离了语义(本文档)和缓存 ([CACHING]) 的定义，以允许每个主要协议版本在引用相同的核心语义的同时独立发展。

### 1.3. Core Semantics

HTTP 通过发送操作或传输表示的消息 (第3.2节)，提供了与资源交互的统一接口 (第3.1节) —— 无论其类型、性质或实现如何。

每条消息要么是请求，要么是响应。客户端构造用于传递其意图的请求消息，并将这些消息路由到已识别的源服务器。服务器侦听请求，解析接收到的每个消息，解释与已识别的目标资源相关的消息语义，并用一个或多个响应消息响应该请求。客户端检查收到的响应，以确定其意图是否被执行，并根据收到的状态代码和内容确定下一步要做什么。

HTTP 语义包括每个请求方法定义的意图 (第9节)、可能在请求头字段中描述的语义扩展、描述响应的状态代码 (第15节) 以及可能在响应字段中给出的其他控制数据和资源元数据。

HTTP 语义还包括描述接收者打算如何解释内容的表示元数据、可能影响内容选择的请求报头字段以及统称为“内容协商”的各种选择算法 (第12节)。

### 1.4. Specifications Obsoleted by This Document

Title | Reference | See
--|--|--
HTTP Over TLS | [RFC2818] | B.1
HTTP/1.1 Message Syntax and Routing [*] | [RFC7230] | B.2
HTTP/1.1 Semantics and Content | [RFC7231] | B.3
HTTP/1.1 Conditional Requests | [RFC7232] | B.4
HTTP/1.1 Range Requests | [RFC7233] | B.5
HTTP/1.1 Authentication | [RFC7235] | B.6
HTTP Status Code 308 (Permanent Redirect) | [RFC7538] | B.7
HTTP Authentication-Info and Proxy-Authentication-Info Response Header Fields | [RFC7615] | B.8
HTTP Client-Initiated Content-Encoding | [RFC7694] | B.9

[*] 本文档仅废弃了 RFC7230 中独立于 HTTP/1.1 消息传递语法和连接管理的部分; RFC7230 的剩余部分由 "HTTP/1.1"[HTTP/1.1] 废止。

## 2. Conformance

### 2.1. Syntax Notation

本规范使用[RFC5234]的 Augmented Backus-Naur Form (ABNF)，扩展了[RFC7405]中定义的字符串区分大小写的表示法。

它还使用了在第 5.6.1 节中定义的列表扩展，允许使用 "#" 操作符 (类似于 "*" 操作符表示重复)紧凑地定义逗号分隔的列表。附录 A 显示了收集到的语法，其中所有列表操作符扩展为标准 ABNF 表示法。

按照惯例，ABNF 规则名前缀为 "obs-" 表示由于历史原因而出现的过时语法规则。

参考 [RFC5234] 附录 B.1 定义的核心规则包括: ALPHA(字母)、CR(回车)、CRLF(CR LF)、CTL(控制符)、DIGIT(十进制0-9)、DQUOTE(双引号)、HEXDIG(十六进制0-9/A-F/a-f)、HTAB(水平制表符)、LF(换行)、OCTET(任何8位数据序列)、SP(空格)、VCHAR(任何可见的 US-ASCII 字符)。

第 5.6 节定义了字段值的一些通用语法组件。

本规范使用了 [RFC6365] 中定义的术语 “字符”、“字符编码方案”、“字符集”和“协议元素”。

### 2.2. Requirements Notation

本文档中的关键词“必须”、“不得”、“必需”、“应”、“不应”、“建议”、“不建议”、“可”和“可选”在所有大写字母出现时（如图所示）应按照 BCP 14 [RFC2119] [RFC8174] 所述进行解释。

该规范根据 HTTP 通信中参与者的角色确定一致性标准。因此，需求被放在发送者、接收者、客户端、服务器、用户代理、中介体、原始服务器、代理、网关或缓存上，这取决于需求所约束的行为。当实现、资源所有者和协议元素注册超出单个通信的范围时，会对它们提出额外的要求。

当需求只应用于创建协议元素的实现，而不是向下游转发接收到的元素的实现时，使用动词 "generate" 而不是 "send"。

如果一个实现符合与它在 HTTP 中所扮演的角色相关的所有需求，那么它就被认为是符合的。

发送方绝对不能生成与相应 ABNF 规则定义的语法不匹配的协议元素。在给定的消息中，发送方绝对不能生成仅允许由其他角色(即发送方没有该消息的角色)的参与者生成的协议元素或语法替代方案。

对 HTTP 的一致性既包括对所使用协议版本的特定消息传递语法的一致性，也包括对所发送的协议元素的语义的一致性。例如，一个客户端声称符合 HTTP/1.1，但未能识别 HTTP/1.1 接收方所需的功能，将无法与根据这些声明调整响应的服务器进行互操作。反映用户选择的特性，如内容协商和用户选择的扩展，可以影响超出协议流的应用程序行为;发送不准确反映用户选择的协议元素将使用户感到困惑并抑制选择。

当实现在语义一致性上失败时，该实现的消息的接收者最终将开发变通方法来相应地调整其行为。如果解决办法仅限于发生故障的实现，接收方可以在保持符合本协议的情况下采用此类解决办法。例如，服务器经常扫描 User-Agent 字段值的一部分，而用户代理经常扫描 Server 字段值，以根据已知的错误或选择不当的默认值调整自己的行为。

### 2.3. Length Requirements

接收方应该防御性地解析接收到的协议元素，只期望该元素符合其 ABNF 语法并适合合理的缓冲区大小。

HTTP对它的许多协议元素没有特定的长度限制，因为合适的长度可能会有很大的不同，这取决于部署上下文和实现的目的。因此，发送方和接收方之间的互操作性取决于对每个协议元素的合理长度的共同期望。此外，在过去 30 年的 HTTP 使用过程中，通常理解的一些协议元素的合理长度已经发生了变化，并且预计在未来还会继续发生变化。

至少，接收方必须能够解析和处理协议元素长度，这些长度至少与它在其他消息中为这些相同的协议元素生成的值相同。例如，将很长的 URI 引用发布到其自身资源的源服务器需要在接收到目标 URI 时能够解析和处理这些相同的引用。

许多接收到的协议元素只在识别和向下游转发该元素所需的范围内进行解析。例如，中介可能将接收到的字段解析为其字段名和字段值组件，但随后转发该字段，而无需在字段值内部进一步解析。

### 2.4. Error Handing

接收方必须根据本规范为其定义的语义(包括本规范的扩展)解释接收到的协议元素，除非接收方(通过经验或配置)确定发送方错误地实现了这些语义所暗示的内容。例如，如果对 User-Agent 报头字段的检查表明某个特定的实现版本在接收到某些内容编码时失败，那么源服务器可能会忽略接收到的 Accept-Encoding 报头字段的内容。

除非另有说明，接收方可以尝试从无效的构造中恢复可用的协议元素。HTTP 不定义特定的错误处理机制，除非这些机制对安全性有直接影响，因为协议的不同应用程序需要不同的错误处理策略。例如，Web 浏览器可能希望从 Location 报头字段没有根据 ABNF 解析的响应中透明地恢复，而系统控制客户端可能认为任何形式的错误恢复都是危险的。

在底层连接失败的情况下，一些请求可以被客户端自动重试，如 9.2.2 节所述。

### 2.5. Protocol Version

HTTP的版本号由 "." 分隔的两个十进制数字组成。(句号或小数点)。第一个数字(主要版本)表示消息语法，而第二个数字(次要版本)表示发送方符合(能够理解以便将来通信)的主要版本中最高的次要版本。

虽然 HTTP 的核心语义在协议版本之间不会改变，但它们的表达式可能会改变，因此当对有线格式进行不兼容的更改时，HTTP版本号也会改变。此外，HTTP允许对协议进行增量的、向后兼容的更改，而无需通过使用定义的扩展点更改其版本 (第16节)。

协议版本作为一个整体表明发送方是否符合该版本对应规范中规定的要求集。例如，"HTTP/1.1" 版本是由本文档的 "HTTP缓存"[Caching] 和 "HTTP/1.1"[HTTP/1.1] 的组合规范定义的。

当引入不兼容的消息语法时，HTTP 的主版本号会增加。当对协议所做的更改增加消息语义或暗示发送方的额外功能时，次要编号将增加。

即使发送方只使用向后兼容的协议子集，次要版本也会公布发送方的通信能力，从而让接收方知道可以在响应(服务器)或未来的请求(客户端)中使用更高级的功能。

当 HTTP 的主版本没有定义任何次要版本时，暗示次要版本 "0"。"0" 用于在需要次要版本标识符的元素中引用该协议。

## 3. Terminology and Core Concepts

HTTP 是为万维网 (WWW) 架构而创建的，并随着时间的推移不断发展，以支持全球超文本系统的可伸缩性需求。该体系结构的大部分内容反映在用于定义 HTTP 的术语中。

### 3.1. Resources

HTTP 请求的目标称为“资源”。HTTP 不限制资源的性质；它仅仅定义了一个可能用于与资源交互的接口。大多数资源由统一资源标识符 (Uniform Resource Identifier, URI) 标识，如第4节所述。

HTTP 的一个设计目标是将资源标识与请求语义分离，这可以通过在请求方法 (第9节) 和一些请求修改头字段中嵌入请求语义来实现。资源不能以与请求方法的语义不一致的方式处理请求。例如，尽管资源的 URI 可能意味着不安全的语义，但客户端可以期望资源在使用安全方法处理请求时避免不安全的操作 (参见章节9.2.1)。

HTTP 依赖统一资源标识符(Uniform Resource Identifier, URI) 标准[URI] 来指示目标资源(章节7.1)和资源之间的关系。

### 3.2. Representations

“表示” 是旨在反映给定资源的过去、当前或期望状态的信息，其格式可以通过协议随时进行通信。一个表示由一组表示元数据和一个潜在的无界表示数据流组成(第8节)。

HTTP 允许“信息隐藏”在其统一的接口后面，通过定义与资源状态的可传输表示相关的通信，而不是传输资源本身。这允许URI标识的资源是任何东西，包括时间函数，如“拉古纳海滩的当前天气”，同时潜在地提供在消息生成时表示该资源的信息[REST]。

统一接口类似于一个窗口，通过这个窗口，人们只能通过将消息传递给另一边的独立行动者来观察事物并对其采取行动。在我们的通信中，需要一个共享的抽象来表示(“取代”)该事物的当前或期望状态。当一个表示是超文本时，它既可以提供资源状态的表示，也可以提供帮助指导接收者未来交互的处理指令。

目标资源可能提供或能够生成多个表示，每个表示旨在反映资源的当前状态。通常基于内容协商(第12节)的算法将用于从这些表示中选择最适用于给定请求的一种。这个“选定的表示”为评估条件请求(第13节)提供了数据和元数据，并为GET的200 (OK)、206(部分内容)和304(未修改)响应构造内容(第9.3.1节)。

### 3.3. Connections, Clients, and Servers

HTTP 是一个在可靠的传输层或会话层“连接”上运行的客户端/服务器协议。

HTTP “客户端”是为了发送一个或多个 HTTP 请求而与服务器建立连接的程序。HTTP “服务器”是一个接受连接的程序，通过发送HTTP响应来服务HTTP请求。

术语客户端和服务器仅指这些程序为特定连接执行的角色。同一个程序可能在某些连接上充当客户端，在其他连接上充当服务器。

HTTP被定义为无状态协议，这意味着可以孤立地理解每个请求消息的语义，并且连接和其中的消息之间的关系对这些消息的解释没有影响。例如，一个CONNECT请求(章节9.3.6)或一个带有Upgrade报头字段的请求(章节7.8)可以在任何时候发生，而不仅仅是在连接的第一条消息中。许多实现依赖于HTTP的无状态设计，以便在多个服务器之间重用代理连接或动态负载平衡请求。

因此，服务器绝对不能假定同一连接上的两个请求来自同一个用户代理，除非连接是安全的并且特定于该代理。一些非标准的HTTP扩展(例如，[RFC4559])已经被发现违反了这一要求，导致了安全性和互操作性问题。

### 3.4. Messages

HTTP 是一种无状态的请求/响应协议，用于在连接之间交换“消息”。术语“发送方”和“接收方”分别指发送或接收给定消息的任何实现。

客户端以带有方法(第9节)和请求目标(第7.1节)的“请求”消息的形式向服务器发送请求。请求还可能包含用于请求修饰符、客户端信息和表示元数据的报头字段(章节6.3)、用于按照方法处理的内容(章节6.4)以及用于在发送内容时传递收集到的信息的尾字段(章节6.5)。

服务器通过发送一个或多个“响应”消息来响应客户机的请求，每个“响应”消息包括一个状态码(第15节)。响应还可能包含用于服务器信息的报头字段、资源元数据和表示元数据、根据状态代码解释的内容，以及用于在发送内容时传递收集到的信息的尾部字段。

### 3.5. User Agents

术语“用户代理”指的是发起请求的各种客户机程序。

最常见的用户代理形式是通用 Web 浏览器，但这只占实现的一小部分。其他常见的用户代理包括 spider (穿越网络的机器人)、命令行工具、广告牌屏幕、家用电器、秤、灯泡、固件更新脚本、移动应用程序和各种形状和大小的通信设备。

作为用户代理并不意味着在请求时有一个人类用户直接与软件代理交互。在许多情况下，用户代理被安装或配置为在后台运行，并保存其结果以供以后检查(或仅保存那些可能有趣或错误的结果的子集)。例如，通常会给 spider 一个起始 URI，并将其配置为在以超文本图的形式在 Web 上爬行时遵循某些行为。

许多用户代理不能(或选择不)向用户提供交互式建议，或就安全或隐私问题提供足够的警告。在少数情况下，该规范要求向用户报告错误，这种报告只能在错误控制台或日志文件中可见，这是可以接受的。同样地，在继续之前由用户确认自动操作的需求可以通过预先配置选择、运行时选项或简单地避免不安全操作来满足;如果用户已经做出了选择，确认并不意味着任何特定的用户界面或正常处理的中断。

### 3.6. Origin Server

术语“源服务器”是指可以为给定的目标资源发起权威响应的程序。

最常见的原始服务器形式是大型公共网站。然而，就像用户代理被等同于浏览器一样，很容易被误导，认为所有的原始服务器都是一样的。常见的原始服务器还包括家庭自动化单元、可配置的网络组件、办公机器、自主机器人、新闻源、交通摄像头、实时广告选择器和视频点播平台。

大多数 HTTP 通信由一个检索请求 (GET) 组成，该请求用于 URI 标识的某些资源的表示。在最简单的情况下，这可以通过用户代理 (UA) 和源服务器 (O) 之间的单个双向连接 (===) 来完成。

```
         request   >
    UA ======================================= O
                                <   response
```

### 3.7. Intermediaries

HTTP 允许使用中介体通过连接链来满足请求。HTTP “中介”有三种常见形式: 代理、网关和隧道。在某些情况下，单个中介可能充当原始服务器、代理、网关或隧道，根据每个请求的性质切换行为。

```
         >             >             >             >
    UA =========== A =========== B =========== C =========== O
               <             <             <             <
```

上图显示了用户代理和原始服务器之间的三个中介(A、B和C)。在整个链中传递的请求或响应消息将通过四个独立的连接。有些 HTTP 通信选项可能只应用于与最近的非隧道邻居的连接，只应用于链的端点，或者应用于链上的所有连接。尽管图是线性的，但是每个参与者可能同时进行多个通信。例如，在处理 A 的请求的同时，B 可能正在接收来自除 A 以外的许多客户机的请求，并且/或将请求转发到除 C 以外的服务器。同样，以后的请求可能通过不同的连接路径发送，通常基于负载平衡的动态配置。

术语“上游”和“下游”用于描述与消息流相关的定向需求:所有消息都从上游流向下游。术语“入站”和“出站”用于描述与请求路由相关的定向需求:入站意味着“指向源服务器”，而出站意味着“指向用户代理”。

“代理”是一种消息转发代理，通常由客户端通过本地配置规则选择，用于接收某些类型的绝对 URI 请求，并试图通过 HTTP 接口的转换来满足这些请求。有些转换是最小的，例如 “http” uri的代理请求，而其他请求可能需要转换到完全不同的应用程序级协议。代理通常用于通过公共中介对组织的 HTTP 请求进行分组，以实现安全服务、注释服务或共享缓存。有些代理被设计为在转发消息或内容时对选定的消息或内容应用转换，如第7.7节所述。

一个“门户”(又名“门户”)。“反向代理”)是一种中介，充当出站连接的源服务器，但转换接收到的请求并将它们转发到另一个或多个服务器。网关通常用于封装遗留或不受信任的信息服务，通过“加速器”缓存来提高服务器性能，并支持跨多台机器对HTTP服务进行分区或负载平衡。

适用于源服务器的所有HTTP要求也适用于网关的出站通信。网关使用它想要的任何协议与入站服务器通信，包括超出本规范范围的HTTP私有扩展。但是，希望与第三方HTTP服务器进行互操作的 HTTP-to-HTTP 网关需要符合网关入站连接上的用户代理要求。

“隧道”在不改变消息的情况下充当两个连接之间的盲中继。一旦激活，隧道就不被视为 HTTP 通信的一方，尽管隧道可能是由 HTTP 请求发起的。当中继连接的两端关闭时，隧道即停止存在。隧道用于通过中介扩展虚拟连接，例如当传输层安全(TLS， [TLS13])用于通过共享防火墙代理建立机密通信时。

上述中介类别仅考虑充当 HTTP 通信参与者的中介。还有一些中介体可以作用于网络协议栈的较低层，在消息发送方不知情或不允许的情况下过滤或重定向 HTTP 流量。网络中介体(在协议级别上)与路径上的攻击者难以区分，由于错误地违反 HTTP 语义，通常会引入安全缺陷或互操作性问题。

例如，“拦截代理”[RFC3040](通常也称为“透明代理”[RFC1919])与HTTP代理不同，因为它不是由客户端选择的。相反，拦截代理过滤或重定向传出的 TCP 端口 80 包(偶尔还有其他常见端口流量)。拦截代理通常出现在公共网络接入点上，作为在允许使用非本地Internet服务之前强制帐户订阅的一种手段，并在公司防火墙内强制执行网络使用策略。

### 3.8. Caches

“缓存”是以前响应消息的本地存储，以及控制其消息存储、检索和删除的子系统。缓存存储可缓存的响应，以减少未来等效请求的响应时间和网络带宽消耗。任何客户端或服务器都可以使用缓存，但缓存不能在充当隧道时使用。

缓存的效果是，如果链上的一个参与者有一个适用于该请求的缓存响应，那么请求/响应链就会缩短。如果 B 有一个未被 UA 或 A 缓存的请求的 O(通过 C ) 早期响应的缓存副本，则如下所示的结果链。

```
            >             >
       UA =========== A =========== B - - - - - - C - - - - - - O
                  <             <
```

如果允许缓存存储响应消息的副本以用于响应后续请求，则响应是“可缓存的”。即使响应是可缓存的，客户机或源服务器也可能对何时可以将缓存的响应用于特定请求设置额外的约束。缓存行为和可缓存响应的HTTP要求在[CACHING]中定义。

在万维网上和大型组织内部部署了各种各样的缓存体系结构和配置。其中包括全国层次结构的代理缓存，以节省带宽和降低延迟，使用网关缓存优化流行站点的区域和全球分布的内容交付网络，广播或组播缓存条目的协作系统，在脱机或高延迟环境中使用的预取缓存条目的存档，等等。

### 3.9. Example Message Exchange

下面的例子说明了一个典型的 HTTP/1.1 消息交换，用于 URI "http://www.example.com/hello.txt" 上的 GET 请求(章节9.3.1):

Client request:

```
GET /hello.txt HTTP/1.1
User-Agent: curl/7.64.1
Host: www.example.com
Accept-Language: en, mi
```

Server response:

```
HTTP/1.1 200 OK
Date: Mon, 27 Jul 2009 12:28:53 GMT
Server: Apache
Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
ETag: "34aa387-d-1568eb00"
Accept-Ranges: bytes
Content-Length: 51
Vary: Accept-Encoding
Content-Type: text/plain

Hello World! My content includes a trailing CRLF.
```

## 4. Identifiers in HTTP

统一资源标识符 (URI) [URI]在整个 HTTP 中用作标识资源的手段(章节3.1)。

### 4.1. URI References

URI 引用用于定位请求、指示重定向和定义关系。

“URI-reference”、“absolute-URI”、“relative-part”、“authority”、“port”、“host”、“path-abempty”、“segment”、“query” 等定义均采用 URI 泛型语法。为可以包含非空路径组件的协议元素定义了“绝对路径”规则。(此规则与 RFC3986 中的 path-abempty 规则略有不同，后者允许使用空路径，而path-absolute规则不允许以 “//” 开头的路径。) “partial-URI” 规则是为可以包含相对 URI 但不包含片段组件的协议元素定义的。

```
  URI-reference = <URI-reference, see [URI], Section 4.1>
  absolute-URI  = <absolute-URI, see [URI], Section 4.3>
  relative-part = <relative-part, see [URI], Section 4.2>
  authority     = <authority, see [URI], Section 3.2>
  uri-host      = <host, see [URI], Section 3.2.2>
  port          = <port, see [URI], Section 3.2.3>
  path-abempty  = <path-abempty, see [URI], Section 3.3>
  segment       = <segment, see [URI], Section 3.3>
  query         = <query, see [URI], Section 3.4>

  absolute-path = 1*( "/" segment )
  partial-URI   = relative-part [ "?" query ]
```

HTTP 中允许 URI 引用的每个协议元素都将在其 ABNF 生成中指示该元素是否允许任何形式的引用 (URI-reference)、是否只允许绝对形式的 URI (absolute-URI)、是否只允许路径和可选查询组件(partial-URI)，或以上几种类型的某种组合。除非另有说明，否则URI引用将相对于目标URI进行解析(章节7.1)。

建议所有发送方和接收方至少支持协议元素中长度为8000字节的uri。注意，这意味着某些结构和在线表示(例如，HTTP/1.1中的请求行)在某些情况下必然会更大。

### 4.2. HTTP-Related URI Schemes

IANA在 <https://www.iana.org/assignments/uri-schemes/> 维护 URI 方案 [BCP35] 的注册表。尽管请求可能针对任何URI方案，但以下方案是HTTP服务器固有的:

URI Scheme | Description | Section
--|--|--
http | Hypertext | Transfer Protocol | 4.2.1
https | Hypertext Transfer Protocol Secure | 4.2.2

请注意，“http” 或 “https” URI的存在并不意味着始终有一个 http 服务器在标识的原点侦听连接。任何人都可以创建 URI，无论服务器是否存在，以及服务器当前是否将该标识符映射到资源。注册名称和 IP 地址的委托性质将创建一个联邦名称空间，无论是否存在 HTTP 服务器。

#### 4.2.1. http URI Scheme

这里定义了 “http” URI方案，用于在分层命名空间内创建标识符，该命名空间由侦听给定端口上 TCP ([TCP]) 连接的潜在 http 源服务器所治理。

```
http-URI = "http" "://" authority path-abempty [ "?" query ]
```

“http”URI的源服务器由授权组件标识，它包括一个主机标识符([URI]，章节3.2.2)和可选端口号([URI]，章节3.2.3)。如果端口子组件为空或没有给出，TCP端口80(为WWW服务预留的端口)是默认的。原点决定了谁有权权威地响应以已标识资源为目标的请求，如第4.3.2节所定义。

发送方绝对不能生成带有空主机标识符的“http”URI。处理此类URI引用的接收方必须将其视为无效而拒绝。

分层路径组件和可选查询组件在源服务器的名称空间中标识目标资源。

#### 4.2.2. https URI Scheme

这里定义了 “https” URI 方案，用于在分层命名空间内创建标识符，该命名空间由潜在的源服务器管理，侦听给定端口上的 TCP 连接，并能够建立已为 HTTP 通信提供安全保护的TLS ([TLS13])连接。在这种情况下，“安全的”具体指的是服务器已经被认证为代表所识别的授权机构，并且与该服务器的所有HTTP通信都具有客户机和服务器都可接受的机密性和完整性保护。

```
 https-URI = "https" "://" authority path-abempty [ "?" query ]
```

“https” URI 的源服务器由授权组件标识，它包括一个主机标识符([URI]，章节3.2.2)和可选端口号([URI]，章节3.2.3)。如果端口子组件为空或未给出，则 TCP 端口 443 (HTTP over TLS的预留端口) 是默认值。原点决定了谁有权权威地响应以标识资源为目标的请求，如第 4.3.3 节中定义的那样。

发送方绝对不能生成带有空主机标识符的 “https” URI。处理此类 URI 引用的接收方必须将其视为无效而拒绝。

分层路径组件和可选查询组件在源服务器的名称空间中标识目标资源。

客户端必须确保其对 “https” 资源的 HTTP 请求在通信之前是安全的，并且它只接受对这些请求的安全响应。请注意，客户端和服务器可以接受的加密机制的定义通常是协商的，并且可以随着时间的推移而改变。

通过 “https” 方案提供的资源与 “http” 方案没有共享标识。它们是具有独立名称空间的不同起源。然而，对 HTTP 的扩展被定义为应用于具有相同主机的所有源，例如 Cookie 协议[Cookie]，允许一个服务设置的信息影响与匹配主机域中的其他服务的通信。这种扩展的设计应该非常谨慎，以防止从安全连接获得的信息在不安全的上下文中被无意地交换。

#### 4.2.3. http(s) Normalization and Comparison

带有 “http” 或 “https” 方案的 URI 根据[URI]第 6 节中定义的方法进行规范化和比较，并使用上述每种方案的默认值。

HTTP 不需要使用特定的方法来确定等价性。例如，缓存键可以作为一个简单的字符串进行比较，在基于语法的归一化之后，或者在基于方案的归一化之后。

“http” 和 “https” URI 的基于方案的规范化([URI]第6.2.3节)涉及以下附加规则:

- 如果端口等于某个方案的默认端口，一般形式是省略端口子组件。
- 当不被用作 OPTIONS 请求的目标时，空路径组件相当于“/”的绝对路径，因此正常形式是提供 “/” 的路径。
- scheme 和 host 不区分大小写，通常以小写形式提供；所有其他组件都以区分大小写的方式进行比较。
- 除“保留”集中的字符外，其他字符等效于它们的百分比编码的八字节:正常形式是不编码它们(参见[URI]的2.1和2.2节)。

例如，以下三个uri是等价的:

```
   http://example.com:80/~smith/home.html
   http://EXAMPLE.com/%7Esmith/home.html
   http://EXAMPLE.com:/%7esmith/home.html
```

可以假设规范化(使用任何方法)后等价的两个 HTTP uri 标识相同的资源，并且任何 HTTP 组件都可以执行规范化。因此，不同的资源不应该被标准化后等效的 HTTP URI 标识(使用[URI]章节6.2中定义的任何方法)。

#### 4.2.4. Deprecation of userinfo in http(s) URIs

授权的 URI 通用语法还包括 userinfo 子组件([URI]， Section 3.2.1)，用于在 URI 中包含用户身份验证信息。在该子组件中，不建议使用 “user:password” 格式。

有些实现将 userinfo 组件用于身份验证信息的内部配置，例如在命令调用选项、配置文件或书签列表中，尽管这种使用可能会暴露用户标识符或密码。

当在消息中生成 “http” 或 “https” URI 引用作为目标 URI 或字段值时，发送方绝对不能生成 userinfo 子组件(及其“@”分隔符)。

在使用来自不可信源的 “http” 或 “https” URI 引用之前，接收方应该解析 userinfo 并将其作为错误处理;这很可能是为了网络钓鱼攻击而被用来绕过授权。

#### 4.2.5. http(s) References with Fragment Identifiers

片段标识符允许间接标识辅助资源，独立于URI方案，如[URI]第3.5节所定义。一些引用URI的协议元素允许包含片段，而另一些则不允许。它们通过使用ABNF规则来区分允许分段的元素;否则，将使用排除片段的特定规则。

> 注意:片段标识符组件不是 URI 方案定义的一部分(参见[URI]第4.3节)，因此没有出现在上面 “http” 和 “https” URI 方案的 ABNF 定义中。

### 4.3 Authoritative Access

授权访问指的是以客户端认为是授权的(由资源所有者控制)的方式取消对给定标识符的引用，以便访问已标识的资源。决定是否授予访问权的过程由 URI 方案定义，并且通常使用 URI 组件中的数据，例如在使用泛型语法时使用授权组件。然而，授权访问并不局限于所识别的机制。

第 4.3.1 节将源站的概念定义为对这些用途的辅助，随后的子节解释了如何确定对等体具有代表源站的权限。

有关建立权限的安全考虑，请参见 17.1 节。

#### 4.3.1. URI Origin

给定URI的“源”是 scheme、host 和 port 的三元组，将 scheme 和 host 规范化为小写，并将 port 规范化以删除前导的零。如果在URI中省略了 port，则使用该方案的默认端口。例如，URI:

```
 https://Example.Com/happy.js
```

源站三元组为：

```
{ "https", "example.com", "443" }
```

这也可以被描述为始终存在端口的规范化URI前缀:

```
https://example.com:443
```

每个源定义自己的命名空间，并控制该命名空间中的标识符如何映射到资源。反过来，随着时间的推移，源如何响应有效的请求，决定了用户将与 URI 关联的语义，而这些语义的有用性最终将这些机制转换为供用户将来引用和访问的资源。

如果两个源在方案、主机或端口上不同，则它们是不同的。即使可以验证同一个实体控制两个不同的源，这些源下的两个命名空间也是不同的，除非授权该源的服务器显式指定别名。

Origin 也用于 HTML 和相关的 Web 协议中，超出了本文档的范围，如[RFC6454]所述。

#### 4.3.2. http Origins

虽然 HTTP 独立于传输协议，但 “HTTP” 方案(第4.2.1节)特定于将授权机构与控制源服务器的任何人关联起来，源服务器侦听授权机构组件中标识的任何主机的指定端口上的 TCP 连接。这是一种非常弱的权威感，因为它依赖于特定于客户端的名称解析机制和通信，而通信可能不会受到路径攻击者的保护。尽管如此，对于将“http”标识符绑定到源服务器以在受信任的环境中进行一致的解析来说，这是一个足够的最低要求。

如果提供的主机标识符是一个 IP 地址，则源服务器是该 IP 地址上指定的 TCP 端口上的侦听器(如果有的话)。如果 host 是一个已注册的名称，则已注册的名称是一个间接标识符，用于与名称解析服务(如DNS)一起使用，以查找适当的源服务器的地址。

当使用 “http” URI 访问指定的资源时，客户端可以尝试通过将主机标识符解析为 IP 地址，在指定的端口上建立到该地址的 TCP 连接，并通过该连接发送一个 http 请求消息，其中包含与客户端目标 URI 匹配的请求目标(章节7.1)。

如果服务器用非临时 HTTP 响应消息响应这样的请求(如第15节所述)，则该响应被认为是对客户端请求的权威响应。

但请注意，上述并不是获得权威响应的唯一方法，也并不意味着权威响应总是必要的(参见[缓存])。例如，Alt-Svc 头字段[ALTSVC]允许源服务器识别同样是该源授权的其他服务。对“http”标识资源的访问也可能由本文档范围之外的协议提供。

#### 4.3.3. https Origins

“https” 方案(章节4.2.2)基于服务器使用私钥的能力来关联授权机构，该私钥对应于客户端认为对已识别的源服务器是可信的证书。客户端通常依赖于一条信任链(由一些预先安排或配置的信任锚点传递)来认为证书是可信的(第4.3.4节)。

在 HTTP/1.1 及更早版本中，只有当客户端通过成功建立并安全的特定于 URI 源主机的连接进行通信时，才会将权限授予服务器。连接建立和证书验证被用作权威的证明。

在 HTTP/2 和 HTTP/3 中，当客户端通过成功建立且安全的连接进行通信时，如果 URI 来源的主机与服务器证书中存在的任何主机相匹配，并且客户端相信它可以为该 URI 打开到该主机的连接，则将权限授予服务器。在实际应用中，客户端会发起 DNS 查询，以检查源主机的 IP 地址与已建立连接的服务器 IP 地址相同。这个限制可以通过源服务器发送一个等效的源帧[RFC8336]来消除。

请求目标的主机和端口值在每个 HTTP 请求中传递，用于标识源，并将其与可能由同一台服务器控制的其他命名空间区分开来(第7.2节)。来源有责任确保提供的任何控制其证书私钥的服务同样负责管理相应的 “https” 命名空间，或至少准备拒绝看似被误导的请求(7.4节)。

源服务器可能不愿意处理对某些目标 uri 的请求，即使它们有这样做的权限。例如，当一台主机在不同的端口(例如 443 和 8000)上运行不同的服务时，检查源服务器上的目标 URI 是必要的(即使在连接已经安全之后)，因为网络攻击者可能会导致一个端口的连接被其他端口接收。如果无法检查目标URI，攻击者可能会将对一个目标 URI 的响应(例如 "https://example.com/foo") 替换为看似权威的来自另一个端口的响应(例如 “https://example.com:8000/foo”)。

请注意，“https” 方案不依赖于 TCP 和连接的端口号来关联授权机构，因为两者都在安全通信之外，因此不能作为确定可信的。因此，HTTP 通信可以在 4.2.2 节定义的任何安全通道上进行，包括不使用 TCP 的协议。

当在要求访问指定资源的上下文中使用 “https” URI 时，客户端可以通过以下方式尝试访问:将主机标识符解析为IP地址，在指定的端口上建立到该地址的 TCP 连接，通过在 TCP 上成功发起具有机密性和完整性保护的 TLS 来保护端到端连接，并通过该连接发送包含与客户端目标 URI 匹配的请求目标的 HTTP 请求消息(章节7.1)。

如果服务器用非临时 HTTP 响应消息响应这样的请求(如第15节所述)，则该响应被认为是对客户端请求的权威响应。

但请注意，上述并不是获得权威响应的唯一方法，也并不意味着权威响应总是必要的(参见[缓存])。

#### 4.3.4. https Certificate Verification

要建立安全连接以解引用 URI，客户端必须验证服务的标识是否与 URI 的源服务器匹配。证书验证用于防止路径攻击者或控制名称解析的攻击者冒充服务器。这个过程要求客户端配置一组信任锚点。

通常情况下，客户端必须使用 [RFC6125] 第 6 节中定义的验证过程来验证服务标识。客户端必须从服务的主机构建一个引用标识:如果主机是一个字面的 IP 地址(第4.3.5节)，引用标识是一个 IP-ID，否则主机是一个名称，引用标识是一个 DNS-ID。

客户端不能使用类型为 CN-ID 的引用标识。如[RFC6125]的6.2.1节所述，旧的客户端可能会使用类型为 CN-ID 的引用标识。

客户端可能经过特殊配置，以接受另一种形式的服务器身份验证。例如，一个客户端可能连接到一个地址和主机名都是动态的服务器，期望该服务提供一个特定的证书(或一个与某些外部定义的引用标识匹配的证书)，而不是一个与目标URI的来源匹配的证书。

在特殊情况下，客户端可以简单地忽略服务器的身份，但必须理解这将使连接对主动攻击敞开大门。

如果证书对目标 URI 的来源无效，则用户代理必须在继续操作之前获得用户的确认(参见3.5节)，或者因证书错误而终止连接。自动化客户端必须将错误记录到适当的审计日志中(如果有的话)，并且应该终止连接(因为证书错误)。自动化客户端可以提供禁用此检查的配置设置，但必须提供启用此检查的设置。

#### 4.3.5. IP-ID Reference Identity

使用 “https” URI 的 “host” 字段中的 IP 地址字面值标识的服务器具有 IP-ID 类型的引用标识。一个 IPv4 的地址使用 “IPv4address” ABNF规则，一个IPv6 的地址使用 “IP-literal” 产生的“IPv6address” 选项;参见 [URI]的3.2.2 节。IP-ID 的引用标识包含IP地址的解码字节。

IP版本4的地址是4个字节，IP版本6的地址是16个字节。没有为任何其他IP版本定义 IP-ID 的使用。证书 subjectAltName 扩展中的 iPAddress 选项没有显式地包括 IP 版本，因此依赖于地址的长度来区分版本;参见[RFC5280]的 4.2.1.6 节。

如果地址与证书的 subjectAltName 扩展名的 iPAddress 值相同，则匹配 IP-ID 类型的引用标识。

## 5. Fields

HTTP使用“字段”以可扩展的名称/值对的形式提供具有注册密钥名称空间的数据。字段在消息的头和尾部分中发送和接收(第6节)。

### 5.1. Field Names

字段名将对应的字段值标记为具有由该名称定义的语义。例如，Date 报头字段在第 6.6.1 节中定义为包含它出现的消息的起源时间戳。

```
  field-name     = token
```

字段名不区分大小写，应该在“超文本传输协议(HTTP)字段名注册表”中注册;参见 16.3.1 节。

一个字段的解释在相同的主HTTP版本的次要版本之间不会改变，尽管在缺少这样一个字段时，接收方的默认行为可能会改变。除非另有指定，否则字段将为所有 HTTP 版本定义。特别是，Host 和 Connection 字段应该被所有 HTTP 实现所识别，无论它们是否宣称符合 HTTP/1.1。

如果定义的语义允许不识别它们的接收者安全地忽略它们，则可以在不改变协议版本的情况下引入新字段;参见 16.3 节。

代理必须转发无法识别的报头字段，除非字段名列在 Connection 报头字段中(章节7.6.1)，或者代理被专门配置为阻塞或转换此类字段。其他收件人应忽略未识别的头和尾字段。遵循这些要求可以在不更新或删除已部署的中介的情况下扩展 HTTP 的功能。

### 5.2. Field Lines and Combined Field Value

字段段由任意数量的“字段行”组成，每一行都有一个“字段名”(见章节5.1)来标识该字段，以及一个“字段行值”来传达该字段实例的数据。

当一个字段名在一个节中只出现一次时，该字段的组合“字段值”由相应的字段行值组成。当一个字段名在一个节中重复时，它的组合字段值由该节中相应的字段行值列表组成，按顺序连接，每个字段行值用逗号分隔。

例如，这一节:

```
Example-Field: Foo, Bar
Example-Field: Baz
```

包含两个字段行，字段名都是“Example-Field”。第一个字段行值为“Foo, Bar”，而第二个字段行值为“Baz”。Example-Field 的字段值是列表“Foo, Bar, Baz”。

### 5.3. Field Order

接收方可以将字段段内具有相同字段名的多个字段行合并到一个字段行中，而不改变消息的语义，方法是将每个后续字段行值按顺序附加到初始字段行值，用逗号(“，”)和可选的空白符(OWS，定义于章节5.6.3)分隔。为了保持一致性，请使用逗号 SP。

因此，接收具有相同名称的字段行的顺序对于字段值的解释很重要;代理在转发消息时绝对不能改变这些字段行值的顺序。

这意味着,除了著名的例外下面提到的,发送者不能生成多个具有相同名称的电场线的一条消息中(无论是在标题或预告片)或附加字段线当一个字段已经存在相同名称的信息,除非该字段的定义允许多个字段行被重组为一个以逗号分隔值(也就是说,至少有一个替代字段定义允许一个逗号分隔的列表,例如在章节5.6.1中定义的#(值)的ABNF规则)。

> 注意:在实际操作中，“Set-Cookie”报头字段([COOKIE])经常跨多个字段行出现在响应消息中，并且不使用列表语法，违反了上述对多个字段行具有相同字段名的要求。由于它不能组合成一个单独的字段值，收件人在处理字段时应该把“Set-Cookie”作为一个特殊情况来处理。(详见[Kri2001]附录A.2.3。)

在一个节中接收具有不同字段名的字段行的顺序并不重要。但是，最好先发送包含额外控制数据的报头字段，例如请求上的 Host 和响应上的 Date，这样实现就可以尽早决定什么时候不处理消息。

服务器在收到完整的请求头部分之前绝对不能向目标资源应用请求，因为后面的头字段行可能包括条件、身份验证凭据或故意误导的重复头字段，这些可能会影响请求处理。

### 5.4. Field Limits

HTTP 不会对每个字段行、字段值的长度或头或尾部分的长度进行预定义限制，如第2节所述。在实践中可以发现对单个长度的各种临时限制，通常取决于特定字段的语义。

服务器接收到一个请求头字段行、字段值或一组大于它希望处理的字段时，必须响应一个适当的 4xx(客户端错误)状态码。忽略这样的报头字段会增加服务器对请求走私攻击的脆弱性([HTTP/1.1]第11.2节)。

如果字段语义可以在不改变消息帧或响应语义的情况下安全忽略所丢弃的值，则客户端可以丢弃或截断接收到的比客户端希望处理的字段行大的字段行。

### 5.5. Field Values

HTTP 字段值由字段语法定义的格式的字符序列组成。每个字段的语法通常使用ABNF ([RFC5234])定义。

```
  field-value    = *field-content
  field-content  = field-vchar
                   [ 1*( SP / HTAB / field-vchar ) field-vchar ]
  field-vchar    = VCHAR / obs-text
  obs-text       = %x80-FF
```

字段值不包括前导或尾随空格。当特定版本的 HTTP 允许在消息中出现此类空白时，字段解析实现必须在计算字段值之前排除此类空白。

字段值通常被限制为 US-ASCII 字符的范围[USASCII]。需要更大范围字符的字段可以使用一种编码，例如[RFC8187]中定义的编码。历史上，HTTP 允许包含 ISO-8859-1 字符集[ISO-8859-1]文本的字段内容，仅通过使用[RFC2047]编码支持其他字符集。新定义字段的规范应该将其值限制为可见的 US-ASCII字节(VCHAR)、SP 和 HTAB。接收方应该将字段内容中其他允许的八字节(即obs-text)视为不透明数据。

包含 CR、LF 或 NUL 字符的字段值是无效和危险的，因为实现可能以不同的方式解析和解释这些字符;字段值中的 CR、LF 或 NUL 的接收者必须在进一步处理或转发该消息之前，要么拒绝该消息，要么用SP替换这些字符。包含其他CTL字符的字段值也是无效的;然而，当这些字符出现在一个安全的上下文中(例如，一个应用程序特定的带引号的字符串，不会被任何下游HTTP解析器处理)，出于健壮性的考虑，接收方可以保留这些字符。

只期望一个成员作为字段值的字段称为“单例字段”。

允许多个成员作为字段值的字段被称为“基于列表的字段”。第5.6.1节的列表操作符扩展被用作定义可以包含多个成员的字段值的通用符号。

因为逗号(“，”)被用作成员之间的分隔符，所以如果允许它们作为成员中的数据，则需要小心对待它们。对于基于列表的字段和单例字段都是如此，因为单例字段可能会错误地发送多个成员，检测此类错误可以提高互操作性。希望在成员中包含逗号的字段，例如在 HTTP-date 或 URI-reference 元素中，应该在该元素周围定义分隔符，以区分该数据中的任何逗号与潜在的列表分隔符。

例如，文本日期和URI(其中任何一个都可能包含逗号)可以安全地包含在基于列表的字段值中，如下所示:

```
Example-URIs: "http://example.com/a.html,foo",
              "http://without-a-comma.example.com/"
Example-Dates: "Sat, 04 May 1996", "Wed, 14 Sep 2005"
```

注意，双引号分隔符几乎总是用于带引号的字符串(第5.6.4节);在双引号内使用不同的语法可能会引起不必要的混淆。

许多字段(如Content-Type，在章节8.3中定义)使用一种通用的参数语法，允许参数值使用不带引号(token)和带引号(quote-string)语法(章节5.6.6)。使用通用语法允许接收者重用现有的解析器组件。当允许两种形式时，参数值的含义应该是相同的，无论它是作为一个标记还是一个带引号的字符串接收。

> 注意:为了定义字段值语法，本规范使用一个以字段名命名的 ABNF 规则来定义该字段值的允许语法(在从底层消息传递语法中提取该值并将多个实例组合到一个列表之后)。

### 5.6. Common Rules for Defining Field Values

#### 5.6.1. Lists (#rule ABNF Extension)

对 [RFC5234] 的 ABNF 规则的 #rule 扩展用于提高一些基于列表的字段值定义的可读性。

定义了一个结构 “#”，类似于 “*”，用于定义以逗号分隔的元素列表。完整形式为 "<n>#<m>element"，表示至少<n>，最多<m>元素，每个元素由单个逗号(",")和可选的空格(OWS，定义于章节5.6.3)分隔。

##### 5.6.1.1. Sender Requirements

在任何使用列表结构的产品中，发送方绝对不能生成空列表元素。换句话说，发送方必须生成满足以下语法的列表:

```
  1#element => element *( OWS "," OWS element )
```

或者

```
  #element => [ 1#element ]
```
对于 n >= 1 并且 m > 1:

```
  <n>#<m>element => element <n-1>*<m-1>( OWS "," OWS element )
```

附录 A 显示了列表结构展开后为发送者收集的 ABNF。

##### 5.6.1.2. Recipient Requirements

空元素不影响当前元素的计数。接收方必须解析并忽略合理数量的空列表元素:足够处理发送方合并值时的常见错误，但又不能过多到可以用作拒绝服务机制的程度。换句话说，接收方必须接受满足以下语法的列表:

```
  #element => [ element ] *( OWS "," OWS [ element ] )
```

请注意，由于可能存在空列表元素，RFC 5234 ABNF不能强制列表元素的基数，因此所有情况的映射就像没有指定基数一样。

例如，给定这些 ABNF 结果:

```
  example-list      = 1#example-list-elmt
  example-list-elmt = token ; see Section 5.6.2
```

下面是 example-list 的有效值(不包括双引号，双引号仅用于定界):

```
  "foo,bar"
  "foo ,bar,"
  "foo , ,bar,charlie"
```

相反，以下值将无效，因为示例列表生成至少需要一个非空元素:

```
  ""
  ","
  ",   ,"
```

#### 5.6.2. Tokens

令牌是不包括空格或分隔符的短文本标识符。

```
  token          = 1*tchar

  tchar          = "!" / "#" / "$" / "%" / "&" / "'" / "*"
                 / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
                 / DIGIT / ALPHA
                 ; any VCHAR, except delimiters
```

许多 HTTP 字段值是使用通用语法组件定义的，由空格或特定的分隔字符分隔。分隔符从令牌中不允许的 US-ASCII 可视字符集中选择 (DQUOTE 和 "()，/:;<=>?@[\]{}")。

#### 5.6.3. Whitespace

该规范使用三个规则来表示线性空白的使用: OWS(可选空白)、RWS(必需空白) 和 BWS(“坏”空白)。

OWS 规则用于可能出现零个或多个线性空白八位字节的地方。对于协议元素，可选的空白是为了提高可读性，发送方应该生成可选的空白作为单个 SP; 否则，发送方不应该生成可选的空白，除非在消息过滤过程中需要覆盖无效或不需要的协议元素。

当至少需要一个线性空白字节来分隔字段令牌时，使用 RWS 规则。发送方应该将 RWS 生成为单个 SP。

OWS 和 RWS 与单个 SP 具有相同的语义。任何已知定义为 OWS 或 RWS 的内容都可以在解释或向下游转发消息之前被单个 SP 替换。

BWS 规则用于仅由于历史原因而允许可选空格的语法。发送方绝对不能在消息中生成 BWS。在解释协议元素之前，接收方必须解析这种糟糕的空白并将其删除。

BWS 没有语义。任何已知定义为 BWS 的内容都可以在解释它或向下游转发消息之前删除。

```
  OWS            = *( SP / HTAB )
                 ; optional whitespace
  RWS            = 1*( SP / HTAB )
                 ; required whitespace
  BWS            = OWS
                 ; "bad" whitespace
```

#### 5.6.4. Quoted Strings

如果使用双引号引用文本字符串，则将其解析为单个值。

```
  quoted-string  = DQUOTE *( qdtext / quoted-pair ) DQUOTE
  qdtext         = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text
```

反斜杠("\")可以在引用字符串和注释结构中用作单字节引用机制。处理带引号字符串值的接收方必须处理带引号对，就像它被反斜杠后面的字节所取代一样。

```
  quoted-pair    = "\" ( HTAB / SP / VCHAR / obs-text )
```
发送方不应该在带引号的字符串中生成带引号对，除非需要在该字符串中引用 DQUOTE 和 反斜杠字节。发送方不应该在注释中生成引号对，除非需要引用括号["("和")]以及注释中出现的反斜杠字节。

#### 5.6.5. Comments

注释可以通过用圆括号括起注释文本来包含在某些 HTTP 字段中。注释只允许在字段值定义中包含 “comment” 的字段中使用。

```
  comment        = "(" *( ctext / quoted-pair / comment ) ")"
  ctext          = HTAB / SP / %x21-27 / %x2A-5B / %x5D-7E / obs-text
```

#### 5.6.6. Parameters

参数是名称/值对的实例;它们通常用于字段值中，作为向项附加辅助信息的通用语法。每个参数通常由紧接在前面的分号分隔。

```
  parameters      = *( OWS ";" OWS [ parameter ] )
  parameter       = parameter-name "=" parameter-value
  parameter-name  = token
  parameter-value = ( token / quoted-string )
```
参数名称不区分大小写。参数值可能区分大小写，也可能不区分大小写，这取决于参数名称的语义。参数和一些等效形式的例子可以在媒体类型(章节8.3.1)和Accept报头字段(章节12.5.1)中看到。

与生成的令牌匹配的参数值可以作为令牌传输，也可以在引号字符串中传输。加引号和不加引号的值是等价的。

> 注意:参数不允许 “=” 字符周围有空格(甚至是“坏”空格)。

#### 5.6.7. Date/Time Formats

在 1995 年之前，服务器通常使用三种不同的格式来通信时间戳。为了与旧的实现兼容，这里定义了这三个实现。首选格式是 Internet 消息格式 [RFC5322] 使用的日期和时间规范的固定长度和单区域子集。

```
  HTTP-date    = IMF-fixdate / obs-date
```

一个首选格式的例子:

```
  Sun, 06 Nov 1994 08:49:37 GMT    ; IMF-fixdate
```

两种过时格式的例子:

```
  Sunday, 06-Nov-94 08:49:37 GMT   ; obsolete RFC 850 format
  Sun Nov  6 08:49:37 1994         ; ANSI C's asctime() format
```

解析 HTTP 字段中的时间戳值的接收方必须接受所有三种 HTTP-date 格式。当发送方生成一个包含一个或多个定义为 HTTP-date 的时间戳的字段时，发送方必须以 IMF-fixdate 格式生成这些时间戳。

HTTP-date 值将时间表示为协调世界时(UTC)的一个实例。前两种格式用格林尼治标准时间的三个字母缩写 “GMT” 表示 UTC，这是 UTC 名称的前身; asctime 格式的值被假定为 UTC。

“时钟” 是一种能够提供合理的 UTC 当前时刻近似值的实现。时钟实现应该使用 NTP ([RFC5905]) 或一些类似的协议来与 UTC 同步。

首选格式：

```
  IMF-fixdate  = day-name "," SP date1 SP time-of-day SP GMT
  ; fixed length/zone/capitalization subset of the format
  ; see Section 3.3 of [RFC5322]

  day-name     = %s"Mon" / %s"Tue" / %s"Wed"
               / %s"Thu" / %s"Fri" / %s"Sat" / %s"Sun"

  date1        = day SP month SP year
               ; e.g., 02 Jun 1982

  day          = 2DIGIT
  month        = %s"Jan" / %s"Feb" / %s"Mar" / %s"Apr"
               / %s"May" / %s"Jun" / %s"Jul" / %s"Aug"
               / %s"Sep" / %s"Oct" / %s"Nov" / %s"Dec"
  year         = 4DIGIT

  GMT          = %s"GMT"

  time-of-day  = hour ":" minute ":" second
               ; 00:00:00 - 23:59:60 (leap second)

  hour         = 2DIGIT
  minute       = 2DIGIT
  second       = 2DIGIT

```

过时的格式：

```
  obs-date     = rfc850-date / asctime-date
```

```
  rfc850-date  = day-name-l "," SP date2 SP time-of-day SP GMT
  date2        = day "-" month "-" 2DIGIT
               ; e.g., 02-Jun-82

  day-name-l   = %s"Monday" / %s"Tuesday" / %s"Wednesday"
               / %s"Thursday" / %s"Friday" / %s"Saturday"
               / %s"Sunday"
```

```
  asctime-date = day-name SP date3 SP time-of-day SP year
  date3        = month SP ( 2DIGIT / ( SP 1DIGIT ))
               ; e.g., Jun  2
```

HTTP-date 区分大小写。注意，[CACHING] 的 4.2 节对缓存接收者放宽了限制。

发送方绝对不能在 HTTP-date 中生成除语法中明确包含的 SP 之外的额外空白。日-名称、日、月、年和时间的语义与具有相应名称的 Internet Message Format 构造的语义相同([RFC5322]，章节 3.3)。

接收到 rfc850-date 格式的时间戳值(使用两位数年份)的接收者必须将看起来超过 50 年的时间戳解释为表示过去最近的年份，并且具有相同的后两位数字。

除非字段定义另有限制，否则鼓励时间戳值的接收者健壮地解析时间戳。例如，消息有时会通过 HTTP 从非 HTTP 源转发，该源可能生成 Internet 消息格式定义的任何日期和时间规范。

> 注意:HTTP 对时间戳格式的要求只适用于它们在协议流中的使用。实现不需要在用户表示、请求日志记录等方面使用这些格式。

## 6. Message Abstraction

HTTP 的每个主要版本都定义了自己的通信语法。本节基于这些消息特征、公共结构和传递语义的能力的泛化，为 HTTP 消息定义了一个抽象数据类型。此抽象用于定义独立于 HTTP 版本的发送方和接收方的需求，以便一个版本的消息可以在不改变其含义的情况下通过其他版本进行转发。

一个“消息”由以下部分组成:

- 控制数据来描述和路由消息；
- 一个名称/值对的头查找表，用于扩展控制数据并传递关于发送者、消息、内容或上下文的附加信息；
- 一个潜在的无限内容流；
- 一个名称/值对的 trailer 查找表，用于通信在发送内容时获得的信息；

首先发送帧(Framing)和控制数据，然后是包含 headers 表字段的 header 部分。当消息包含内容时，内容将在header部分之后发送，可能随后是一个 trailer 部分，其中可能包含预告片表的字段。

消息被期望作为流进行处理，其中流的目的及其继续处理在读取时显示出来。因此，控制数据描述了接收者需要立即知道的内容，首部字段描述了在接收内容之前需要知道的内容，内容(在存在时)可能包含接收者想要或需要实现消息语义的内容，而 trailer 字段提供了在发送内容之前未知的可选元数据。

消息的目的是“自描述”:在解码或重组传输中被压缩或省略的部分后，接收者需要知道的关于消息的一切都可以通过查看消息本身来确定，而不需要了解发送者当前的应用程序状态(通过之前的消息建立)。然而，客户端必须在解析、解释或缓存相应的响应时保留请求的信息。例如，HEAD 方法的响应看起来就像 GET 响应的开头，但不能以相同的方式解析。

请注意，这种消息抽象是跨多个 HTTP 版本的泛化，包括某些版本可能没有的功能。例如，trailer 字段是在 HTTP/1.1 分块传输编码中引入的，作为内容之后的附加部分。在 HTTP/2 和 HTTP/3 中，终止每个流的首部块中也存在一个等效的特性。

### 6.1. Framing and Completeness

消息分帧指示每个消息如何开始和结束，以便将每个消息与同一连接上的其他消息或噪声区分开来。HTTP 的每个主要版本都定义了自己的分帧机制。

HTTP/0.9 和 HTTP/1.0 的早期部署使用了关闭底层连接来结束响应。为了向后兼容，HTTP/1.1 也允许这种隐式分帧。然而，如果连接提前关闭，隐式分帧可能无法区分不完整的响应。因此，几乎所有现代实现都以长度定界的消息数据序列的形式使用显式分帧。

当一个消息的帧表示的所有字节都可用时，该消息被认为是“完成的”。请注意，如果没有显式使用分帧，则底层连接关闭后结束的响应消息被认为是完整的，即使它可能与不完整的响应无法区分，除非传输层错误表明它不完整。

### 6.2. Control Data

消息以描述其主要用途的控制数据开始。请求消息控制数据包括请求方法(第 9 节)、请求目标(第 7.1 节)和协议版本(第 2.5 节)。响应消息控制数据包括状态码(第 15 节)、可选原因短语和协议版本。

在 HTTP/1.1 ([HTTP/1.1]) 及更早版本中，控制数据作为消息的第一行发送。在 HTTP/2 ([HTTP/2]) 和 HTTP/3 ([HTTP/3]) 中，控制数据以带有 保留名称前缀 的 伪首部字段 形式发送(例如，":authority")。

每个 HTTP 消息都有一个协议版本。根据使用的版本，它可以在消息中明确标识，也可以由接收消息的连接推断。接收方使用该版本信息来确定日后与该发送方通信的限制或潜力。

当消息被一个中介转发时，协议版本被更新以反映该中介使用的版本。Via 头字段(章节 7.6.3 )用于在转发的消息中通信上游协议信息。

客户端发送的请求版本应该等于符合要求的最高版本，且主版本不高于服务器支持的最高版本(前提是知道这一点)。客户端不能发送不符合的版本。

如果客户端知道服务器没有正确地实现 HTTP 规范，则可以发送低版本的请求。但只有在客户端尝试了至少一个正常的请求，并从响应状态码或首部字段(例如 server )中确定服务器没有正确地处理高版本的请求之后，才会发送低版本的请求。

服务器发送的响应版本应该等于与服务器一致的最高版本，且主版本小于或等于请求中接收到的版本。服务器不能发送与之不一致的版本。如果服务器出于任何原因希望拒绝客户端主要协议版本的服务，则可以发送 505 (HTTP Version Not Supported) 响应。

接收到具有其实现的主版本号和高于其实现的次版本号的消息的收件人应该处理该消息，就好像该消息属于该收件人符合的主版本中最高的次版本一样。当发送给尚未表示支持更高版本的接收方时，接收方可以假定具有更高次版本的消息具有足够的向后兼容性，可以由相同主版本的任何实现安全地处理。

### 6.3. Header Fields

在内容之前发送或接收的字段(第5节)称为 “报头字段” (通俗地说，就是“报头”)。

消息的“标题部分”由一系列标题字段行组成。每个头字段可以修改或扩展消息语义、描述发送者、定义内容或提供额外的上下文。

> 注意:当命名字段只允许在 header 部分发送时，我们将其特别称为 “header 字段”。

### 6.4. Content

HTTP 消息通常以消息“内容”的形式传输完整或部分表示:由字节组成的流，在消息的首部部分之后发送，由消息帧描述。

内容的抽象定义反映了从消息框架中提取出来的数据。例如，一个HTTP/1.1 消息体([HTTP/1.1]第 6 节) 可能包含一个用分块传输编码编码的数据流，一个数据块序列，一个零长度的块和一个 trailer 字段，而同一消息的内容只包括传输编码解码后的数据流;它不包括块长度、分块分帧语法，也不包括 trailer 字段(第6.5节)。

注意:有些字段名有 "Content-" 前缀。这是一个非正式的惯例；正如上文定义的，其中一些字段引用消息的内容，而其他字段则仅限于所选择的表示形式(第 3.2 节)。请参阅各个字段的定义以消除歧义。

#### 6.4.1. Content Semantics

请求内容的目的由方法语义(第9节)定义。

例如，PUT 请求内容中的表示(章节 9.3.4)表示成功应用请求后目标资源的期望状态，而 POST 请求内容中的表示(章节9.3.3)表示目标资源要处理的信息。

在响应中，内容的用途由请求方法、响应状态码(第15节)和描述该内容的响应字段定义。例如，对 GET 的 200 (OK) 响应的内容(章节 9.3.1)表示在消息发起日期时观察到的目标资源的当前状态(章节 6.6.1)，而对 POST 的响应中的相同状态码的内容可能表示处理结果或应用处理后目标资源的新状态。

要获取的 206(Partial Content) 响应的内容要么包含所选表示的单个部分，要么包含该表示的多个部分的多部分消息体，如 15.3.7 节所述。

带有错误状态码的响应消息通常包含表示错误条件的内容，这样内容就描述了错误状态和解决错误的建议步骤。

对 HEAD 请求方法的响应(章节9.3.2)从不包含内容；相关的响应头字段只表明如果请求方法是 GET(章节9.3.1)，它们的值会是什么。

2xx(Successful) 响应对应 CONNECT 请求，将连接切换到隧道模式。

所有 1xx (Informational)、204(No content) 和 304(Not Modified) 响应都不包含内容。

所有其他响应都包含内容，尽管该内容的长度可能为 0。

#### 6.4.2. Identifying Content

当完整或部分表示作为消息内容传输时，通常希望发送方提供或接收方确定与该特定表示相对应的资源的标识符。例如，客户端向资源发出 GET 请求，请求 “当前天气报告”，可能需要一个特定于返回内容的标识符(例如，“拉古纳海滩 20210720T1711 的天气报告”)。这对于共享或标记资源内容很有用，这些资源的表示形式预计会随着时间的推移而变化。

对于请求消息:

- 如果请求有 Content-Location 头字段，那么发送方断言内容是由 Content-Location 字段值标识的资源的表示。但是，这样的断言是不可信的，除非它可以通过其他方法进行验证(本规范没有定义)。这些信息对于修订历史链接可能仍然有用。
- 否则，内容将无法被 HTTP 识别，但内容本身可能提供更具体的标识符。

对于响应消息，按顺序应用以下规则，直到找到匹配项:

1. 如果请求方法为 HEAD，或者响应状态码为 204(No Content) 或 304(Not Modified)，则响应中没有内容。
2. 如果请求方法是 GET，响应状态码是 200 (OK)，则内容是目标资源的表示(章节 7.1)。
3. 如果请求方法是 GET，响应状态码是 203(Non-Authoritative)，则内容是由中介提供的目标资源的潜在修改或增强表示。
4. 如果请求方法是 GET，响应状态码是 206(Partial content)，则内容是目标资源表示的一个或多个部分。
5. 如果响应具有 Content-Location 头字段，并且其字段值是对与目标 URI 相同的 URI 的引用，则内容是目标资源的表示。
6. 如果响应有一个 Content-Location 头字段，并且它的字段值是对一个不同于目标 URI 的 URI 的引用，那么发送方断言内容是由 Content-Location 字段值标识的资源的表示。但是，这样的断言是不可信的，除非它可以通过其他方法进行验证(本规范没有定义)。
7. 否则，内容将无法被 HTTP 识别，但内容本身可能提供更具体的标识符。

### 6.5. Trailer Fields

位于 trailer seciton 中的字段(第5节)被称为 "trailer fields"(通俗地说，就是 “trailers”)。trailer 字段对于提供消息完整性检查、数字签名、交付度量或后处理状态信息非常有用。

Trailer 字段应该与 header 部分的字段分开处理和存储，以避免在 header 部分完成时已知的消息语义相互矛盾。某些首部字段的存在或缺失可能会影响在接收到 trailer fields 之前对整个消息进行路由或处理的选择；这些选择不能被后来发现的 trailer 字段所撤销。

#### 6.5.1. Limitations on Use of Trailers

只有在当前使用的 HTTP 版本支持并通过显式分帧机制启用的情况下，才可能出现 trailer 字段。例如，HTTP/1.1 中的分块传输编码允许在内容之后发送 trailer 字段 ([HTTP/1.1]的 7.1.2 节)。

许多字段不能在首部部分之外处理，因为在接收内容之前必须对它们进行评估，例如那些描述消息分帧、路由、身份验证、请求修饰符、响应控制或内容格式的字段。发送方必须不生成 trailer 字段，除非发送方知道相应的头字段名称的定义允许该字段以 trailer形式发送。

trailer 字段很难被从一个协议版本转发到另一个协议版本的中介体处理。如果在传输过程中可以缓冲整个消息，一些中间设备可以在转发消息之前将 trailer 字段合并到 header 部分(视情况而定)。然而，在大多数情况下，trailer 会被直接丢弃。除非收件人理解相应的头字段定义，并且该定义明确允许并定义如何安全地合并 trailer 字段值，否则不得将 trailer 字段合并到头部分。

关键字 "trailers" 出现在一个请求的 TE 头字段(章节10.1.4)中，表明客户端愿意接受 trailer 字段，代表自己和任何下游客户。对于来自中介体的请求，这意味着所有下游客户端都愿意接受转发的响应中的 trailer 字段。注意，"trailers" 的存在并不意味着客户端会处理响应中任何特定的 trailer 字段；只有 trailer 部分不会被任何客户端删除。

因为 trailer 字段可能会在传输过程中被丢弃，所以服务器不应该生成它认为用户代理需要接收的 trailer 字段。

#### 6.5.2. Processing Trailer Fields

可以发送 "Trailer" 头字段(章节6.6.2)来表示可能在 Trailer 部分发送的字段，这允许接收方在处理内容之前准备接收。例如，如果字段名表明在接收到内容时应该计算动态校验和，然后在收到 trailer 字段值后立即检查，那么这可能很有用。

与头字段一样，具有相同名称的 trailer 字段按照接收到的顺序进行处理;具有相同名称的多个 trailer 字段行具有等价于将多个值附加为成员列表的语义。即使每个成员值在接收到的字段行中只处理一次，也必须将在消息期间可能生成多次的尾部字段定义为基于列表的字段。

在消息的结尾，收件人可以将接收到的 trailer 字段集视为名称/值对的数据结构，类似于(分离的)首部字段。额外的处理期望，如果有，可以在字段规范中定义用于 trailer 字段。

### 6.6. Message Metadata

描述消息本身的字段，例如消息是何时以及如何生成的，可以出现在请求和响应中。

#### 6.6.1. Date

"Date" 报头字段表示消息产生的日期和时间，与 [RFC5322] 节 3.6.1 中定义的起源日期字段(orig-date)具有相同的语义。该字段的值是 HTTP-date 类型，定义在 5.6.7 节中。

```
  Date = HTTP-date
```
示例：

```
Date: Tue, 15 Nov 1994 08:12:31 GMT
```

生成日期头字段的发送方应将其字段值生成为生成消息的日期和时间的最佳近似值。理论上，日期应该表示生成消息内容之前的时刻。实际上，发送者可以在消息发起过程中的任何时间生成日期值。

带有时钟的源服务器(如 5.6.7 节所定义)必须在所有 2xx(Successful)、3xx(Redirection) 和 4xx(Client Error) 响应中生成一个日期头字段，并且可能在 1xx(Informational) 和 5xx(Server Error) 响应中生成一个日期头字段。

没有时钟的源服务器不能生成日期头字段。

具有时钟的接收方在接收没有日期头字段的响应消息时，必须记录接收到的时间，如果消息被缓存或转发到下游，则将相应的日期头字段附加到消息的头部分。

具有时钟的收件人在收到具有无效日期头字段值的响应时，可以将该值替换为接收响应的时间。

用户代理可以在请求中发送日期头字段，但通常不会这样做，除非它被认为可以向服务器传递有用的信息。例如，如果希望服务器根据用户代理和服务器时钟之间的差异调整其对用户请求的解释，自定义HTTP应用程序可能会传递一个日期。

#### 6.6.2. Trailer

"Trailer" 报头字段提供了一个字段名称列表，发送方希望在该消息中作为 trailer 字段发送。这允许接收方在开始处理内容之前准备接收指定的元数据。

```
  Trailer = #field-name
```
例如，发送者可能表示将在流式内容时计算签名，并以 trailer 字段的形式提供最终签名。这允许接收方在接收内容时执行相同的检查。

打算在消息中生成一个或多个 trailer 字段的发送者应该在该消息的 header 部分生成一个 trailer 头字段，以指示哪些字段可能出现在预告片中。

如果一个中介体在传输过程中丢弃了 trailer 部分，那么 trailer 字段可以提供元数据丢失的提示，尽管不能保证 trailer 的发送方总是会发送命名字段。

## 7. Routing HTTP Messages

HTTP 请求消息路由由每个客户机根据目标资源、客户机的代理配置和入站连接的建立或重用确定。对应的响应路由遵循相同的连接链返回客户端。

### 7.1. Determining the Target Resource

虽然很多应用程序都使用 HTTP，但大多数客户端依赖与通用 Web 浏览器相同的资源标识机制和配置技术。即使通信选项硬编码在客户端配置中，我们也可以把它们组合起来的效果看作 URI 引用(4.1节)。

URI 引用被解析为其绝对形式，以便获得“目标 URI”。目标 URI排除引用的片段组件(如果有的话)，因为片段标识符是为客户端处理保留的([URI]，第3.5节)。

要对“目标资源”执行操作，客户端发送一个请求消息，其中包含其已解析的目标 URI 的足够组件，以使接收者能够识别相同的资源。由于历史原因，解析后的目标 URI 组件，合称“请求目标”，在消息控制数据和主机首部字段中发送(章节7.2)。

有两种不常见的情况，请求目标组件是特定于方法的形式。

- 对于 CONNECT (章节 9.3.6)，请求目标是隧道目的端的主机名和端口号，用冒号分隔。
- 对于 OPTIONS (章节9.3.7)，请求目标可以是一个星号(“*”)。

有关详细信息，请参阅相应的方法定义。这些表单不能与其他方法一起使用。

在收到客户端请求后，服务器根据接收到的组件的本地配置和传入的连接上下文重构目标 URI。这种重构是每个主协议版本特有的。例如，[HTTP/1.1] 的 3.3 节定义了服务器如何确定 HTTP/1.1 请求的目标 URI。

> 注意:以前的规范将重新组合的目标 URI 定义为一个不同的概念，即“有效请求URI”。

### 7.2. Host and :authority

请求中的 "Host" 头字段提供来自目标 URI 的主机和端口信息，使源服务器在为多个主机名的请求提供服务时能够区分资源。

在 HTTP/2 [HTTP/2] 和 HTTP/3 [HTTP/3] 中，Host 报头字段在某些情况下被请求控制数据的 ":authority" 伪报头字段所取代。

```
  Host = uri-host [ ":" port ] ; Section 4
```

目标 URI 的权限信息对于处理请求非常重要。用户代理必须在请求中生成 Host 报头字段，除非它以 ":authority" 伪报头字段的形式发送该信息。发送 Host 的用户代理应该将它作为请求头部分的第一个字段发送。

例如，对源服务器 <http://www.example.org/pub/WWW/> 的 GET 请求将以以下方式开始:

```
GET /pub/WWW/ HTTP/1.1
Host: www.example.org
```

由于主机和端口信息扮演着应用层路由机制的角色，它经常成为恶意软件的攻击目标，试图毒害共享缓存或将请求重定向到非预期的服务器。如果拦截代理依赖主机和端口信息将请求重定向到内部服务器，或者用作共享缓存中的缓存键，而没有首先验证被拦截的连接是否针对该主机的有效 IP 地址，那么它特别容易受到攻击。

### 7.3. Routing Inbound Requests

一旦确定了目标 URI 及其来源，客户端就会决定是否需要一个网络请求来完成所需的语义，如果是，则确定该请求的方向。

#### 7.3.1. To a Cache

如果客户端有缓存并且请求可以被它满足，那么请求通常会首先被定向到那里。

#### 7.3.2. To a Proxy

如果缓存不能满足请求，那么典型的客户端将检查其配置，以确定是否使用代理来满足请求。代理的配置取决于具体实现，但通常是基于 URI 前缀匹配、选择性授权机构匹配，或两者兼而有之。代理本身通常用 "http" 或 "https" URI 标识。

如果 "http" 或 "https" 代理适用，则客户端通过建立(或重用)到该代理的连接，然后向其发送包含与客户端目标 URI 匹配的请求目标的 http 请求消息来连接入站。

#### 7.3.3. To the Origin

如果没有代理可用，典型的客户端将调用处理程序例程(特定于目标 URI 的方案)以获得对标识资源的访问。这取决于目标 URI 模式，并由其相关规范定义。

第 4.3.2 节定义了如何通过建立(或重用)到标识的源服务器的入站连接，然后向它发送一个 http 请求消息，其中包含与客户端的目标 URI 匹配的请求目标，从而获得对 "http" 资源的访问权。

第 4.3.3 节定义了如何通过建立(或重用)到源服务器的入站安全连接来获得对 "https" 资源的访问权，该连接对已识别的源具有权威性，然后向它发送一个 HTTP 请求消息，其中包含与客户端的目标 URI 匹配的请求目标。

### 7.4. Rejecting Misdirected Requests

一旦服务器接收到请求并充分解析以确定其目标URI，服务器将决定是否自己处理请求、将请求转发到另一个服务器、将客户端重定向到不同的资源、响应错误或放弃连接。该决定可以受到请求或连接上下文的任何影响，但具体针对的是服务器是否已配置为处理针对目标 URI 的请求，以及连接上下文是否适合该请求。

例如，一个请求可能被故意或无意地误导了，以至于接收到的 Host 首部字段中的信息与连接的主机或端口不同。如果连接来自可信网关，则可能会出现这种不一致;否则，它可能表明试图绕过安全过滤器，欺骗服务器传递非公开内容，或毒害缓存。有关消息路由的安全性考虑，请参见第 17 节。

除非连接来自可信网关，否则如果目标 URI 的任何特定于方案的要求不满足，则源服务器必须拒绝请求。特别是，对 "https" 资源的请求必须被拒绝，除非它是通过一个通过目标URI来源的有效证书(如章节4.2.2所定义)保护的连接接收的。

响应中的 421(Misdirected Request) 状态码表明源服务器已经拒绝了该请求，因为它看起来是被误定向的(章节 15.5.20)。

### 7.5. Response Correlation

一个连接可能用于多个 请求/响应 交换。用于关联请求和响应消息的机制是版本相关的。某些版本的 HTTP 使用隐式消息排序，而其他版本则使用显式标识符。

所有响应，无论状态码(包括临时响应)，都可以在接收到请求后的任何时间发送，即使请求尚未完成。响应可以在其相应的请求完成之前完成(章节6.1)。同样，客户端也不需要为响应等待任何特定的时间。如果在一段合理的时间内没有收到响应，客户端(包括中间设备)可能会放弃请求。

在发送相关请求的同时收到响应的客户端应该继续发送该请求，除非它收到明确的相反指示(参见，例如 [HTTP/1.1] 的 9.5 节和 [HTTP/2] 的 6.4 节)。

### 7.6. Message Forwarding

如 3.7 节所述，中介体在处理 HTTP 请求和响应时可以扮演多种角色。一些中间设备用于提高性能或可用性。其他用于访问控制或过滤内容。由于 HTTP 流具有类似于管道和过滤器架构的特征，因此中介体对流的任何方向的增强(或干扰)都没有内在的限制。

即使协议元素没有被识别(例如，新方法、状态码或字段名)，中介也应该转发消息，因为这为下游接收者保留了可扩展性。

不作为隧道的中介体必须实现 7.6.1 节中指定的连接头字段，并排除那些只用于传入连接的字段。

除非受到无限请求循环的保护，否则中介体不能将消息转发给自身。一般来说，中介应该识别自己的服务器名，包括别名、本地变体或字面 IP 地址，并直接响应此类请求。

HTTP 消息可以被解析为流进行增量处理或向下游转发。然而，发送方和接收方不能依赖部分消息的增量交付，因为有些实现会缓冲或延迟消息转发，以提高网络效率、安全检查或内容转换。

#### 7.6.1. Connection

"Connection" 头字段允许发送方列出当前连接所需的控制选项。

```
  Connection        = #connection-option
  connection-option = token
```

连接选项不区分大小写。

当连接之外的字段用于提供当前连接的控制信息时，发送方必须在连接头字段中列出相应的字段名。注意，某些版本的 HTTP 禁止使用用于此类信息的字段，因此不允许使用 Connection 字段。

在转发消息之前，中介体必须解析接收到的 Connection header 字段，并且对于该字段中的每个连接选项，删除与该连接选项同名的任何 header 或 trailer 字段，然后删除连接 header 字段本身(或者用中介体自己对所转发消息的控制选项替换它)。

因此，连接首部字段提供了一种声明性的方式，区分哪些字段只针对直接接收者("hop-by-hop")，哪些字段针对链上的所有接收者("end-to-end")，使消息能够自我描述，并允许未来部署特定于连接的扩展，而不必担心它们会被旧的中介盲目转发。

此外，在应用这些字段的语义之后，中介应该删除或替换转发之前已知需要删除的字段，无论它们是否作为连接选项出现。这包括但不限于:

- Proxy-Connection (Appendix C.2.2 of [HTTP/1.1])
- Keep-Alive (Section 19.7.1 of [RFC2068])
- TE (Section 10.1.4)
- Transfer-Encoding (Section 6.1 of [HTTP/1.1])
- Upgrade (Section 7.8)

发送方不能发送一个与字段对应的连接选项，该字段是为内容的所有接收方准备的。例如，Cache-Control 永远不适合作为连接选项([CACHING] 的 5.2 节)。

连接选项并不总是对应于消息中的字段，因为如果连接选项没有关联参数，则可能不需要特定于连接的字段。相比之下，如果没有相应的连接选项而接收到特定于连接的字段，通常表明该字段被中介体不当转发，应该被接收方忽略。

当定义一个与字段不对应的新连接选项时，规范作者无论如何都应该保留相应的字段名，以避免以后的冲突。这些保留字段名在 "Hypertext Transfer Protocol (HTTP) Field Name Registry" (第 16.3.1 节)中注册。

#### 7.6.2. Max-Forwards

"Max-Forwarded" 头字段提供了一种通过 TRACE (章节 9.3.8) 和 OPTIONS (章节 9.3.7) 请求方法来限制代理转发请求的次数的机制。当客户端试图跟踪一个看起来失败或链中间循环的请求时，这很有用。

```
  Max-Forwards = 1*DIGIT
```

Max-Forwards 值是一个十进制整数，表示该请求消息可以转发的剩余次数。

每个中介体接收到包含 Max-Forwards 首部字段的 TRACE 或 OPTIONS 请求时，必须在转发请求之前检查并更新其值。如果接收到的值为0，则中间节点不能转发请求；相反，中介必须作为最终接收者进行响应。如果接收到的 Max-Forwards 值大于零，中介必须在转发的消息中生成一个更新的 Max-Forwards 字段，该字段的值小于：a) 接收到的值减去 1 或 b) 接收方支持的 Max-Forwards 的最大值。

接收方可以忽略任何其他请求方法接收到的 Max-Forwards 首部字段。

#### 7.6.3. Via

“Via”报头字段表示在用户代理和服务器之间(在请求中)或原始服务器和客户端之间(在响应中)存在中间协议和接收者，类似于电子邮件中的“Received”报头字段(RFC5322节3.6.7)。Via可用于跟踪消息转发，避免请求循环，并确定请求/响应链中发送方的协议能力。

```
  Via = #( received-protocol RWS received-by [ RWS comment ] )

  received-protocol = [ protocol-name "/" ] protocol-version
                    ; see Section 7.8
  received-by       = pseudonym [ ":" port ]
  pseudonym         = token
```

"Via" 字段值的每个成员表示已转发消息的代理或网关。每个中介体附加自己关于如何接收消息的信息，这样最终结果将根据转发接收者的顺序进行排序。

代理必须在转发的每条消息中发送适当的 Via 头字段，如下所述。HTTP-to-HTTP 网关必须在每个入站请求消息中发送适当的 Via 头字段，并可以在转发的响应消息中发送 Via 头字段。

对于每个中介体，received-protocol 表示消息的上游发送方使用的协议和协议版本。因此，Via 字段记录了 请求/响应 链中已发布的协议功能，以便下游接收者仍然可以看到它们;这有助于确定哪些向后不兼容的特性可以安全地在响应中使用，或在以后的请求中使用，如 2.5 节所述。为简洁起见，当接收到的协议为 HTTP 时，不需要指定 protocol-name。

接收部分通常是随后转发消息的接收服务器或客户端的主机和可选端口号。然而，如果真实主机被认为是敏感信息，发送者可能会用假名替换它。如果没有提供端口，接收方可能会认为它是在默认端口上接收的(如果有的话)。

发送方可以生成注释来识别每个接收方的软件，类似于用户代理和服务器头字段。然而，Via 中的注释是可选的，收件人可以在转发消息之前删除它们。

例如，请求消息可以从 HTTP/1.0 用户代理发送到一个代号为 "fred" 的内部代理，该代理使用 HTTP/1.1 将请求转发到 p.example.net 的公共代理，该公共代理通过将请求转发到 www.example.com 的原始服务器来完成请求。www.example.com 收到的请求将具有以下 Via header 字段:

```
Via: 1.0 fred, 1.1 p.example.net
```

通过网络防火墙作为门户的中介不应该转发防火墙区域内主机的名称和端口，除非明确启用了这样做。如果没有启用，这样的中介应该将防火墙后面的任何主机的每个接收主机替换为该主机的适当假名。

如果 Via 头字段列表成员具有相同的接收协议值，中间体可以将其有序子序列合并为单个成员。例如,

```
Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy
```

可以折叠成

```
Via: 1.0 ricky, 1.1 mertz, 1.0 lucy
```

发送者不应合并多个名单成员，除非他们都在同一组织控制下，并且主机已经被假名取代。发送端不能合并具有不同接收协议值的成员。

### 7.7. Message Transformations

有些中介包括转换消息及其内容的功能。例如，代理可以在图像格式之间进行转换，以节省缓存空间或减少慢速链路上的流量。但是，在将这些转换应用于用于医疗成像或科学数据分析等关键应用的内容时，特别是在使用完整性检查或数字签名以确保收到的内容与原始内容相同时，可能会出现操作问题。

如果将 HTTP-to-HTTP 代理设计或配置为以语义上有意义的方式修改消息，则称为 "transforming proxy"(即，在正常 HTTP 处理所需的修改之外，以对原始发送方重要或对下游接收方潜在重要的方式更改消息)。例如，转换代理可能充当共享注释服务器(修改响应以包括对本地注释数据库的引用)、恶意软件过滤器、格式转码器或隐私过滤器。无论哪个客户端(或客户组织)选择代理，都假定需要这种转换。

如果代理接收到主机名不是完全限定域名的目标 URI，它可以在转发请求时将自己的域名添加到主机名中。如果目标 URI 包含完全限定的域名，则代理不能更改主机名。

当转发到下一个入站服务器时，代理不能修改接收到的目标 URI 的 "absolute-path" 和 "query" 部分，除非转发协议有要求。例如，通过 HTTP/1.1 转发请求到源服务器的代理将根据请求方法将空路径替换为 "/" ([HTTP/1.1]第 3.2.1 节) 或 "*" ([HTTP/1.1]第 3.2.4 节)。

代理不能转换包含无转换缓存指令([CACHING]的 5.2.2.6 节)的响应消息的内容(章节 6.4)。请注意，这不适用于不改变内容的消息转换，例如添加或删除传输编码( [HTTP/1.1] 第 7 节)。

代理可以转换不包含无转换缓存指令的消息的内容。转换 200(OK) 响应内容的代理可以通过将响应状态码更改为 203(Non-Authoritative Information) 来通知下游接收方已经应用了转换。

代理不应该修改提供通信链端点、资源状态或所选表示(除内容外)信息的头字段，除非字段的定义明确允许这样的修改，或者认为为了隐私或安全需要进行修改。

### 7.8. Upgrade

"Upgrade" 头字段旨在提供一种简单的机制，用于在同一个连接上从 HTTP/1.1 转换到其他协议。

客户端可以在请求的 Upgrade 首部中发送一个协议名称列表，邀请服务器在发送最终响应之前，按照优先级降序切换到一个或多个已命名的协议。如果服务器希望在该连接上继续使用当前协议，则可以忽略接收到的 Upgrade 首部字段。Upgrade 不能用于坚持协议更改。

```
  Upgrade          = #protocol

  protocol         = protocol-name ["/" protocol-version]
  protocol-name    = token
  protocol-version = token
```

尽管协议名以首选大小写注册，但收件人在将每个协议名与支持的协议进行匹配时，应使用不区分大小写的比较。

发送 101(Switching Protocol) 响应的服务器必须发送一个 Upgrade 首部字段，表示连接切换到哪个新协议；如果要切换多个协议层，发送方必须按层上升顺序列出协议。服务器不能切换到客户端没有在相应请求的Upgrade 首部字段中指明的协议。服务器可以选择忽略客户端指定的优先顺序，并根据其他因素选择新协议，例如请求的性质或服务器当前的负载。

发送 426(Upgrade Required) 响应的服务器必须发送一个 Upgrade 首部字段来表示可接受的协议，按照优先级降序排列。

服务器可以在任何其他响应中发送一个 Upgrade 首部字段，以通知它实现了对升级到所列协议的支持，按照优先级降序排列，如果将来的请求合适的话。

下面是一个假想的客户端发送的例子:

```
GET /hello HTTP/1.1
Host: www.example.com
Connection: upgrade
Upgrade: websocket, IRC/6.9, RTA/x11
```

协议变更后，应用层通信的能力和性质完全取决于选择的新协议。然而，在发送完 101(Switching Protocol) 响应后，服务器需要继续响应原始请求，就像它在新协议中收到了等价的响应一样(即，在协议更改后，服务器仍然有一个未处理的请求需要满足，并且需要这样做，而不需要重复请求)。

例如，如果在 GET 请求中收到了 Upgrade 首部字段，并且服务器决定切换协议，它首先在 HTTP/1.1 中响应 101(Switching Protocol) 消息，然后立即使用与对目标资源的 GET 响应等效的新协议。这样就可以将连接升级到与 HTTP 语义相同的协议，而无需额外的往返延迟。除非接收到的消息语义能被新协议认可，否则服务器不能切换协议；任何协议都可以满足 OPTIONS 请求。

下面是对上述假设请求的响应示例:

```
HTTP/1.1 101 Switching Protocols
Connection: upgrade
Upgrade: websocket

[... data stream switches to websocket with an appropriate response
(as defined by new protocol) to the "GET /hello" request ...]
```

升级发送方还必须在 Connection 报头字段(章节7.6.1)中发送一个 "Upgrade" 连接选项，以通知中间设备不要转发该字段。在 HTTP/1.0 请求中收到 Upgrade 首部字段的服务器必须忽略该字段。

在完全发送完请求消息之前，客户端不能在连接上使用升级后的协议(也就是说，客户端不能更改正在发送的协议)。如果服务器同时收到了 Upgrade 和一个 Expect 报头字段 "100-Continue"(章节10.1.1)，服务器必须在发送 101(Switching Protocol) 响应之前发送 100(Continue) 响应。

Upgrade 头字段只适用于切换现有连接之上的协议；它不能用于切换基础连接(传输)协议，也不能将现有通信切换到不同的连接。为此，更合适的做法是使用 3xx(Redirection) 响应(15.4 节)。

本规范仅定义了用于超文本传输协议族的协议名称 "HTTP"，由 2.5 节和本规范后续更新的 HTTP 版本规则定义。其他协议名称应该使用 16.7 节定义的注册程序进行注册。

## 8. Representation Data and Metadata

### 8.1. Representation Data

与 HTTP 消息相关联的表示数据要么作为消息的内容提供，要么由消息语义和目标 URI 引用。表示数据的格式和编码由表示元数据头字段定义。

表示数据的数据类型通过头字段 Content-Type 和 Content-Encoding 确定。它们定义了一个两层的有序编码模型:

```
  representation-data := Content-Encoding( Content-Type( data ) )
```

### 8.2. Representation Metadata

表示头字段提供有关表示的元数据。当消息包含内容时，表示头字段描述如何解释该数据。在对 HEAD 请求的响应中，表示头字段描述了内容中包含的表示数据，如果相同的请求是 GET 请求的话。

### 8.3. Content-Type

"Content-Type" 头字段表示相关表示的媒体类型:是包含在消息内容中的表示，也是由消息语义确定的选定表示。所指示的媒体类型定义了数据格式，以及在接收到的消息语义范围内，在解码由 "Content-Encoding" 指示的任何内容编码之后，该数据将如何被接收方处理。

```
  Content-Type = media-type
```

媒体类型定义在 8.3.1 节。这个字段的一个例子是:

```
Content-Type: text/html; charset=ISO-8859-4
```

生成包含内容的消息的发送方应在该消息中生成 Content-Type 头字段，除非发送方不知道所附表示的预期媒体类型。如果 Content-Type 头字段不存在，接收方可以假定媒体类型为 "application/octet-stream" ([RFC2046]，章节4.5.1)，或者检查数据以确定其类型。

在实践中，资源所有者并不总是正确地配置其源服务器，以为给定的表示提供正确的内容类型。有些用户代理检查内容，并在某些情况下覆盖接收到的类型(例如，参见[Sniffing])。这种 "MIME sniffing" 有对数据得出错误结论的风险，这可能会使用户面临额外的安全风险(例如，“权限提升”)。此外，不同的媒体类型通常共享一种共同的数据格式，只是在处理数据的方式上有所不同，这是无法通过单独检查数据来区分的。在实现嗅探时，鼓励实现者为用户提供一种禁用嗅探的方法。

虽然 Content-Type 被定义为一个单例字段，但它有时会被错误地多次生成，导致合并后的字段值看起来像一个列表。接收方通常试图通过使用列表中最后一个语法上有效的成员来处理此错误，如果不同的实现具有不同的错误处理行为，则会导致潜在的互操作性和安全性问题。

#### 8.3.1. Media Type

HTTP 在 Content-Type (8.3 节) 和 Accept (12.5.1 节)头字段中使用媒体类型[RFC2046]，以便提供开放和可扩展的数据类型和类型协商。媒体类型定义了数据格式和各种处理模型:如何根据消息上下文处理数据。

```
  media-type = type "/" subtype parameters
  type       = token
  subtype    = token
```

类型和子类型标记不区分大小写。

类型/子类型后面可以是以名称/值对形式以分号分隔的参数(第5.6.6节)。参数的存在或不存在可能对媒体类型的处理很重要，这取决于它在媒体类型注册表中的定义。参数值可能区分大小写，也可能不区分大小写，这取决于参数名的语义。

例如，在描述 UTF-8 字符编码方案中编码的 HTML 文本数据时，下列媒体类型是等价的，但为了一致性，第一种媒体类型是首选的(在[RFC2046]，第4.1.2 节中，"harset" 参数值定义为大小写不敏感的):

```
  text/html;charset=utf-8
  Text/HTML;Charset="utf-8"
  text/html; charset="utf-8"
  text/html;charset=UTF-8
```

媒体类型应按照 [BCP13] 中定义的程序在 IANA 注册。

#### 8.3.2. Charset

HTTP使用 "charset" 名称来表示或协商文本表示的字符编码方案([RFC6365]，第 2 节)。在这个文档定义的字段中，字符集名称要么出现在参数中 (Content-Type)，要么出现在 Accept-Encoding 中，以普通标记的形式出现。在这两种情况下，字符集名称的匹配是不区分大小写的。

字符集名称应该按照 [RFC2978] 第 2 节中定义的程序在 IANA "Character Sets" 注册中心(<https://www.iana.org/assignments/character-sets>) 注册。

> 注意:理论上，字符集名称由 [RFC2978] 的 2.3 节中定义的 "mime-charset" ABNF 规则定义(在 [Err1912] 中更正)。该规则允许两个字符不包含在 "token" 中 ("{"和"}")，但在编写本文时，注册的字符集名称都不包含大括号(参见 [Err5433])。

#### 8.3.3. Multipart Types

MIME 提供了许多 "multipart" 类型——将一个或多个表示封装在单个消息体中。正如 [RFC2046] 的 5.1.1 节所定义的，所有的 multipart 类型都有一个共同的语法，并且包括一个边界参数作为媒体类型值的一部分。消息体本身是一个协议元素;发送者必须只生成 CRLF 来表示身体部位之间的换行。

HTTP 消息分帧不使用 multipart 边界作为消息体长度的指示器，尽管生成或处理内容的实现可能会使用它。例如，"multipart/form-data" 类型通常用于在请求中携带表单数据，如 [RFC7578] 所述，而 "multipart/byteranges" 类型由本规范定义，用于 206(Partial Content) 响应(参见15.3.7节)。

### 8.4. Content-Encoding

"Content-Encoding" 头字段表示除了媒体类型固有的编码外，还应用了什么内容编码，因此，为了获得 Content-Type 头字段引用的媒体类型中的数据，必须应用什么解码机制。内容编码主要用于压缩表示形式的数据，而不会丢失其底层媒体类型的标识。

```
  Content-Encoding = #content-coding
```

一个使用示例：

```
Content-Encoding: gzip
```

如果一个或多个编码被应用于一个表示，应用编码的发送方必须生成一个 Content-Encoding 头字段，该字段按应用的顺序列出内容编码。请注意，命名为 "identity" 的编码是为其在 Accept-Encoding 中的特殊作用而保留的，因此不应该包括在内。

关于编码参数的附加信息可以由本规范未定义的其他头字段提供。

与 Transfer-Encoding  ([HTTP/1.1] 第 6.1 节)不同，内容编码中列出的编码是表示的一个特征;表示形式按照编码形式定义，除非在元数据定义中另有说明，否则有关表示形式的所有其他元数据都与编码形式有关。通常，仅在呈现或类似使用之前对表示进行解码。

如果媒体类型包含一种固有的编码，比如总是被压缩的数据格式，那么这种编码就不会在 Content-Encoding 中重述，即使它恰好与内容编码中的一种算法相同。只有在出于某种奇怪的原因，第二次应用这种内容编码以形成表示时，才会列出这种内容编码。同样地，一个源服务器可能会选择将相同的数据发布为多个表示，只是不同的表示是定义为内容类型的一部分还是 Content-Encoding 的一部分，因为一些用户代理在处理每个响应时会有不同的行为(例如，打开一个“另存为…”对话框，而不是自动解压和呈现内容)。

如果请求消息中的表示具有不可接受的内容编码，则源服务器可以使用状态码 415(Unsupported Media Type) 进行响应。

#### 8.4.1. Content Codings

内容编码值表示已经或可以应用于表示的编码转换。内容编码主要用于压缩表示或以其他方式进行有用的转换，而不会丢失其底层媒体类型的标识，也不会丢失信息。通常情况下，这种表示以编码形式存储，直接传输，只由最终的接收方解码。

```
content-coding   = token
```

所有内容编码都不区分大小写，应该在 "HTTP Content Coding Registry" 中注册，如 16.6 节所述。

内容编码值用于 Accept-Encoding (第 12.5.3 节)和 Content-Encoding (第 8.4 节)头字段。

##### 8.4.1.1. Compress Coding

"compress" 编码是一种自适应的 Lempel-Ziv-Welch (LZW) 编码，通常由 UNIX 文件压缩程序 "compress" 产生。收件人应该将 "x-compress" 等同于 "compress"。

##### 8.4.1.2. Deflate Coding

"deflate" 编码是一种 "zlib" 数据格式 [RFC1950]，包含使用 Lempel-Ziv (LZ77) 压缩算法和 Huffman 编码的 "deflate" 压缩数据流 [RFC1951]。

> 注意:一些不符合规范的实现发送 "deflate" 压缩数据时没有使用 zlib 包装器。

##### 8.4.1.3. Gzip Coding

"gzip" 编码是一个具有 32 位循环冗余校验(CRC)的 LZ77 编码，通常由 gzip 文件压缩程序 [RFC1952] 产生。收件人应该认为 "x-gzip" 等同于 "gzip"。

### 8.5. Content-Language

"Content-Language" 头字段描述了表示的预期受众的自然语言。注意，这可能并不等同于表示中使用的所有语言。

```
  Content-Language = #language-tag
```

语言标记定义在 8.5.1 节。内容语言的主要目的是允许用户根据自己的首选语言识别和区分表示。因此，如果内容只针对懂丹麦语的观众，那么合适的领域是

```
Content-Language: da
```

如果没有指定 Content-Language，默认情况下该内容适用于所有语言的受众。这可能意味着发送者不认为它是特定于任何自然语言的，或者发送者不知道它的目的是哪种语言。

对于面向多个受众的内容，可能会列出多种语言。例如，将要求同时以毛利原文和英文本提出《怀唐伊条约》的译本

```
Content-Language: mi, en
```

然而，仅仅因为在一个表示中存在多种语言，并不意味着它针对多种语言的受众。一个例子是初学者的语言入门，例如“第一课拉丁语”，它显然是为有英语文化的观众使用的。在这种情况下，Content-Language 应该只包含"en"。

Content-Language 可以应用于任何媒体类型 —— 不仅限于文本文档。

#### 8.5.1. Language Tags

语言标签(language tag)，如 [RFC5646] 所定义，用于标识人类所说的、书写的或以其他方式传达的用于与其他人进行信息交流的自然语言。计算机语言被明确排除在外。

HTTP 在 Accept-Language 和 Content-Language 头字段中使用 language 标签。Accept-Language 使用 12.5.4 节中定义的更广泛的语言范围产品，而 Content-Language 使用下面定义的语言标签产品。

```
  language-tag = <Language-Tag, see [RFC5646], Section 2.1>
```

语言标记是一个或多个不区分大小写的子标记序列，每个子标记之间用连字符 ("-"，%x2D) 分隔。在大多数情况下，一个语言标签由一个主要语言子标签组成，该子标签标识了一个广泛的相关语言族(例如，"en" = English)，可以选择后面跟随一系列子标签，以细化或缩小该语言的范围(例如，"en-ca" = 在加拿大交流的英语的种类)。语言标记中不允许有空格。示例标签包括:

```
  fr, en-US, es-419, az-Arab, x-pig-latin, man-Nkoo-GN
```

更多信息参见 [RFC5646]。

### 8.6. Content-Length

"Content-Length" 头字段表示相关表示的数据长度为十进制非负整数字节数。当以内容的形式传输表示时， Content-Length 特指包含的数据量，以便用于确定帧范围(例如，[HTTP/1.1] 的第 6.2 节)。在其他情况下，Content-Length 表示所选表示形式的当前长度，接收者可以使用它来估计传输时间或与之前存储的表示形式进行比较。

```
  Content-Length = 1*DIGIT
```

一个例子是

```
Content-Length: 3495
```

当该方法定义了所包含内容的含义且不发送 Transfer-Encoding 时，用户代理应该在请求中发送  Content-Length。例如，即使 Content-Length 值为 0(表示内容为空)，用户代理也会在 POST 请求中发送 Content-Length。当请求消息不包含内容且方法语义不期望此类数据时，用户代理不应该发送 Content-Length 头字段。

服务器可以在对 HEAD 请求的响应中发送一个 Content-Length 头字段(章节9.3.2)；服务器不能在这样的响应中发送 Content-Length，除非它的字段值等于使用 GET 方法时在响应内容中发送的字节数的十进制数。

服务器可以在 304 (Not Modified) 响应中发送内容长度的首部字段来响应有条件的 GET 请求(章节15.4.5)；服务器不能在这样的响应中发送 Content-Length，除非它的字段值等于相同请求的 200(OK) 响应中发送的内容的十进制数字节。

服务器不能在任何响应中发送状态码为 1xx(Informational) 或 204(No Content) 的 Content-Length 首部字段。 对于 CONNECT 请求，服务器不能在任何 2xx(Successful) 响应中发送 Content-Length 头字段(章节 9.3.6)。

除了上述定义的情况外，在没有传输编码的情况下，当内容大小在发送完整的首部部分之前已知时，源服务器应该发送 Content-Length 首部字段。这将允许下游接收者测量传输进度，知道接收到的消息何时完成，并可能为其他请求重用连接。

任何 Content-Length 字段的值大于或等于零都是有效的。由于对内容的长度没有预定义的限制，接收方必须预测潜在的大的十进制数字，并防止由于整数转换溢出造成的解析错误或由于整数转换造成的精度损失(第 17.5 节)。

因为 Content-Length 在 HTTP/1.1 中用于消息定界，它的字段值可以影响下游接收者解析消息的方式，即使即时连接没有使用 HTTP/1.1。如果消息由下游中介体转发，与接收到的消息分帧不一致的 Content-Length字段值可能会由于内部请求或响应分割而导致安全问题。

因此，发送方不能转发已知内容长度报头字段值不正确的消息。

同样，发送端不能转发与上述 ABNF 不匹配的内容长度报头字段值，但有一个例外:接收端内容长度报头字段值由相同的十进制值组成，以逗号分隔的列表重复 (例如，"Content-Length:42, 42") 可以拒绝无效的消息，或者将无效的字段值替换为十进制值的单个实例，因为这可能表明上游消息处理器生成或组合了重复的消息。

### 8.7. Content-Location

"Content-Location" 头字段引用一个 URI，该 URI 可以用作与此消息内容中的表示相对应的特定资源的标识符。换句话说，如果在生成此消息时对此 URI 执行 GET 请求，则200(OK) 响应将包含与此消息中包含的内容相同的表示。

```
  Content-Location = absolute-URI / partial-URI
```

字段值要么是  absolute-URI，要么是 partial-URI。在后一种情况下(第4节)，引用的 URI 是相对于目标 URI 的([URI]，第5节)。

Content-Location 值不能替代目标 URI(章节7.1)。它是表示元数据。它与 [RFC2557] 第 4 节中为 MIME 主体部分定义的同名头字段具有相同的语法和语义。然而，它在 HTTP 消息中的出现对 HTTP 接收者有一些特殊的含义。

如果  Content-Location 包含在 2xx(Successful) 响应消息中，并且它的值(在转换为绝对形式后)指向与目标 URI 相同的 URI，那么接收者可以将内容视为该资源在消息发起日期所指示的时间的当前表示。对于 GET (章节 9.3.1) 或 HEAD (章节 9.3.2) 请求，这与服务器不提供内容定位时的默认语义相同。对于状态变化的请求，如 PUT (9.3.4 节)或 POST (9.3.3 节)，它意味着服务器的响应包含了该资源的新表示，从而与只报告操作的表示(例如“它工作了!”)区分开来。这允许编写应用程序更新其本地副本，而不需要后续的 GET 请求。

如果 Content-Location 包含在 2xx(Successful) 响应消息中，并且其字段值引用与目标 URI 不同的 URI，则源服务器声称该 URI 是与所包含的表示相对应的不同资源的标识符。只有当两个标识符共享相同的资源所有者时，这种声明才可信，而这是无法通过 HTTP 以编程方式确定的。

- 对于 GET 或 HEAD 请求的响应，这表明目标 URI 引用的资源需要经过内容协商，而 Content-Location 字段值是所选表示的更具体的标识符。
- 对于状态改变方法的 201(Created) 响应，与 Location 字段值相同的 Content-Location 字段值表明此内容是新创建资源的当前表示。
- 否则，这样的内容位置表明此内容是报告请求操作状态的表示形式，并且相同的报告(供将来使用 GET 访问)在给定的 URI 上可用。例如，通过 POST 请求进行的购买交易可能包括一个收据文档作为 200(OK) 响应的内容; Content-Location 字段值提供了一个标识符，用于将来检索相同收据的副本。

在请求消息中发送 Content-Location 的用户代理声明其值指向用户代理最初获得所附表示的内容的位置(在用户代理进行任何修改之前)。换句话说，用户代理提供了一个到原始表示来源的反向链接。

在请求消息中接收 Content-Location 字段的源服务器必须将该信息视为临时请求上下文，而不是作为表示的一部分逐字保存的元数据。源服务器可以使用该上下文来指导处理请求，或将其保存以供其他用途，例如在源链接中或版本化元数据中。但是，源服务器不能使用这样的上下文信息来改变请求语义。

例如，如果客户端对协商好的资源发出一个 PUT 请求，而源服务器接受了这个 PUT 请求(没有重定向)，那么资源的新状态应该与 PUT 中提供的状态保持一致;内容位置不能作为反向内容选择标识符的一种形式，只更新协商后的表示形式之一。如果用户代理需要后一种语义，它将直接将 PUT 应用于内容位置 URI。

### 8.8. Validator Fields

资源元数据被称为 "验证器"(validator)，如果它可以在一个前提条件(13.1节)内使用，以发出一个条件请求(第13节)。"Validator" 字段表示所选表示的当前验证器(第3.2节)。

在安全请求的响应中，validator 字段描述了源服务器在处理响应时选择的表示形式。请注意，根据方法和状态码语义，为给定响应选择的表示不一定与作为响应内容包含的表示相同。

在对状态改变请求的成功响应中，validator 字段描述了在处理请求时替换了先前选择的表示形式的新表示形式。

例如，201(Created) 响应中的 ETag 字段与新创建资源表示的实体标签进行通信，这样实体标签就可以在以后的条件请求中用作验证器，以防止 "丢失更新" 的问题。

本规范定义了两种形式的元数据，通常用于观察资源状态和测试前提条件: 修改日期(8.8.2 节)和不透明实体标签(8.8.3 节)。反映资源状态的其他元数据已经由 HTTP 的各种扩展定义，例如 Web Distributed Authoring and Versioning [WEBDAV]，这些超出了本规范的范围。

#### 8.8.1. Weak versus Strong

验证器有两种类型:强验证器和弱验证器。弱验证器很容易生成，但用于比较时就没那么有用了。强大的验证器是比较的理想选择，但高效地生成非常困难(有时不可能)。HTTP 公开了正在使用的验证器类型，并限制了何时可以将弱验证器用作先决条件，而不是强制所有形式的资源都遵循相同的验证器强度。

“强验证器”是表示元数据，每当表示数据发生变化时，它的值就会改变，而这些数据在 200(OK) 响应的内容中是可观察到的。

除了表示数据的更改之外，强验证器可能还会因为其他原因而更改，例如表示元数据的重要语义部分发生更改时(例如 Content-Type)，但是源服务器最好只在需要使远程缓存和创作工具保存的响应失效时更改值。

缓存项可能会持续任意长的时间，而不考虑过期时间。因此，缓存可能会尝试使用很久以前获得的验证器来验证条目。随着时间的推移，在与特定资源相关联的所有表示形式的所有版本中，强验证器是唯一的。然而，在不同资源的表示之间并不意味着唯一性(即，同一个强验证器可能同时用于多个资源的表示，这并不意味着这些表示是相等的)。

实践中有各种各样的强验证器。最好的方法是基于严格的版本控制，其中对表示的每次更改总是导致在可以访问表示之前分配唯一的节点名称和版本标识符。如果数据在发送响应头字段之前可用，并且不需要在每次接收验证请求时重新计算摘要，那么应用于表示数据的抗碰撞散列函数就足够了。但是，如果资源只有元数据上的不同表示，比如碰巧共享相同数据格式的媒体类型之间的内容协商，那么源服务器需要在验证器中合并额外的信息，以区分这些表示。

相比之下，“弱验证器”是表示元数据，可能不会随着表示数据的每次更改而更改。这个弱点可能是由于值的计算方式有限制(例如时钟分辨率)，无法确保资源所有可能表示的唯一性，或者资源所有者希望通过某种自我确定的等价集合而不是唯一的数据序列对表示进行分组。

当源服务器认为之前的表示形式代替当前表示形式不可接受时，就应该更改弱实体标记。换句话说，当源服务器希望缓存使旧响应失效时，弱实体标签应该更改。

例如，基于动态测量的每秒变化内容的天气报告的表示形式，可以使用相同的弱验证器(从源服务器的角度来看)分组成等价的表示形式的集合，以便允许缓存表示形式在合理的一段时间内有效(可能根据服务器负载或天气质量进行动态调整)。同样，如果只定义了一秒的分辨率，表示的修改时间可能是一个弱验证器，如果可能在一秒内修改两次表示，并在这些修改之间检索。

类似地，如果一个验证器被给定资源的两个或多个表示共享，那么它就是弱验证器，除非这些表示有相同的表示数据。例如，如果源服务器对应用了 gzip 内容编码的表示形式发送的验证器与对没有内容编码的表示形式发送的验证器相同，那么验证器就是弱的。但是，如果两个同时进行的表示只在表示元数据上不同，比如同一个表示数据有两种不同的媒体类型，那么它们可能共享相同的强验证器。

强验证器可用于所有条件请求，包括缓存验证、部分内容范围和避免“丢失更新”。弱验证器仅在客户端不需要与先前获得的数据完全相等时才可用，例如在验证缓存条目或将web遍历限制为最近更改时。

#### 8.8.2. Last-Modified

响应头中的 "Last-Modified" 字段提供了一个时间戳，表示源服务器认为所选内容最后一次被修改的日期和时间，这是在处理完请求后确定的。

```
  Last-Modified = HTTP-date
```

一个使用示例：

```
Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT
```

##### 8.8.2.1. Generation

对于可以合理且一致地确定最后修改日期的任何选择的表示形式，源服务器都应该发送last - modified，因为它用于条件请求和评估缓存新鲜度([CACHING])可以大大减少不必要的传输，并显著提高服务的可用性和可扩展性。

表示通常是资源接口背后许多部分的总和。最后修改时间通常是这些部分最近被修改的时间。如何为任何给定资源确定该值是超出本规范范围的实现细节。

源服务器应该获取表示形式的Last-Modified值，尽可能接近它为响应生成日期字段值的时间。这允许接收者对表示的修改时间做出准确的评估，特别是当表示在响应生成时附近发生更改时。

具有时钟(如5.6.7节所定义)的原始服务器不能生成一个晚于服务器发出消息时间(日期，6.6.1节)的最后修改日期。如果上一次修改时间是从特定于实现的元数据中得出的，该元数据根据源服务器的时钟计算为未来的某个时间，那么源服务器必须用消息发送日期替换该值。这防止了未来的修改日期对缓存验证产生不利影响。

没有时钟的源服务器不能为响应生成最后修改日期，除非该日期值是由其他系统(可能有时钟的系统)分配给资源的。

##### 8.8.2.2. Comparison

Last-Modified 时间在请求中用作验证时，隐式地是弱的，除非可以使用以下规则推断出它是强的。

- 验证器由原始服务器与实际的当前验证器进行比较;
- 该源服务器可靠地知道，在所提供的验证器覆盖的第二次期间，关联的表示没有更改两次;

或

- 客户端将在 If-Modified-Since、If-Unmodified-Since 或 If-Range 头字段中使用验证器，因为客户端有关联表示的缓存条目和
- 该缓存项包括一个日期值，该日期值在最后修改值之后至少一秒，并且客户端有理由相信它们是由相同的时钟生成的，或者最后修改和日期值之间有足够的差异，使时钟同步问题不太可能发生;

或

- 验证器由中间缓存与存储在其表示的缓存条目中的验证器进行比较，并且
- 该缓存项包括一个日期值，该日期值至少比最后修改的值晚一秒，缓存有理由相信它们是由同一个时钟生成的，或者最后修改的值和日期值之间有足够的差异，使时钟同步问题不太可能发生。

这个方法依赖于这样一个事实:如果源服务器在同一秒内发送了两个不同的响应，但它们的最后修改时间相同，那么这些响应中至少有一个的日期值与最后修改时间相等。

#### 8.8.3. ETag

响应中的 "ETag" 字段提供了所选表示的当前实体标签，这是在处理请求结束时确定的。实体标签是一个不透明的验证器，用于区分同一资源的多种表示形式，无论这些表示形式是由于资源状态随时间的变化造成的，还是由于内容协商导致的多种表示形式同时有效，或者两者都有效。实体标记由不透明的引号字符串组成，可能以弱验证指示符作为前缀。

```
  ETag       = entity-tag

  entity-tag = [ weak ] opaque-tag
  weak       = %s"W/"
  opaque-tag = DQUOTE *etagc DQUOTE
  etagc      = %x21 / %x23-7E / obs-text
             ; VCHAR except double quotes, plus obs-text
```

> 注意:以前，opaque-tag 被定义为一个引号字符串([RFC2616]，章节3.11);因此，一些接收者可能会执行反斜杠反转义。因此，服务器应该避免在实体标记中使用反斜杠字符。

在不方便存储修改日期的情况下，在 HTTP-date 值的一秒分辨率不够的情况下，或者在修改日期没有得到一致维护的情况下，实体标签比修改日期更可靠。

例如:

```
ETag: "xyzzy"
ETag: W/"xyzzy"
ETag: ""
```

实体标签可以是弱验证器，也可以是强验证器，强验证器是默认值。如果源服务器为表示提供了实体标记，并且该实体标记的生成不满足强验证器的所有特征(第8.8.1节)，则源服务器必须通过在不透明值前加上 "W/" (区分大小写)将该实体标记标记为弱。

发送者可以在 trailer 章节中发送 ETag 字段(参见章节6.5)。然而，由于 trailer 经常被忽略，除非在发送内容时生成实体标签，否则最好将 ETag 作为头字段发送。

##### 8.8.3.1. Generation

实体标记背后的原则是，只有服务作者足够了解资源的实现，以便为该资源选择最准确和最有效的验证机制，并且任何这样的机制都可以映射到一个简单的字节序列，以便进行比较。由于该值是不透明的，因此客户端无需知道每个实体标签是如何构建的。

例如，将特定于实现的版本应用于所有更改的资源可能使用一个内部修订号，可能还结合了用于内容协商的方差标识符，以准确区分表示形式。其他实现可能使用表示内容的抗碰撞哈希、各种文件属性的组合或具有亚秒分辨率的修改时间戳。

源服务器应该为任何选择的表示发送 ETag，对其变化的检测可以合理且一致地确定，因为在条件请求中使用实体标签和评估缓存新鲜度([CACHING])可以大大减少不必要的传输，并显著提高服务可用性、可扩展性和可靠性。

##### 8.8.3.2. Comparison

根据比较上下文是否允许使用弱验证器，有两个实体标签比较函数:

"Strong comparison": 如果两个实体标签都不是弱标签，且它们的不透明标签逐字匹配，则它们是等价的。

"Weak comparison": 如果两个实体标签的不透明标签逐字匹配，则它们是等价的，无论其中一个或两个都标记为“弱”。

下面的例子展示了一组实体标签对的结果，以及弱比较函数和强比较函数的结果:

ETag 1 | ETag 2 | Strong Comparison | Weak Comparison
--|--|--|--
W/"1" | W/"1" | no match | match
W/"1" | W/"2" | no match | no match
W/"1" | "1" | no match | match
"1" | "1" | match | match

##### 8.8.3.3. Example: Entity Tags Varying on Content-Negotiated Resources

如果一个需要协商内容的资源(第12节)，在响应 GET 请求时发送的表示根据 Accept-Encoding 的请求头字段不同(第12.5.3节):

\>\> Request:

```
GET /index HTTP/1.1
Host: www.example.com
Accept-Encoding: gzip
```

在这种情况下，响应可能使用 gzip 内容编码，也可能不使用。如果没有，响应可能如下所示:

\>\> Response:

```
HTTP/1.1 200 OK
Date: Fri, 26 Mar 2010 00:05:00 GMT
ETag: "123-a"
Content-Length: 70
Vary: Accept-Encoding
Content-Type: text/plain

Hello World!
Hello World!
Hello World!
Hello World!
Hello World!
```

另一种使用 gzip 内容编码的方式是:

\>\> Response:

```
HTTP/1.1 200 OK
Date: Fri, 26 Mar 2010 00:05:00 GMT
ETag: "123-b"
Content-Length: 43
Vary: Accept-Encoding
Content-Type: text/plain
Content-Encoding: gzip

...binary data...
```

> 注意:内容编码是表示数据的属性，因此内容编码表示的强实体标记必须与未编码表示的实体标记不同，以防止缓存更新和范围请求期间的潜在冲突。相比之下，传输编码([HTTP/1.1] 第 7 节)仅在消息传输期间适用，不会产生不同的实体标签。

## 9. Methods

### 9.1. Overview

请求方法令牌是请求语义的主要来源;它指明了客户端提出此请求的目的，以及客户端期望成功的结果是什么。

请求方法的语义可以通过请求中出现的一些报头字段的语义进一步特殊化，如果这些额外的语义与方法不冲突的话。例如，客户端可以发送有条件的请求报头字段(章节13.1)，使所请求的操作以目标资源的当前状态为条件。

HTTP 被设计成可用作分布式对象系统的接口。请求方法调用要应用于目标资源的操作，其方式与将远程方法调用发送到已识别对象的方式大致相同。

```
  method = token
```

方法令牌是区分大小写的，因为它可能被用作基于对象的系统的网关，这些系统具有区分大小写的方法名称。按照约定，标准化方法是用全大写 US-ASCII 字母定义的。

与分布式对象不同，HTTP 中的标准化请求方法不是特定于资源的，因为统一接口在基于网络的系统 [REST] 中提供了更好的可见性和重用性。标准化方法一经定义，在应用于任何资源时应该具有相同的语义，尽管每个资源自己确定这些语义是否被实现或允许。

本规范定义了HTTP中常用的一些标准化方法，如下表所示。

Method Name | Description | Section
--|--|--
GET | Transfer a current representation of the target resource. | 9.3.1
HEAD | Same as GET, but do not transfer the response content. | 9.3.2
POST | Perform resource-specific processing on the request content. | 9.3.3
PUT | Replace all current representations of the target resource with the request content. | 9.3.4
DELETE | Remove all current representations of the target resource. | 9.3.5
CONNECT | Establish a tunnel to the server identified by the target resource. | 9.3.6
OPTIONS | Describe the communication options for the target resource. | 9.3.7
TRACE | Perform a message loop-back test along the path to the target resource. | 9.3.8

所有通用服务器都必须支持 GET 和 HEAD 方法。其他方法都是可选的。

目标资源允许的一组方法可以在 Allow 头字段中列出(10.2.1节)。然而，允许的方法集可以动态改变。接收到未识别或未实现的请求方法的源服务器应该使用 501(Not Implemented) 状态码进行响应。如果源服务器接收到被识别并实现的请求方法，但目标资源不允许使用该方法，则响应状态码为 405(Method Not Allowed)。

其他方法已经被指定用于 HTTP，超出了本规范的范围。所有这些方法都应该在 "Hypertext Transfer Protocol (HTTP) Method Registry" 中注册，如 16.1 节所述。

### 9.2. Common Method Properties

#### 9.2.1. Safe Methods

如果定义的语义本质上是只读的，则请求方法被认为是“安全的”;也就是说，客户端不请求，也不期望源服务器上的任何状态改变，因为对目标资源应用了安全的方法。同样，合理使用安全的方法不会对原始服务器造成任何伤害、财产损失或异常负担。

安全方法的这种定义并不能阻止实现中包含一些行为，这些行为可能有害，不是完全只读的，或者在调用安全方法时产生副作用。然而，重要的是，客户没有要求这种额外的行为，因此不能对其负责。例如，大多数服务器在每次响应完成后都会附加访问日志文件的请求信息，无论使用什么方法，即使日志存储空间已满并导致服务器失败，这种做法也是安全的。同样，通过在 Web 上选择广告发起的安全请求通常会产生收费广告账户的副作用。

在这个规范定义的请求方法中，GET、HEAD、OPTIONS 和 TRACE 方法被定义为安全的。

区分安全方法和不安全方法的目的是让自动检索过程 (spider) 和缓存性能优化 (pre-fetching) 能够工作，而不必担心造成危害。此外，它允许用户代理在处理潜在的不可信内容时，对不安全的方法自动使用施加适当的约束。

当向用户展示潜在的操作时，用户代理应该区分安全的和不安全的方法，以便在请求之前让用户知道不安全的操作。

当资源被构造成目标 URI 中的参数具有选择操作的效果时，确保操作与请求方法语义一致是资源所有者的责任。例如，基于 web 的内容编辑软件通常在查询参数中使用操作，例如 "page?do=delete"。如果此类资源的目的是执行不安全的操作，那么资源所有者必须在使用安全请求方法访问该资源时禁用或禁止该操作。如果不这样做，当自动化进程为了维护链接、预获取、构建搜索索引等目的对每个 URI 引用执行 GET 时，将导致不幸的副作用。

#### 9.2.2. Idempotent Methods

如果使用该方法的多个相同请求对服务器的预期效果与单个请求的效果相同，则该请求方法被认为是“幂等的”。在本规范定义的请求方法中，PUT、DELETE 和其他安全请求方法是幂等的 (也就是说 POST、CONNECT 方法是非幂等的)。

与安全的定义一样，幂等性只适用于用户请求的内容;服务器可以自由地分别记录每个请求，保留修订控制历史记录，或者为每个幂等请求实现其他非幂等副作用。

幂等方法之所以被区分出来，是因为如果在客户端读取服务器响应之前发生通信失败，请求可以自动重复。例如，如果客户端发送了一个 PUT 请求，而底层连接在接收到响应之前就关闭了，那么客户端可以建立一个新的连接并重试幂等请求。它知道重复请求将具有相同的预期效果，即使原始请求成功，尽管响应可能不同。

客户端不应该使用非幂等方法自动重试请求，除非它有某种方法知道请求语义实际上是幂等的，而不管使用哪种方法，或者有某种方法可以检测到原始请求从未被应用过。

例如，如果用户代理(通过设计或配置)知道该请求对该资源是安全的，那么它可以自动重复 POST 请求。同样，专为在版本控制存储库上操作而设计的用户代理可以在连接失败后检查目标资源修订，恢复或修复部分应用的任何更改，然后自动重试失败的请求，从而从部分失败条件中恢复。

有些客户端采取了更冒险的方法，尝试猜测何时可以自动重试。例如，如果底层传输连接在接收到响应的任何部分之前就关闭了，客户端可能会自动重试 POST 请求，特别是使用了空闲的持久连接时。

代理不能自动重试非幂等请求。客户端不应该自动重试失败的自动重试。

#### 9.2.3. Methods and Caching

为了让缓存存储和使用响应，相关的方法需要显式允许缓存，并详细说明在什么条件下可以使用响应来满足后续请求;不这样做的方法定义不能缓存。有关其他要求，请参阅 [CACHING]。

本规范定义了 GET、HEAD 和 POST 的缓存语义，尽管绝大多数缓存实现只支持 GET 和 HEAD。

### 9.3. Method Definitions

#### 9.3.1. GET

GET 方法请求传输目标资源的当前选定表示。一个成功的响应反映了目标 URI ([URI]章节1.2.2)所确定的“一致性”的质量。因此，通过 HTTP 检索可识别信息通常是通过对标识符发起 GET 请求来执行的，该标识符与在200(OK) 响应中提供该信息的可能性相关联。

GET 是信息检索的主要机制，也是几乎所有性能优化的重点。为每个重要资源生成 URI 的应用程序可以从这些优化中受益，同时允许它们被其他应用程序重用，从而创建促进 Web 进一步扩展的网络效应。

很容易将资源标识符想象成远程文件系统路径名，并将其表示为此类文件内容的副本。实际上，这就是实现的资源数量(有关安全考虑，请参见17.3节)。然而，在实践中没有这样的限制。

资源的 HTTP 接口很可能被实现为内容对象树、各种数据库记录的程序化视图或其他信息系统的网关。即使 URI 映射机制绑定到文件系统，也可以配置一个源服务器，以请求作为输入执行文件，并将输出作为表示发送，而不是直接传输文件。无论如何，只有源服务器需要知道每个资源标识符如何与实现相对应，以及该实现如何管理选择和发送目标资源的当前表示。

客户端可以将 GET 的语义改为“范围请求”，通过在请求中发送一个范围头字段，仅请求传输所选表示的某些部分(章节 14.2)。

尽管请求消息分帧与所使用的方法无关，但 GET 请求中接收到的内容没有一般定义的语义，不能改变请求的含义或目标，并且可能导致某些实现拒绝该请求并关闭连接，因为其存在的请求夹带攻击( [HTTP/1.1] 节 11.2)风险。客户端不应该在 GET 请求中生成内容，除非它是直接发送到源服务器的，并且源服务器已经在带内或带外表明了这样的请求是有目的的，并且将得到充分的支持。原始服务器不应该依赖私有协议来接收内容，因为HTTP通信的参与者通常不知道请求链上的中介。

GET 请求的响应是可缓存的;缓存可以使用它来满足后续的 GET 和 HEAD 请求，除非 Cache-Control 头字段另有指示( [CACHING] 节 5.2)。

当使用一种机制从用户提供的信息(例如使用 GET 的表单查询字段)构建目标 URI 来执行信息检索时，可能会提供不适合在 URI 中公开的潜在敏感数据(参见17.9节)。在某些情况下，可以对数据进行过滤或转换，使其不会显示这些信息。在其他情况下，特别是在缓存响应没有好处的情况下，使用 POST 方法(章节9.3.3)而不是 GET 方法可以在请求内容中而不是在目标 URI 中传输这些信息。

#### 9.3.2. HEAD

HEAD 方法与 GET 方法相同，只是服务器不能在响应中发送内容。HEAD 用于在不传输表示数据的情况下获取所选表示的元数据，通常用于测试超文本链接或查找最近的修改。

在响应 HEAD 请求时，服务器应该发送与请求方法为 GET 时相同的 header 字段。然而，服务器可能会忽略那些仅在生成内容时才确定值的头字段。例如，有些服务器会缓存动态响应，直到生成最小数据量为止，这样它们就可以更有效地划分较小的响应，或者对内容选择做出较晚的决定。例如，可以 GET 的响应可能包含 Content-Length 和其他不同的字段，这些字段不是在 HEAD 响应中生成的。与为 HEAD 请求生成和丢弃内容相比，这些微小的不一致性被认为是可取的，因为请求 HEAD 通常是为了效率。

尽管请求消息分帧与所使用的方法无关，但 HEAD 请求中接收到的内容没有一般定义的语义，不能改变请求的含义或目标，并且可能导致某些实现拒绝该请求并关闭连接，因为其潜在的请求夹带攻击( [HTTP/1.1] 节 11.2)。客户端不应该在 HEAD 请求中生成内容，除非它直接发送到一个源服务器，该服务器先前在带内或带外表明该请求有目的并将得到充分支持。原始服务器不应该依赖私有协议来接收内容，因为 HTTP 通信的参与者通常不知道请求链上的中介。

HEAD 请求的响应是可缓存的;缓存可以使用它来满足后续的头请求，除非 Cache-Control 头字段另有指示([缓存]节5.2)。HEAD 响应也可能会影响之前缓存的 GET 响应;参见 [CACHING] 的第 4.3.5 节。

#### 9.3.3. POST

POST 方法要求目标资源根据资源自身的特定语义处理请求中包含的表示。例如，POST 用于下列功能:

- 向数据处理过程提供一个数据块，例如在 HTML 表单中输入的字段;
- 在公告板、新闻组、邮件列表、博客或类似的文章组中发布消息;
- 创建一个源服务器尚未识别的新资源;
- 向资源的现有表示形式追加数据。

源服务器根据 POST 请求的处理结果选择合适的状态码，表示响应语义;本规范定义的几乎所有状态码都可以在POST的响应中收到 (除了 206(Partial Content)、304(Not Modified) 和 416(Range Not Satisfiable))。

如果成功处理 POST 请求后，在源服务器上创建了一个或多个资源，源服务器应该发送 201(created) 响应，其中包含一个 Location 首部字段，该字段提供了创建的主资源的标识符(章节10.2.2)，以及一个表示，描述了请求的状态，同时引用了新资源。

POST 请求的响应只有在包含明确的新鲜度信息(参见[缓存]的4.2.1节) 和与 POST 的目标 URI 值相同的 Content-Location 首部字段(8.7节)时才可缓存。缓存的 POST 响应可以重用，以满足稍后的 GET 或 HEAD 请求。相比之下，缓存的 POST 响应无法满足 POST 请求，因为 POST 可能不安全;参见 [CACHING] 的第 4 节。

如果 POST 的处理结果相当于现有资源的表示，则源服务器可以通过发送 303(See Other) 响应，将用户代理重定向到该资源，其中的Location字段包含现有资源的标识符。这样做的好处是为用户代理提供一个资源标识符，并通过一种更适合共享缓存的方法来传输表示，但如果用户代理还没有缓存表示，则需要额外的请求。

#### 9.3.4. PUT

PUT 方法请求用请求消息内容中包含的表示所定义的状态创建或替换目标资源的状态。对给定表示的成功 PUT 将表明对同一目标资源的后续 GET 将导致在 200(OK) 响应中发送等效表示。然而，不能保证这样的状态变化是可观察到的，因为目标资源可能由其他用户代理并行操作，或者可能在接收到任何后续 GET 之前受到源服务器的动态处理。一个成功的响应只意味着用户代理在源服务器处理它的时候达到了目的。

如果目标资源没有当前表示，而 PUT 成功创建了一个，那么源服务器必须通过发送 201(已创建) 响应通知用户代理。如果目标资源确实有一个当前的表示，并且该表示根据所附表示的状态被成功修改，那么源服务器必须发送一个 200(OK) 或 204(No Content) 响应来表示请求成功完成。

源服务器应该验证 PUT 表示是否与其为目标资源配置的约束一致。例如，如果源服务器基于 URI 确定资源的表示元数据，则源服务器需要确保在成功的 PUT 请求中接收到的内容与该元数据一致。当 PUT 表示与目标资源不一致时，源服务器应该通过转换表示或更改资源配置使它们一致，或者响应包含充分信息的适当错误消息来解释表示不合适的原因。409(Conflict) 或 415(Unsupported Media Type) 状态码是建议的，后者是特定于内容类型值的约束。

例如，如果目标资源被配置为始终具有 "text/html" 的 Content-Type，并且 PUT 的表示形式具有 "image/jpeg" 的内容类型，那么源服务器应该执行以下操作之一:

- 重新配置目标资源以反映新的媒体类型;
- 在将其保存为新的资源状态之前，将 PUT 表示转换为与资源一致的格式;
- 使用 415(Unsupported Media Type) 响应拒绝请求，指示目标资源限制为 "text/html"，可能包括一个指向不同资源的链接，该资源将是新表示的合适目标。

除了用户代理请求的意图和源服务器响应的语义所能表达的内容外，HTTP 并没有确切定义 PUT 方法如何影响源服务器的状态。除了通过 HTTP 提供的接口之外，它没有定义资源可能是什么。它没有定义如何“存储”资源状态，也没有定义这种存储如何因资源状态的变化而改变，也没有定义源服务器如何将资源状态转换为表示形式。一般来说，服务器有意地隐藏资源接口背后的所有实现细节。

同时扩展到 header 和 trailer 字段的存储方式;虽然常见的报头字段(如 Content-Type)通常会在后续的 GET 请求中存储和返回，但 header 和 trailer 字段的处理是特定于接收请求的资源的。因此，源服务器应该忽略在 PUT 请求中接收到的无法识别的 header 和 trailer 字段(即，不将它们保存为资源状态的一部分)。

源服务器绝对不能在成功响应 PUT 时发送验证器字段(章节8.8)，例如 ETag 或 Last-Modified 字段，除非请求的表示数据保存时没有对内容应用任何转换(即资源的新表示数据与 PUT 请求中接收到的内容相同)，并且验证器字段值反映了新的表示。这一需求允许用户代理知道它发送(并保留在内存中的)的表示何时是 PUT 的结果，因此不需要再次从源服务器检索它。在响应中接收到的新验证器可以用于将来的条件请求，以防止意外覆盖(第13.1节)。

POST 方法和 PUT 方法的根本区别在于封装方式的不同意图。POST 请求中的目标资源是根据资源自身的语义来处理封装的表示，而 PUT 请求中的封装表示被定义为替换目标资源的状态。因此，PUT 的意图是幂等 (idempotent) 的，中介可以看到，尽管确切的效果只有原始服务器知道。

PUT 请求的正确解释假定用户代理知道需要哪个目标资源。在接收到更改状态的请求后，代表客户端选择合适的 URI 的服务应该使用 POST 方法而不是 PUT 方法实现。如果源服务器不会对目标资源进行请求的 PUT 状态更改，而是希望将其应用于不同的资源，例如当资源已移动到不同的 URI 时，则源服务器必须发送适当的 3xx(Redirect) 响应;然后，用户代理可以自己决定是否重定向请求。

应用到目标资源的 PUT 请求可能会对其他资源产生副作用。例如，一篇文章可能有一个标识“当前版本”(一个资源)的 URI，它与标识每个特定版本(在某一点上与当前版本资源共享相同状态的不同资源)的 URI 是分开的。因此，对“当前版本” URI 的成功 PUT 请求可能会创建一个新版本资源，并改变目标资源的状态，还可能导致在相关资源之间添加链接。

有些源服务器支持使用 Content-Range 首部字段(14.4节)作为请求修饰符来执行部分 PUT，如 14.5 节所述。

PUT 方法的响应是不可缓存的。如果一个成功的 PUT 请求通过了一个缓存，其中存储了一个或多个目标 URI 的响应，这些存储的响应将失效(参见[缓存]的4.4节)。

#### 9.3.5. DELETE

DELETE 方法请求源服务器删除目标资源与其当前功能之间的关联。实际上，这种方法类似于 UNIX 中的 "rm" 命令:它表示对原始服务器的 URI 映射进行删除操作，而不是期望删除先前关联的信息。

如果目标资源有一个或多个当前表示，它们可能会被源服务器销毁，也可能不会被回收，关联的存储也可能不会被回收，这完全取决于资源的性质及其由源服务器实现的情况(这超出了本规范的范围)。同样，由于 DELETE 操作，资源的其他实现方面可能需要停用或存档，例如数据库或网关连接。通常，假定源服务器只允许对具有指定机制的资源进行 DELETE 操作。

允许 DELETE 方法的资源相对较少 —— 它的主要用途是用于远程创作环境，其中用户对其效果有一定的指导。例如，先前使用 PUT 请求创建的资源，或者在 POST 请求的 201(created) 响应之后通过 Location 报头字段标识的资源，可能允许相应的 DELETE 请求撤销这些操作。类似地，实现创作功能的自定义用户代理实现(例如使用 HTTP 进行远程操作的修订控制客户端)可能会基于服务器的 URI 空间已被精心设计为与版本存储库对应的假设使用 DELETE。

如果成功应用了 DELETE 方法，源服务器应该发送:

- 202(Accepted) 状态码，如果行动可能会成功，但尚未颁布;
- 204(No Content) 状态码，如果该行为已经颁布，并且没有进一步的信息需要提供;
- 200(OK) 状态码，如果动作已经执行并且响应消息包含描述状态的表示。

尽管请求消息框架独立于所使用的方法，但在 DELETE 请求中接收到的内容没有一般定义的语义，不能改变请求的含义或目标，并且可能导致某些实现拒绝请求并关闭连接，因为它可能是请求夹带攻击( [HTTP/1.1] 第 11.2 节)。客户端不应该在 DELETE 请求中生成内容，除非它是直接发送给一个源服务器，该服务器之前已经在频带内或频带外表明该请求有目的并且将得到充分支持。源服务器不应该依赖私有协议来接收内容，因为 HTTP 通信的参与者通常不知道请求链上的中介。

DELETE 方法的响应是不可缓存的。如果一个成功的 DELETE 请求通过一个缓存，这个缓存有一个或多个目标 URI 的存储响应，那么这些存储的响应将会失效(参见 [CACHING] 的 4.4 节)。

#### 9.3.6. CONNECT

CONNECT 方法要求接收方建立一个到请求目标所标识的目标源服务器的隧道，如果成功，随后将其行为限制为在两个方向上盲目转发数据，直到隧道关闭。隧道通常用于创建一个端到端的虚拟连接，通过一个或多个代理，然后可以使用 TLS(传输层安全，TLS13) 进行保护。

CONNECT 使用一种特殊形式的请求目标，该方法唯一，只包含隧道目标的主机和端口号，用冒号分隔。没有默认端口;客户端必须发送端口号，即使连接请求是基于 URI 引用的，其中包含一个带有省略端口的授权组件(章节4.1)。例如,

```
CONNECT server.example.com:80 HTTP/1.1
Host: server.example.com
```

服务器必须拒绝以空端口号或无效端口号为目标的连接请求，通常通过响应 400(Bad Request) 状态码。

因为 CONNECT 改变了 HTTP 连接的 请求/响应 性质，所以特定的 HTTP 版本可能有不同的方式将其语义映射到协议的有线格式。

CONNECT 用于向代理发起请求。接收方可以通过直接连接到由请求目标标识的服务器，或者(如果配置为使用另一个代理)通过将连接请求转发到下一个入站代理来建立隧道。原始服务器可以接受 CONNECT 请求，但大多数原始服务器不实现CONNECT。

任何 2xx(Successful) 响应都表明发送方(以及所有入站代理)将在响应头部分之后立即切换到隧道模式;在该头部分之后收到的数据来自请求目标标识的服务器。除成功响应外的任何响应都表明隧道尚未形成。

当隧道中介体检测到任何一端关闭了它的连接时，隧道就会被关闭:中介体必须尝试将来自被关闭一端的所有未完成的数据发送到另一端，关闭两个连接，然后丢弃所有剩余的未传输的数据。

代理身份验证可用于建立创建隧道的权限。例如:

```
CONNECT server.example.com:443 HTTP/1.1
Host: server.example.com:443
Proxy-Authorization: basic aGVsbG86d29ybGQ=
```

建立到任意服务器的隧道有很大的风险，特别是当目标是众所周知的或保留的 TCP 端口，而不是用于 Web 通信时。例如，连接到 "example.com:25" 将建议代理连接到用于 SMTP 通信的预留端口;如果允许的话，这可能会诱使代理转发垃圾邮件。支持 CONNECT 的代理应该将其限制在一组有限的已知端口或一组可配置的安全请求目标。

服务器不能在 2xx(Successful) 响应中发送任何 Transfer-Encoding 或 Content-Length 头字段。客户端必须忽略在连接成功响应中收到的任何 Content-Length 或 Transfer-Encoding 头字段。

连接请求消息没有内容。在连接请求消息的首部部分之后发送的数据的解释与使用的 HTTP 版本有关。

CONNECT 方法的响应不可缓存。

#### 9.3.7. OPTIONS

OPTIONS 方法请求关于目标资源可用的通信选项的信息，可以在源服务器上，也可以在中间的中介上。此方法允许客户端确定与资源或服务器功能相关联的选项和/或需求，而不需要执行资源操作。

带有星号("\*")的选项请求作为请求目标(章节 7.1 )适用于一般的服务器，而不是特定的资源。由于服务器的通信选项通常取决于资源，所以 "\*" 请求只用于 "ping" 或 "no-op" 类型的方法;除了允许客户端测试服务器的功能之外，它什么也不做。例如，这可以用来测试代理是否符合 HTTP/1.1 (或不符合)。

如果请求目标不是星号，则选项请求应用于与目标资源通信时可用的选项。

对 OPTIONS 生成成功响应的服务器应该发送任何首部，这些首部可能表明服务器实现的、适用于目标资源的可选特性(例如，Allow)，包括本规范未定义的潜在扩展。响应内容(如果有的话)也可以以机器或人类可读的表示形式描述通信选项。本规范没有定义这种表示的标准格式，但可能由 HTTP 的未来扩展定义。

客户端可以在 OPTIONS 请求中发送 Max-Forwarded 报头字段，目标是请求链中的特定接收者(参见7.6.2节)。代理在转发请求时不能生成 Max-Forward 报头字段，除非接收到的请求带有 Max-Forward 字段。

生成包含内容的选项请求的客户端必须发送描述表示媒体类型的有效 Content-Type 头字段。注意，本规范没有定义此类内容的任何用途。

OPTIONS 方法的响应不可缓存。

#### 9.3.8. TRACE

TRACE 方法请求请求消息的一个远程的、应用程序级别的回环。请求的最终接收方应该将接收到的消息(不包括下面描述的一些字段)作为 200(OK) 响应的内容反映给客户端。 "message/http" 格式( [http /1.1] 章节 10.1)是这样做的一种方法。最终的接收者要么是原始服务器，要么是请求中第一个接收到 Max-Forwarded 值为 0 的服务器(章节 7.6.2)。

客户端不能在 TRACE 请求中生成包含可能被响应公开的敏感数据的字段。例如，用户代理在 TRACE 请求中发送存储的用户凭据(第 11 节)或 COOKIE [COOKIE] 是愚蠢的。请求的最终接收者在生成响应内容时应该排除任何可能包含敏感数据的请求字段。

TRACE 允许客户端查看从请求链的另一端接收到的内容，并使用该数据进行测试或诊断信息。我们对 Via 头字段(7.6.3节)的值特别感兴趣，因为它用于跟踪请求链。使用 Max-Forwarded 首部字段允许客户端限制请求链的长度，这对于测试无限循环中转发消息的代理链很有用。

客户端不能在 TRACE 请求中发送内容。

对 TRACE 方法的响应不可缓存。

## 10. Message Context

### 10.1. Request Context Fields

下面的请求头字段提供了关于请求上下文的附加信息，包括关于用户、用户代理和请求背后的资源的信息。

#### 10.1.1. Expect

请求中的 "Expect" 头字段表示为了正确处理此请求，服务器需要支持的一组行为(期望)。

```
  Expect =      #expectation
  expectation = token [ "=" ( token / quoted-string ) parameters ]
```

Expect 字段值不区分大小写。

该规范定义的唯一期望是 "100-continue" (没有定义参数)。

如果服务器接收到包含成员(不是 100-continue) 的 Expect 字段值，则可能返回 417(Expectation Failed) 状态码，表示无法满足预期。

"100-Continue" 期望通知收件人，客户端将在此请求中发送内容(可能是较大内容)，并希望接收 100(Continue) 临时响应，如果方法、目标 URI 和头字段不足以立即成功、重定向或错误响应。这允许客户端在实际发送内容之前等待一个值得发送内容的指示，这可以在数据很大或客户端预期可能发生错误时提高效率(例如，第一次发送状态更改方法时，没有事先验证身份凭据)。

例如，一个请求以

```
PUT /somewhere/fun HTTP/1.1
Host: origin.example.com
Content-Type: video/h264
Content-Length: 1234567890987
Expect: 100-continue
```

允许源服务器立即响应错误消息，例如 401(Unauthorized) 或 405(Method Not Allowed)，然后客户端才开始向管道传输不必要的数据。

客户端要求:

- 客户端不能在不包含内容的请求中生成 100-continue 期望。
- 在发送请求内容之前等待 100(Continue) 响应的客户端必须发送一个包含 100-Continue 期望的 Expect 头字段。
- 发送 100-continue 期望的客户端不需要等待任何特定的时间长度;这样的客户端即使还没有收到响应，也可以继续发送内容。此外，由于无法通过 HTTP/1.0 作为中介发送 100(Continue) 响应，这样的客户端不应该在发送内容之前等待一段不确定的时间。
- 在响应一个包含 100-continue 期望的请求时收到 417(Expectation Failed) 状态码的客户端应该在没有 100-continue 期望的情况下重复该请求，因为 417 响应仅仅表明响应链不支持期望(例如，它通过 HTTP/1.0 服务器)。

服务器要求:

- 在 HTTP/1.0 请求中收到 100-continue 期望的服务器必须忽略这个期望。
- 如果服务器已经收到了对应请求的部分或全部内容，或者分帧表明没有内容，则可能会忽略发送 100(Continue) 响应。
- 发送 100(Continue) 响应的服务器在接收并处理请求内容后，必须最终发送最终状态码，除非连接提前关闭。
- 在读取整个请求内容之前以最终状态码响应的服务器应该表明它是打算关闭连接(例如，参见 [HTTP/1.1] 的 9.6 节)还是继续读取请求内容。

在收到 HTTP/1.1 (或更高版本)的请求，其中包含方法、目标 URI 和包含 100-continue 期望和请求内容指示的完整首部时，源服务器必须发送以下内容:

- 如果状态可以通过检查方法、目标URI和头字段来确定，则返回带有最终状态码的立即响应；
- 立即响应 100(Continue)，鼓励客户端发送请求内容。

在收到 HTTP/1.1 (或更高版本)的请求时，该请求具有方法、目标URI和包含 100-continue 期望的完整首部部分，并表明接下来将是请求内容，代理必须:

- 如果状态可以通过检查方法、目标URI和头字段来确定，则发送带有最终状态码的立即响应；
- 通过向下一个入站服务器发送相应的请求行和首部部分，将请求转发到原始服务器。

如果代理相信(根据配置或过去的交互)下一个入站服务器只支持 HTTP/1.0，代理可以立即生成 100(Continue) 响应，鼓励客户端开始发送内容。

#### 10.1.2. From

#### 10.1.3. Referer

#### 10.1.4. TE

#### 10.1.5. User-Agent

### 10.2. Response Context Fields

#### 10.2.1. Allow

#### 10.2.2. Location

#### 10.2.3. Retry-After

#### 10.2.4. Server

### 11. HTTP Authentication

#### 11.1. Authentication Scheme

#### 11.2. Authentication Parameters

#### 11.3. Challenge and Response

#### 11.4. Credentials

#### 11.5. Establishing a Protection Space (Realm)

#### 11.6. Authenticating Users to Origin Servers

##### 11.6.1. WWW-Authenticate

##### 11.6.2. Authorzation

##### 11.6.3. Authentication-Info

#### 11.7. Authencating Clients to Proxies

##### 11.7.1. Proxy-Authenticate

##### 11.7.2. Proxy-Authorization

##### 11.7.3. Proxy-Authentication-Info

## 12. Content Negotiation

### 12.1. Proactive Negotiation

### 12.2. Reactive Negotiation

### 12.3. Request Content Negotiation

### 12.4. Content Negotitation Field Features

#### 12.4.1. Absence

#### 12.4.2. Quality Values

#### 12.4.3. Wildcard Values

### 12.5. Content Negotiation Fields

#### 12.5.1. Accept

#### 12.5.2. Accept-Charset

#### 12.5.3. Accept-Encoding

#### 12.5.4. Accept-Language

#### 12.5.5. Vary

## 13. Conditional Requests

### 13.1. Preconditions

#### 13.1.1. If-Match

#### 13.1.2. If-None-Match

#### 13.1.3. If-Modified-Since

#### 13.1.4. If-Unmodified-Since

#### 13.1.5. If-Range

## 14. Range Requests

### 14.1. Range Units

#### 14.1.1. Range Specifiers

#### 14.1.2. Byte Ranges

### 14.2. Range

### 14.3. Accept-Ranges

### 14.4. Content-Range

### 14.5. Partial PUT

### 14.6. Media Type multipart/byteranges

## 15. Status Codes

### 15.1. Overview of Status Codes

### 15.2. Infomational 1xx

#### 15.2.1. 100 Continue

#### 15.2.2. 101 Switching Protocols

### 15.3. Successful 2xx

#### 15.3.1. 200 OK

#### 15.3.2. 201 Created

#### 15.3.3. 202 Accepted

#### 15.3.4. 203 Non-Authoritative Information

#### 15.3.5. 204 No Content

#### 15.3.6. 205 Reset Content

#### 15.3.7. 206 Partial Content

##### 15.3.7.1. Single Part

##### 15.3.7.2. Multiple Parts

##### 15.3.7.3. Combining Parts

### 15.4. Redirection 3xx

#### 15.4.1. 300 Multiple Choices

#### 15.4.2. 301 Moved Permanently

#### 15.4.3. 302 Found

#### 15.4.4. 303 See Other

#### 15.4.5. 304 Not Modified

#### 15.4.6. 305 Use Proxy

#### 15.4.7. 306 (Unused)

#### 15.4.8. 307 Temporary Redirect

#### 15.4.9. 308 Permanent Redirect

### 15.5. Client Error 4xx

#### 15.5.1 400 Bad Request

#### 15.5.2 401 Unauthorized

#### 15.5.3 402 Payment Required

#### 15.5.4 403 Forbidden

#### 15.5.5 404 Not Found

#### 15.5.6 405 Method Not Allowed

#### 15.5.7 406 Not Acceptable

#### 15.5.8 407 Proxy Authentication Required

#### 15.5.9 408 Request Timeout

#### 15.5.10 409 Conflict

#### 15.5.11 410 Gone

#### 15.5.12 411 Length Required

#### 15.5.13 412 Precondition Failed

#### 15.5.14 413 Content Too Large

#### 15.5.15 414 URI Too Long

#### 15.5.16 415 Unsupported Media Type

#### 15.5.17 416 Range Not Satisfiable

#### 15.5.18 417 Expectation Failed

#### 15.5.19 418 (Unused)

#### 15.5.20 421 Misdirected Request

#### 15.5.21 422 Unprocessalbe Content

#### 15.5.22 426 Upgrade Required

### 15.6. Server Error 5xx

#### 15.6.1. 500 Internal Server Error

#### 15.6.2. 501 Not Implemented

#### 16.6.3. 502 Bad Gateway

#### 16.6.4. 503 Service Unavailable

#### 16.6.5. 504 Gateway Timeout

#### 16.6.6. 505 HTTP Version Not Supported

## 16. Extending HTTP

### 16.1. Method Extensibility

#### 16.1.1. Method Registry

#### 16.1.2. Considerations for New Methods

### 16.2. Status Code Extensibility

#### 16.2.1. Status Code Registry

#### 16.2.2. Considerations for New Status codes

### 16.3. Field Extensibility

#### 16.3.1. Field Name Registry

#### 16.3.2. Considerations for New Field Names

##### 16.3.2.1. Considerations for New Field Names

##### 16.3.2.2. Considerations for New Field Values

### 16.4. Authentication Scheme Extensibility

#### 16.4.1. Authentication Scheme Registry

#### 16.4.2. Consierations for New Authentication Schemes

### 16.5. Range Unit Extensibility

#### 16.5.1. Range Unit Registry

#### 16.5.2. Considerations for New Range Units

### 16.6. Content Coding Extensibility

#### 16.6.1. Content Coding Registry

#### 16.6.2. Considerations for New Content Codings

### 16.7. Upgrade Token Registry

## 17. Security Considerations

### 17.1. Establishing Authority

### 17.2. Risks of Intermediaries

### 17.3. Attacks Based on File and Path Names

### 17.4. Attacks Based on Command, Code, or Query Injection

### 17.5. Attacks via Protocol Element Length

### 17.6. Attacks Using Shared-Dictionary Compression

### 17.7. Disclosure of Personal Information

### 17.8. Privacy of Server Log Information

### 17.9. Disclosure of Personal Information

### 17.10. Privacy of Server Log Information

### 17.11. Disclosure of Fragment after Redirects

### 17.12. Disclosure of Product Information

### 17.13. Browser Fingerprinting

### 17.14. Validator Retention

### 17.15. Denial-of-Service Attacks Using Range

### 17.16. Authetication Considerations

#### 17.16.1. Confidentiality of Credentials

#### 17.16.2. Credentials and Idle Clients

#### 17.16.3. Protection Spaces

#### 17.16.4. Additional Response Fields

## 18. IANA Considerations

### 18.1. URI Scheme Registration

### 18.2. Method Registration

### 18.3. Status Code Registration

### 18.4. Field Name Registration

### 18.5. Authentication Scheme Registration

### 18.6. Content Coding Registration

### 18.7. Range Unit Registration

### 18.8. Media Type Registration

### 18.9. Port Registration

### 18.10. Upgrade Token Registration

## 19. References

## Appendix A. Collected ABNF
