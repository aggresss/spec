# HTTP/3

> 原文 [https://www.rfc-editor.org/rfc/rfc9114](https://www.rfc-editor.org/rfc/rfc9114)

## 摘要

QUIC 传输协议有几个 HTTP 传输中需要的特性，例如流多路复用、每流流控制和低延迟连接建立。本文档描述了 HTTP 语义在 QUIC 上的映射。本文档还确定了 QUIC 包含的 HTTP/2 功能，并描述了如何将 HTTP/2 扩展移植到 HTTP/3。

## 1. Introduction

HTTP 语义 ( [ HTTP ] ) 用于 Internet 上范围广泛的服务。这些语义最常用于 HTTP/1.1 和 HTTP/2。HTTP/1.1 已用于各种传输层和会话层，而 HTTP/2 主要用于 TCP 上的 TLS。HTTP/3 通过新的传输协议支持相同的语义：QUIC。

### 1.1. Prior Versions of HTTP

HTTP/1.1 ( [ HTTP/1.1 ] ) 使用空格分隔的文本字段来传送 HTTP 消息。虽然这些交换是人类可读的，但使用空格进行消息格式化会导致解析复杂性和对变异行为的过度容忍。

因为 HTTP/1.1 不包含多路复用层，所以通常使用多个 TCP 连接来并行处理请求。然而，这对拥塞控制和网络效率有负面影响，因为 TCP 不在多个连接之间共享拥塞控制。

HTTP/2 ( [ HTTP/2 ] ) 引入了一个二进制帧和多路复用层，以在不修改传输层的情况下改善延迟。然而，由于 HTTP/2 的多路复用的并行性质对于 TCP 的丢失恢复机制是不可见的，丢失或重新排序的数据包会导致所有活动事务出现停顿，无论该事务是否直接受到丢失数据包的影响。

### 1.2. Delegation to QUIC

QUIC 传输协议结合了流多路复用和每个流的流量控制，类似于 HTTP/2 帧层提供的功能。通过在流级别提供可靠性和跨整个连接的拥塞控制，与 TCP 映射相比，QUIC 有能力提高 HTTP 的性能。QUIC还在传输层整合了 TLS 1.3 ( [ TLS ] )，提供与在 TCP 上运行 TLS 相当的机密性和完整性，并改进了 TCP 快速打开 ( [ TFO ] ) 的连接设置延迟。

本文档定义了 HTTP/3：HTTP 语义在 QUIC 传输协议上的映射，很大程度上借鉴了 HTTP/2 的设计。HTTP/3 依靠 QUIC 提供数据的机密性和完整性保护；对等认证；可靠、有序、按流传输。在将流生命周期和流量控制问题委托给 QUIC 时，每个流都使用了类似于 HTTP/2 帧的二进制帧。QUIC 包含一些 HTTP/2 功能，而其他功能则在 QUIC 之上实现。

QUIC 在[ QUIC-TRANSPORT ]中有描述。有关 HTTP/2 的完整描述，请参阅[ HTTP/2 ]。

## 2. HTTP/3 Protocol Overview

HTTP/3 使用 QUIC 传输协议和类似于 HTTP/2 的内部帧层为 HTTP 语义提供传输。

一旦客户端知道某个端点存在 HTTP/3 服务器，它就会打开 QUIC 连接。QUIC 提供协议协商、基于流的多路复用和流量控制。3.1 节描述了 HTTP/3 端点的发现 。

在每个流中，HTTP/3 通信的基本单位是帧（第 7.2 节）。每种帧类型都有不同的用途。例如，标题 和数据帧构成 HTTP 请求和响应的基础（第 4.1 节）。适用于整个连接的帧在专用控制流上传送.

使用 QUIC 流抽象执行请求的多路复用，这在[ QUIC-TRANSPORT ]的第 2 节中进行了描述。每个请求-响应对使用单个 QUIC 流。流彼此独立，因此一个流被阻塞或遭受数据包丢失不会阻止其他流的进展。

服务器推送是 HTTP/2 ( [ HTTP/2 ] ) 中引入的一种交互模式，它允许服务器在客户端发出指示请求的情况下将请求-响应交换推送到客户端。这会权衡网络使用与潜在的延迟增益。几个 HTTP/3 帧用于管理服务器推送，例如 PUSH_PROMISE, MAX_PUSH_ID, 和 CANCEL_PUSH.

与 HTTP/2 一样，请求和响应字段在传输时被压缩。因为 HPACK ( [ HPACK ] ) 依赖于压缩字段部分的有序传输 (QUIC 不提供保证)，HTTP/3 将 HPACK 替换为 QPACK ( [ QPACK ] )。QPACK 使用单独的单向流来修改和跟踪字段表状态，而编码字段部分引用表的状态而不修改它。

### 2.1. Document Organization

以下部分详细概述了 HTTP/3 连接的生命周期：

- “连接设置和管理”（第 3 节）介绍了如何发现 HTTP/3 端点和建立 HTTP/3 连接。
- “在 HTTP/3 中表达 HTTP 语义”（第 4 节）描述了如何使用帧来表达 HTTP 语义。
- “ Connection Closure ”（第 5 节）描述了 HTTP/3 连接是如何终止的，无论是优雅的还是突然的。

协议的细节和与传输的交互在后续部分中描述：

- “流映射和使用”（第 6 节）描述了 QUIC 流的使用方式。
- “HTTP 帧层”（第 7 节）描述了大多数流中使用的帧。
- “错误处理”（第 8 节）描述了如何处理和表达错误条件，无论是针对特定流还是针对整个连接。

最后几节提供了其他资源：

- “HTTP/3 的扩展”（第 9 节）描述了如何在未来的文档中添加新功能。
- 可以在 附录 A 中找到 HTTP/2 和 HTTP/3 之间更详细的比较。

### 2.2. Conventions and Terminology

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.

This document uses the variable-length integer encoding from [QUIC-TRANSPORT].

The following terms are used:

- abort: An abrupt termination of a connection or stream, possibly due to an error condition.
- client: The endpoint that initiates an HTTP/3 connection. Clients send HTTP requests and receive HTTP responses.
- connection: A transport-layer connection between two endpoints using QUIC as the transport protocol.
- connection error: An error that affects the entire HTTP/3 connection.
- endpoint: Either the client or server of the connection.
- frame: The smallest unit of communication on a stream in HTTP/3, consisting of a header and a variable-length sequence of bytes structured according to the frame type.

Protocol elements called "frames" exist in both this document and [QUIC-TRANSPORT]. Where frames from [QUIC-TRANSPORT] are referenced, the frame name will be prefaced with "QUIC". For example, "QUIC CONNECTION_CLOSE frames". References without this preface refer to frames defined in Section 7.2.

- HTTP/3 connection: A QUIC connection where the negotiated application protocol is HTTP/3.
- peer: An endpoint. When discussing a particular endpoint, "peer" refers to the endpoint that is remote to the primary subject of discussion.
- receiver: An endpoint that is receiving frames.
- sender: An endpoint that is transmitting frames.
- server: The endpoint that accepts an HTTP/3 connection. Servers receive HTTP requests and send HTTP responses.
- stream: A bidirectional or unidirectional bytestream provided by the QUIC transport. All streams within an HTTP/3 connection can be considered "HTTP/3 streams", but multiple stream types are defined within HTTP/3.
- stream error:

An application-level error on the individual stream.

The term "content" is defined in Section 6.4 of [HTTP].

Finally, the terms "resource", "message", "user agent", "origin server", "gateway", "intermediary", "proxy", and "tunnel" are defined in Section 3 of [HTTP].

Packet diagrams in this document use the format defined in Section 1.3 of [QUIC-TRANSPORT] to illustrate the order and size of fields.

## 3. Connection Setup and Management

### 3.1. Discovering an HTTP/3 Endpoint

HTTP 依赖于权威响应的概念：在源服务器（或在其方向）发出响应消息时，在给定目标资源状态的情况下，已确定该响应是对该请求最合适的响应在目标 URI 中标识。[ HTTP ]的第 4.3 节讨论了为 HTTP URI 定位权威服务器。

“https” 方案将授权与证书的拥有相关联，客户端认为该证书对于由 URI 的授权组件标识的主机是值得信赖的。在 TLS 握手中收到服务器证书后，客户端 必须使用[ HTTP ]的第 4.3.4 节 中描述的过程验证该证书是否与 URI 的原始服务器匹配。如果证书无法针对 URI 的源服务器进行验证，则客户端 不得 认为该服务器是该源的权威服务器。

客户端 可以 尝试访问具有 “https” URI 的资源，方法是将主机标识符解析为 IP 地址，在指定端口上建立到该地址的 QUIC 连接（包括如上所述的服务器证书验证），并发送一个 HTTP/3 请求消息通过该安全连接将 URI 定向到服务器。除非使用某些其他机制来选择 HTTP/3，否则在 TLS 握手期间，令牌 “h3” 用于应用层协议协商（ALPN；参见 [ RFC7301 ]）扩展。

连接问题（例如，阻塞 UDP）可能导致无法建立 QUIC 连接；在这种情况下，客户端 应该 尝试使用基于 TCP 的 HTTP 版本。

服务器 可以 在任何 UDP 端口上提供 HTTP/3；替代服务广告总是包含一个显式端口，并且 URI 包含一个显式端口或与方案关联的默认端口。

#### 3.1.1. HTTP Alternative Services

HTTP 来源可以使用 “h3” ALPN 令牌通过 Alt-Svc HTTP 响应标头字段或 HTTP/2 ALTSVC 帧（[ ALTSVC ] ）通告等效 HTTP/3 端点的可用性。

例如，源可以在 HTTP 响应中指示 HTTP/3 在同一主机名的 UDP 端口 50781 上可用，方法是包含以下标头字段：

```
Alt-Svc: h3=":50781"
```

在收到指示 HTTP/3 支持的 Alt-Svc 记录后，客户端 可以 尝试建立到指定主机和端口的 QUIC 连接；如果此连接成功，则客户端可以使用本文档中描述的映射发送 HTTP 请求。

#### 3.1.2. Oter Schemes

尽管 HTTP 独立于传输协议，但 “http” 方案将权限与在权限组件中标识的任何主机的指定端口上接收 TCP 连接的能力相关联。因为 HTTP/3 不使用 TCP，所以 HTTP/3 不能用于直接访问由 “http” URI 标识的资源的权威服务器。但是， [ ALTSVC ]等协议扩展允许权威服务器识别其他同样具有权威性且可能可通过 HTTP/3 访问的服务。

在对方案不是 “https” 的来源发出请求之前，客户端必须确保服务器愿意为该方案提供服务。对于方案为 “http” 的来源， [ RFC8164 ]中描述了实现此目的的实验方法。将来可能会为各种方案定义其他机制。

### 3.2. Connection Establishment

HTTP/3 依赖 QUIC 版本 1 作为底层传输。未来的规范可能会定义其他 QUIC 传输版本与 HTTP/3 的使用 。

QUIC 版本 1 使用 TLS 版本 1.3 或更高版本作为其握手协议。HTTP/3 客户端 必须 支持一种机制，在 TLS 握手期间向服务器指示目标主机。如果服务器由域名 ( [ DNS-TERMS ] ) 标识，客户端 必须 发送服务器名称指示 (SNI; [ RFC6066 ] ) TLS 扩展，除非使用替代机制来指示目标主机。

QUIC 连接按照[ QUIC-TRANSPORT ]中的描述建立。在连接建立期间，通过在 TLS 握手中选择 ALPN 令牌 “h3” 来指示 HTTP/3 支持。可以 在同一握手中提供对其他应用层协议的支持 。

虽然与核心 QUIC 协议相关的连接级选项是在初始加密握手中设置的，但特定于 HTTP/3 的设置是在 SETTINGS 中传达 的帧。QUIC 连接建立后，一个 SETTINGS 帧必须由每个端点作为各自 HTTP 控制流的初始帧发送.

### 3.3. Connection Reuse

HTTP/3 连接在多个请求中是持久的。为了获得最佳性能，预计客户端不会关闭连接，直到确定不需要与服务器进行进一步通信（例如，当用户导航离开特定网页时）或直到服务器关闭连接。

一旦存在到服务器端点的连接，这个连接可以被重新用于具有多个不同 URI 授权组件的请求。要将现有连接用于新源，客户端 必须使用[ HTTP ]的第 4.3.4 节 中描述的过程验证服务器为新源服务器提供的证书。这意味着客户端将需要保留服务器证书以及验证该证书所需的任何其他信息；不这样做的客户端将无法将连接重用于其他来源。

如果由于任何原因证书对于新源不可接受，则 不得 重用连接并且 应该 为新源建立新连接。如果无法验证证书的原因可能适用于已经与连接关联的其他来源，则客户端 应该 为这些来源重新验证服务器证书。例如，如果由于证书已过期或被吊销而导致证书验证失败，则这可能用于使使用该证书建立授权的所有其他来源无效。

客户端 不应该 打开多个 HTTP/3 连接到给定的 IP 地址和 UDP 端口，其中 IP 地址和端口可能来自 URI、选定的替代服务（[ ALTSVC ]）、配置的代理或名称解析任何这些。客户端 可以 使用不同的传输或 TLS 配置打开到同一 IP 地址和 UDP 端口的多个 HTTP/3 连接，但 应该 避免使用相同的配置创建多个连接。

鼓励服务器尽可能长时间保持开放的 HTTP/3 连接，但允许在必要时终止空闲连接。当任一端点选择关闭 HTTP/3 连接时，终止端点 应该 首先发送一个GOAWAY帧（第 5.2 节），以便两个端点都可以可靠地确定先前发送的帧是否已被处理，并优雅地完成或终止任何必要的剩余任务。

不希望客户端为特定来源重用 HTTP/3 连接的服务器可以通过发送 421(Misdirected Request) 状态代码响应请求来表明它对请求没有权威；请参阅[ HTTP ]的第 7.4 节。

## 4. Expressing HTTP Semantics in HTTP/3

### 4.1. HTTP Message Framing

客户端在请求流上发送 HTTP 请求，这是一个客户端发起的双向 QUIC 流；参见第 6.1 节。客户端 必须 在给定的流上只发送一个请求。服务器在与请求相同的流上发送零个或多个临时 HTTP 响应，然后是单个最终 HTTP 响应，如下所述。有关临时和最终 HTTP 响应的描述，请参见[ HTTP ]的第 15 节。

推送响应在服务器发起的单向 QUIC 流上发送；参见 第 6.2.2 节。服务器以与标准响应相同的方式发送零个或多个临时 HTTP 响应，然后是单个最终 HTTP 响应。推送在第 4.6 节中有更详细的描述。

在给定的流上，接收到多个请求或在最终 HTTP 响应之后接收到额外的 HTTP 响应 必须 被视为格式错误.

HTTP 消息（请求或响应）包括：

- 标头部分，包括消息控制数据，作为单个标头发送 帧，
- 可选地，内容（如果存在）作为一系列数据发送帧，和
- 可选地，trailer 部分（如果存在）作为单个标题发送帧。

Header 和 Trailer 部分在[ HTTP ]的第 6.3和6.5节中描述；内容在[ HTTP ]的第 6.4 节中描述。

收到无效的帧序列 必须 被视为连接错误 类型 H3_FRAME_UNEXPECTED. 特别是，一个 HEADERS 帧前的 DATA 帧，或 HEADER 和 DATA 帧之前的 Trailing HEADERS 帧，被认为是无效的。其他帧类型，尤其是未知的帧类型，可能会根据它们自己的规则被允许；见第 9 节。

服务器 可以 发送一个或多个 PUSH_PROMISE 在响应消息的帧之前、之后或交错的帧。这些 PUSH_PROMISE 帧不是响应的一部分；有关更多详细信息，请参阅第 4.6 节。 PUSH_PROMISE 推流不允许帧; 包含 PUSH_PROMISE 的推送响应帧 必须 被视为连接错误 类型 H3_FRAME_UNEXPECTED.

未知类型的帧（第 9 节），包括保留帧（第 7.2.8 节） 可以 在请求或推送流上发送在本节中描述的其他帧之前、之后或交织。

标头和PUSH_PROMISE帧可能引用对 QPACK 动态表的更新。虽然这些更新不是消息交换的直接组成部分，但必须先接收并处理它们，然后才能使用消息。有关详细信息，请参阅 第 4.2 节。

传输编码（参见[ HTTP/1.1 ]的第 7 节）没有为 HTTP/3 定义；不得 使用 Transfer-Encoding 标头字段 。

当且仅当一个或多个临时响应（1xx；参见[ HTTP] 的第15.2节）先于对同一请求的最终响应时，一个响应可以包含多个消息。临时回复不包含内容或 trailer 部分。

HTTP 请求/响应 交换完全消耗客户端发起的双向 QUIC 流。发送请求后，客户端必须关闭流以进行发送。除非使用 CONNECT 方法（参见第 4.4 节），否则客户端不得使流关闭依赖于接收对其请求的响应。发送最终响应后，服务器必须关闭流以进行发送。至此，QUIC 流完全关闭。

当流关闭时，这表示最终 HTTP 消息结束。因为有些消息很大或不受限制，端点应该在接收到足够的消息以取得进展后开始处理部分 HTTP 消息。如果客户端启动的流终止而没有足够的 HTTP 消息来提供完整的响应，服务器应该中止其响应流，错误代码为 H3_REQUEST_INCOMPLETE.

如果响应不依赖于尚未发送和接收的请求的任何部分，则服务器可以在客户端发送整个请求之前发送完整的响应。当服务器不需要接收请求的剩余部分时，它可以中止读取请求流，发送完整的响应，并干净地关闭流的发送部分。错误代码 H3_NO_ERROR 请求客户端停止发送请求流时应该使用. 客户端 不得 因为请求突然终止而丢弃完整的响应，尽管客户端总是可以出于其他原因自行决定丢弃响应。如果服务器发送了部分或完整的响应但没有中止读取请求，客户端 应该 继续发送请求的内容并正常关闭流。

#### 4.1.1. Request Cancellation and Rejection

一旦一个请求流已经打开，请求 可以 被任一端点取消。如果响应不再感兴趣，客户会取消请求；如果服务器无法响应或选择不响应，则服务器会取消请求。如果可能，建议 服务器 发送带有适当状态代码的 HTTP 响应，而不是取消它已经开始处理的请求。

实现 应该 通过突然终止仍然打开的流的任何方向来取消请求。为此，实现重置流的发送部分并中止流的接收部分的读取；参见 [ QUIC-TRANSPORT ]的第 2.4 节。

当服务器在不执行任何应用程序处理的情况下取消请求时，该请求被认为是“被拒绝的”。服务器 应该 使用错误代码 H3_REQUEST_REJECTED中止其响应流. 在此上下文中，“已处理”意味着流中的一些数据被传递到某个更高层的软件，这些软件可能因此采取了一些行动。客户端可以将被服务器拒绝的请求视为根本没有发送过，从而允许稍后重试。

服务器 不得 使用 H3_REQUEST_REJECTED 已部分或完全处理的请求的错误代码。当服务器在部分处理后放弃响应时，它 应该 使用错误代码 H3_REQUEST_CANCELLED 中止其响应流.

客户端 应该 使用错误代码 H3_REQUEST_CANCELLED 取消请求。收到此错误代码后，服务器 可以使用错误代码 H3_REQUEST_REJECTED 突然终止响应如果没有进行任何处理。客户端 不得 使用 H3_REQUEST_REJECTED 错误代码，除非服务器请求关闭请求流使用此错误代码。

如果流在收到完整的响应后被取消，客户端 可以 忽略取消并使用响应。但是，如果流在收到部分响应后被取消，则 不应 使用该响应。只有 GET、PUT 或 DELETE 等幂等操作才能安全重试；客户端不应该 使用非幂等方法自动重试请求，除非它有一些方法知道请求语义是独立于方法的幂等的，或者有一些方法可以检测到原始请求从未被应用过。有关详细信息，请参阅[ HTTP ]的第 9.2.2 节。

#### 4.1.2. Malformed Requests and Responses

格式错误的请求或响应是一个原本有效的帧序列，但由于以下原因而无效：

- 禁止字段或伪标题字段的存在，
- 没有强制性的伪标题字段，
- 伪头字段的无效值，
- 字段后的伪标题字段，
- 无效的 HTTP 消息序列，
- 包含大写字段名称，或
- 在字段名称或值中包含无效字符。

如果 Content-Length 标头字段的值不等于 DATA 的总和，则在包含 Content-Length 标头字段（[ HTTP ]的第 8.6 节）时被定义为具有内容的请求或响应是格式错误的 收到的帧长度。被定义为从不包含内容的响应，即使存在 Content-Length，也可以具有非零的 Content-Length 标头字段，即使 DATA 中不包含任何内容帧。

处理 HTTP 请求或响应的中介（即任何不充当隧道的中介） 不得转发格式错误的请求或响应。检测到的格式错误的请求或响应必须被视为流错误类型 H3_MESSAGE_ERROR.

对于格式错误的请求，服务器可以在关闭或重置流之前发送一个 HTTP 响应指示错误。客户端不得接受格式错误的响应。请注意，这些要求旨在防止针对 HTTP 的几种常见攻击类型；他们故意严格，因为宽容会使实现暴露于这些漏洞。

### 4.2. HTTP Fields

HTTP 消息携带元数据作为一系列称为 “HTTP 字段” 的键值对；请参阅[ HTTP ]的第 6.3 节和第 6.5 节。有关已注册 HTTP 字段的列表，请参阅维护在 <https://www.iana.org/assignments/http-fields/> 的“超文本传输​​协议 (HTTP) 字段名称注册表” 。与 HTTP/2 一样，HTTP/3 在字段名称、连接标头字段和伪标头字段中使用与字符相关的其他注意事项。

字段名称是包含 ASCII 字符子集的字符串。HTTP 字段名称和值的属性在[ HTTP ]的第 5.1 节中有更详细的讨论。字段名称中的字符 必须 在编码之前转换为小写。字段名称中包含大写字符的请求或响应 必须 被视为格式错误.

HTTP/3 不使用 Connection 标头字段来指示特定于连接的字段；在此协议中，特定于连接的元数据通过其他方式传送。端点不得生成包含连接特定字段的 HTTP/3 字段部分；任何包含连接特定字段的消息 必须被视为格式错误.

唯一的例外是 TE 标头字段，它可能出现在 HTTP/3 请求标头中；如果是，它不得包含除 “trailers” 以外的任何值。

将 HTTP/1.x 消息转换为 HTTP/3 的中介 必须删除特定于连接的标头字段，如[ HTTP ]的第 7.6.1 节 所述，否则它们的消息将被其他 HTTP/3 端点视为格式错误.

#### 4.2.1. Field Compression

[ QPACK ]描述了 HPACK 的一种变体，它使编码器可以控制压缩导致的队头阻塞程度。这允许编码器平衡压缩效率和延迟。HTTP/3 使用 QPACK 压缩标头和尾部部分，包括标头部分中存在的控制数据。

为了获得更好的压缩效率，Cookie 标头字段 ( [ COOKIES ] ) 可以 在压缩之前拆分为单独的字段行，每个字段行具有一个或多个 cookie 对。如果解压的字段部分包含多个 cookie 字段行，则 在传递到 HTTP/2 或 HTTP/3 以外的上下文之前，必须使用双字节定界符 “; ”（ASCII 0x3b、0x20）将这些连接成一个字节字符串，例如 HTTP/1.1 连接或通用 HTTP 服务器应用程序。

#### 4.2.2. Header Size Constraints

HTTP/3 实现可以对其在单个 HTTP 消息上接受的消息头的最大大小施加限制。接收到比它愿意处理的更大的标头部分的服务器可以发送 HTTP 431(Request Header Fields Too Large) 状态代码（[ RFC6585 ]）。客户端可以丢弃它无法处理的响应。字段列表的大小是根据字段的未压缩大小计算的，包括以字节为单位的名称和值的长度加上每个字段 32 字节的开销。

如果一个实现希望将此限制告知其对等方，则可以将其作为 SETTINGS_MAX_FIELD_SECTION_SIZE 中的字节数来传送范围。收到此参数的实现 不应 发送超过指定大小的 HTTP 消息头，因为对等方可能会拒绝处理它。但是，HTTP 消息在到达源服务器之前可以经过一个或多个中介；请参阅[ HTTP ]的第 3.7 节。由于此限制由处理消息的每个实现单独应用，因此不保证接受低于此限制的消息。

### 4.3. HTTP Control Data

与 HTTP/2 一样，HTTP/3 使用了一系列伪标头字段，其中字段名称以字符 ":"(ASCII 0x3a) 开头。这些伪报头字段传送消息控制数据；请参阅[ HTTP ]的第 6.2 节。

伪标头字段不是 HTTP 字段。除了本文档中定义的那些之外，端点不得生成伪报头字段。但是，拓展可以协商修改此限制；见 第 9 节。

伪标头字段仅在定义它们的上下文中有效。为请求定义的伪标头字段不得出现在响应中；为响应定义的伪标头字段不得出现在请求中。伪标头字段 不得 出现在尾部部分。端点必须将包含未定义或无效伪报头字段的请求或响应视为格式错误.

所有伪报头字段必须出现在报头部分中的常规报头字段之前。任何包含出现在常规标头字段之后的标头部分中的伪标头字段的请求或响应 必须被视为格式错误.

#### 4.3.1. Request Pseudo-Header Fields

为请求定义了以下伪标头字段：

- “:method”：包含 HTTP 方法（[ HTTP ]的第 9 节）
- “:scheme”：包含目标 URI 的方案部分（[ URI ]的第 3.1 节）。
    - :scheme 伪标头不限于具有方案“http”和“https”的 URI。代理或网关可以转换对非 HTTP 方案的请求，从而允许使用 HTTP 与非 HTTP 服务进行交互。
    - 有关使用“https”以外的方案的指南，请参阅第 3.1.2 节。
- “:authority”：包含目标 URI 的权限部分（[ URI ]的第 3.2 节）。授权机构 不得 为方案“http”或“https”的 URI 包含已弃用的 userinfo 子组件。
    - 为确保 HTTP/1.1 请求行可以准确再现，在从具有特定方法形式的请求目标的 HTTP/1.1 请求转换时，必须 省略此伪标头字段 ；请参阅[ HTTP ]的第 7.1 节。直接生成 HTTP/3 请求的客户端 应该 使用 :authority 伪标头字段而不是 Host 标头字段。将 HTTP/3 请求转换为 HTTP/1.1 的中介 必须 通过复制 :authority 伪标头字段的值来创建一个 Host 字段（如果该字段不存在于请求中）。
- “:path”：包含目标 URI 的路径和查询部分（“绝对路径”生产和可选的字符?（ASCII 0x3f）后跟“查询”生产；参见[ URI ]的第3.3和3.4节。
    - 对于“http”或“https”URI，此伪标头字段 不得为空；不包含路径组件的“http”或“https”URI 必须 包含值/(ASCII 0x2f)。不包含路径组件的 OPTIONS 请求包含*:path 伪标头字段的值 (ASCII 0x2a)；请参阅[ HTTP ]的第 7.1 节。

所有 HTTP/3 请求必须只包含 ":method"、":scheme" 和 ":path" 伪标头字段的一个值，除非请求是 CONNECT 请求；参见 第 4.4 节。

如果 :scheme 伪标头字段标识具有强制权限组件（包括“http”和“https”）的方案，则请求 必须 包含 ":authority" 伪标头字段或主机标头字段。如果存在这些字段，则它们不得为空。如果两个字段都存在，则它们必须包含相同的值。如果该方案没有强制性的授权组件并且在请求目标中没有提供，则请求 不得 包含 ":authority" 伪标头或主机标头字段。

省略强制伪标头字段或包含这些伪标头字段的无效值的 HTTP 请求格式错误.

HTTP/3 没有定义携带 HTTP/1.1 请求行中包含的版本标识符的方法。HTTP/3 请求隐式具有协议版本 “3.0”。

#### 4.3.2. Response Pseudo-Header Fields

对于响应，定义了一个包含 HTTP 状态代码的 “:status” 伪标头字段；请参阅[ HTTP ]的第 15 节。这个伪报头字段必须包含在所有响应中；否则，响应格式错误 （参见第 4.1.2 节）。

HTTP/3 没有定义一种方式来携带包含在 HTTP/1.1 状态行中的版本或原因短语。HTTP/3 响应隐式具有协议版本 “3.0”。

### 4.4. The CONNECT Method

CONNECT 方法请求接收者建立到 request-target 标识的目标源服务器的隧道；请参阅[ HTTP ]的第 9.3.6 节。它主要与 HTTP 代理一起使用，以与源服务器建立 TLS 会话，以便与 “https” 资源进行交互。

在 HTTP/1.x 中，CONNECT 用于将整个 HTTP 连接转换为到远程主机的隧道。在 HTTP/2 和 HTTP/3 中，CONNECT 方法用于在单个流上建立隧道。

CONNECT 请求 必须 构造如下：

- :method 伪标头字段设置为 “CONNECT”
- 省略了 :scheme 和 :path 伪标头字段
- :authority 伪标头字段包含要连接的主机和端口（相当于 CONNECT 请求的请求目标的授权形式；参见 [HTTP] 的第7.1节）。

请求流在携带要传输的数据的请求结束时保持打开状态。不符合这些限制的 CONNECT 请求格式错误.

支持 CONNECT 的代理建立到 :authority 伪标头字段中标识的服务器的 TCP 连接 ( [ RFC0793 ] )。成功建立此连接后，代理会发送一个 HEADERS 包含 2xx 系列客户端状态代码的帧，如[ HTTP ]的第 15.3 节中所定义。

所有数据流上的帧对应于 TCP 连接上发送或接收的数据。任何数据的有效载荷客户端发送的帧由代理转发给 TCP 服务器；从 TCP 服务器接收到的数据被打包成 DATA 由代理帧。请注意，不能保证 TCP 段的大小和数量可预测地映射到 HTTP DATA 的大小和数量或 QUIC STREAM 框架。

一旦 CONNECT 方法完成，只有 DATA 允许在流上发送帧。 如果扩展定义明确允许，则可以使用扩展帧 。任何其他已知帧类型的接收 必须 被视为连接错误类型 H3_FRAME_UNEXPECTED.

TCP 连接可以由任一对等方关闭。当客户端结束 请求流时（即，代理处的接收流进入“Data Recvd”状态），代理将在其与 TCP 服务器的连接上设置 FIN 位。当代理接收到设置了 FIN 位的数据包时，它将关闭它发送给客户端的发送流。在一个方向上保持半关闭状态的 TCP 连接不是无效的，但通常被服务器处理得很差，所以客户端 不应该 关闭一个流来发送，而他们仍然期望从 CONNECT 的目标接收数据。

TCP连接错误通过突然终止流来发出信号。代理将 TCP 连接中的任何错误（包括接收到设置了 RST 位的 TCP 段）视为流错误类型 H3_CONNECT_ERROR.

相应地，如果代理检测到流或 QUIC 连接有错误，它 必须 关闭 TCP 连接。如果代理检测到客户端已重置流或中止从流中读取，则它 必须 关闭 TCP 连接。如果流被重置或读取被客户端中止，代理 应该 在另一个方向上执行相同的操作以确保流的两个方向都被取消。在所有这些情况下，如果底层 TCP 实现允许，代理 应该 发送一个设置了 RST 位的 TCP 段。

由于 CONNECT 创建到任意服务器的隧道，支持 CONNECT 的代理 应该 将其使用限制在一组已知端口或安全请求目标列表；有关详细信息，请参阅[ HTTP ]的第 9.3.6 节。

### 4.5. HTTP Upgrade

HTTP/3 不支持 HTTP 升级机制（[ HTTP ]的第 7.8 节）或 101(Switch Protocol) 信息状态代码（[ HTTP ]的第 15.2.2 节）。

### 4.6. Server Push

服务器推送是一种交互模式，它允许服务器在预期客户端发出指定请求的情况下将请求-响应交换推送到客户端。这会权衡网络使用与潜在的延迟增益。HTTP/3 服务器推送类似于 [ HTTP/2 ]第 8.2 节中描述的内容，但它使用不同的机制。

服务器为每个服务器推送分配一个唯一的推送 ID。推送 ID 用于在 HTTP/3 连接的整个生命周期中指代各种上下文中的推送。

推送 ID 空间从零开始，以MAX_PUSH_ID设置的最大值结束 框架。特别是，在客户端发送 MAX_PUSH_ID 之前，服务器无法推送框架。客户端发送 MAX_PUSH_ID 帧来控制服务器可以承诺的推送次数。服务器 应该 按顺序使用推送 ID，从零开始。客户端 必须处理推送流 的接收作为连接错误类型H3_ID_ERROR 当没有MAX_PUSH_ID已发送帧或当流引用大于最大推送 ID 的推送 ID 时。

推送 ID 用于一个或多个PUSH_PROMISE 携带请求消息的控制数据和报头字段的帧。这些帧在请求流上发送 产生了推动力。这允许服务器推送与客户端请求相关联。当在多个请求流上承诺相同的推送 ID ，解压缩的请求字段部分必须包含相同顺序的相同字段，并且每个字段中的名称和值必须相同。

然后推送 ID 包含在推送流中最终实现这些承诺。推流标识它履行的承诺的推送 ID，然后包含对承诺的请求的响应，如第 4.1 节所述。

最后在 CANCEL_PUSH 中可以使用 push ID帧; 参见 第 7.2.3 节。客户端使用此帧来指示他们不希望接收承诺的资源。服务器使用此框架来指示它们将不会履行先前的承诺。

并非所有请求都可以推送。服务器 可以 推送具有以下属性的请求：

- 可缓存；参见[ HTTP ]的第 9.2.3 节
- 安全的; 见[ HTTP ]第 9.2.1 节
- 不包括请求内容或 trailer 部分

服务器 必须 在 :authority 伪标头字段中包含一个值，服务器对其具有权威性。如果客户端尚未验证推送请求指示的来源的连接，则它 必须 执行与在连接上发送对该来源的请求之前所做的相同的验证过程；参见第 3.3 节。如果此验证失败，则客户端 不得 认为服务器对该来源具有权威性。

客户端 应该 发送一个 CANCEL_PUSH 收到 PUSH_PROMISE 后的帧帧携带不可缓存的请求，不安全，指示请求内容的存在，或者它不认为服务器具有权威性。不得 使用或缓存任何相应的响应 。

每个推送的响应都与一个或多个客户端请求相关联。推送与请求流关联 PUSH_PROMISE 收到帧。相同的服务器推送可以使用PUSH_PROMISE与其他客户端请求相关联在多个请求流上具有相同推送 ID 的帧. 这些关联不影响协议的操作，但 用户代理在决定如何使用推送资源时可能会考虑它们。

PUSH_PROMISE的订购与响应的某些部分相关的框架很重要。服务器 应该 发送PUSH_PROMISE发送HEADERS之前的帧 或数据引用承诺响应的框架。这减少了客户端请求将由服务器推送的资源的机会。

由于重新排序，推流数据可以在相应的 PUSH_PROMISE之前到达框架。当客户端收到新的推流时对于未知的推送 ID，关联的客户端请求和推送的请求标头字段都是未知的。客户端可以缓冲流数据以期望匹配的PUSH_PROMISE. 客户端可以使用流控制（[ QUIC-TRANSPORT ]的第 4.1 节）来限制服务器可以提交给推送流的数据量。客户端 应该 中止读取并丢弃已经从推送流中读取的数据如果没有相应的PUSH_PROMISE帧在合理的时间内处理。

推送流数据也可以在客户端取消推送后到达。在这种情况下，客户端可以使用错误代码 H3_REQUEST_CANCELLED 中止读取流 . 这要求服务器不要传输额外的数据，并表明它会在收到后被丢弃。

可缓存的推送响应（参见[ HTTP-CACHING ]的第 3 节）可以由客户端存储，如果它实现了 HTTP 缓存。在接收到推送响应时，推送响应被认为在源服务器上成功验证（例如，如果存在 “no-cache” 缓存响应指令；请参阅[ HTTP-CACHING ]的第 5.2.2.4 节）。

不可缓存的推送响应不得由任何 HTTP 缓存存储。它们可以单独提供给应用程序。

## 5. Connection Closure

一旦建立，一个 HTTP/3 连接就可以随着时间的推移用于许多请求和响应，直到连接关闭。连接关闭可以以多种不同方式中的任何一种发生。

### 5.1. Idle Connections

每个 QUIC 端点在握手期间声明空闲超时。如果 QUIC 连接保持空闲（没有收到数据包）的时间超过此持续时间，对等方将假定连接已关闭。如果现有连接的空闲时间超过 QUIC 握手期间协商的空闲超时时间，HTTP/3 实现将需要为新请求打开一个新的 HTTP/3 连接，如果接近空闲超时，他们应该这样 做；参见 [ QUIC-TRANSPORT ]的第 10.1 节。

如[ QUIC-TRANSPORT ]的第 10.1.2 节所述，当请求或服务器推送有未完成的响应时，HTTP 客户端应请求传输保持连接打开。如果客户端不期望来自服务器的响应，则允许空闲连接超时比花费精力维护可能不需要的连接更可取。网关可以根据需要维护连接，而不是承担与服务器建立连接的延迟成本。服务器不应该主动保持连接打开。

### 5.2. Connection Shutdown

即使连接不空闲，任何一个端点都可以决定停止使用连接并启动正常的连接关闭。端点通过发送 GOAWAY 启动 HTTP/3 连接的正常关闭框架。GOAWAY frame 包含一个标识符，向接收者指示在此连接中已经或可能处理的请求或推送的范围。服务器发送客户端发起的双向流ID；客户端发送推送 ID. GOAWAY的发送者拒绝具有指定标识符或更大标识符的请求或推送（第 4.1.1 节）. 如果没有请求或推送被处理，这个标识符 可以是零。

GOAWAY 中的信息 frame 使客户端和服务器能够在关闭 HTTP/3 连接之前就接受哪些请求或推送达成一致。发送 GOAWAY 帧，端点应该显式取消（参见第4.1.1节和第 7.2.3节）任何标识符大于或等于指示标识符的请求或推送，以便清理受影响流的传输状态。随着更多请求或推送到达，端点应该继续这样做。

端点不得在收到GOAWAY后发起新请求或承诺对连接进行新推送来自同行的框架。客户端可以建立一个新的连接来发送额外的请求。

一些请求或推送可能已经在传输中：

收到GOAWAY后帧，如果客户端已经发送了流 ID 大于或等于 GOAWAY 中包含的标识符的请求 框架，这些请求将不会被处理。客户端可以在不同的 HTTP 连接上安全地重试未处理的请求。无法重试请求的客户端会在服务器关闭连接时丢失所有正在进行的请求。

请求流 ID 小于GOAWAY中的流 ID来自服务器的帧可能已被处理；在收到响应之前无法知道它们的状态，流被单独重置，另一个GOAWAY接收到的流 ID 低于相关请求的流 ID，或者连接终止。

如果未处理这些请求，服务器 可以拒绝指定 ID 以下的流上的单个请求。

如果服务器收到GOAWAY承诺使用推送 ID推送后的帧大于或等于GOAWAY中包含的标识符frame，那些推送将不会被接受。
服务器 应该 发送一个GOAWAY提前知道连接关闭时的帧，即使提前通知很小，以便远程对等方可以知道请求是否已部分处理。例如，如果 HTTP 客户端在服务器关闭 QUIC 连接的同时发送 POST，如果服务器不发送 GOAWAY，则客户端无法知道服务器是否开始处理该 POST请求框架来指示它可能对哪些流进行了操作。

端点 可以 发送多个GOAWAY帧指示不同的标识符，但每个帧中的标识符 不得 大于任何先前帧中的标识符，因为客户端可能已经在另一个 HTTP 连接上重试了未处理的请求。收到离开包含比先前收到的更大的标识符 必须 被视为连接错误类型H3_ID_ERROR.

尝试正常关闭连接的端点可以发送 GOAWAY帧的值设置为最大可能值（服务器为2 62 -4，客户端为2 62 -1）。这确保对等方停止创建新请求或推送。在为任何飞行中的请求或推送留出时间后，端点可以发送另一个GOAWAY帧指示在连接结束之前它可能接受哪些请求或推送。这确保可以干净地关闭连接而不会丢失请求。

客户端在为GOAWAY中的 Push ID 字段选择值时具有更大的灵活性 它发送。值 2 62 -1 表示服务器可以继续完成已经承诺的推送。较小的值表示客户端将拒绝推送 ID 大于或等于该值的推送。像服务器一样，客户端 可以 发送后续的GOAWAY帧只要指定推送ID不大于任何先前发送的值。

即使是离开表示给定的请求或推送在收到后不会被处理或接受，底层传输资源仍然存在。发起这些请求的端点可以取消它们以清理传输状态。

一旦处理完所有接受的请求和推送，端点可以允许连接变为空闲，或者它 可以 启动立即关闭连接。完成正常关闭的端点 应该 使用 H3_NO_ERROR关闭连接时的错误代码。

如果客户端已经用请求消耗了所有可用的双向流 ID，则服务器不需要发送GOAWAY帧，因为客户端无法发出进一步的请求。

### 5.3. Immediate Application Closure

HTTP/3 实现可以随时立即关闭 QUIC 连接。这导致向对等方发送 QUIC CONNECTION_CLOSE 帧，指示应用层已终止连接。此帧中的应用程序错误代码向对等方指示关闭连接的原因。有关在 HTTP/3 中关闭连接时可以使用的错误代码，请参阅第 8 节。

在关闭连接之前，GOAWAY 可以发送帧以允许客户端重试某些请求。包括GOAWAY将帧与 QUIC CONNECTION_CLOSE 帧放在同一个数据包中可以提高客户端接收帧的机会。

如果存在未显式关闭的打开流，则在关闭连接时隐式关闭它们；参见 [ QUIC-TRANSPORT ]的第 10.2 节。

### 5.4. Transport Closure

由于各种原因，QUIC 传输可能会向应用层指示连接已终止。这可能是由于对等方的明确关闭、传输层错误或网络拓扑的更改中断了连接。

如果连接在没有 GOAWAY 的情况下终止 frame，客户端必须假设发送的任何请求，无论是全部还是部分，都可能已经被处理。

## 6. Stream Mapping and Usage

QUIC 流提供可靠的字节顺序交付，但不保证其他流上字节的交付顺序。在 QUIC 的版本 1 中，包含 HTTP 帧的流数据由 QUIC STREAM 帧承载，但这种分帧对 HTTP 分帧层是不可见的。传输层缓冲和排序接收到的流数据，向应用程序公开可靠的字节流。尽管 QUIC 允许流中的乱序传递，但 HTTP/3 并未使用此功能。

QUIC 流可以是单向的，仅从发起者到接收者传输数据，也可以是双向的，在两个方向上传输数据。流可以由客户端或服务器发起。有关 QUIC 流的更多详细信息，请参阅[ QUIC-TRANSPORT ]的第 2 节。

当通过 QUIC 发送 HTTP 字段和数据时，QUIC 层处理大部分流管理。HTTP 在使用 QUIC 时不需要做任何单独的多路复用：通过 QUIC 流发送的数据总是映射到特定的 HTTP 事务或整个 HTTP/3 连接上下文。

### 6.1. Bidirectional Streams

所有客户端发起的双向流都用于 HTTP 请求和响应。双向流确保响应可以很容易地与请求相关联。这些流称为请求流。

这意味着客户端的第一个请求发生在 QUIC 流 0 上，随后的请求发生在流 4、8 上，依此类推。为了允许这些流打开，HTTP/3 服务器应该为允许的流数量和初始流流量控制窗口配置非零最小值。为了避免不必要地限制并行性， 一次至少应该允许 100 个请求流。

HTTP/3 不使用服务器发起的双向流，尽管扩展可以定义这些流的用途。客户端必须将收到服务器发起的双向流视为连接错误类型 H3_STREAM_CREATION_ERROR 除非已经商定了这样的延期。

### 6.2. Unidirectional Streams

单向流，在任一方向上，用于一系列目的。目的由流类型指示，它在流的开头作为可变长度整数发送。该整数之后的数据格式和结构由流类型决定。

```
Unidirectional Stream Header {
  Stream Type (i),
}
```

本文档中定义了两种流类型：控制流 （第 6.2.1 节）和推流（第 6.2.2 节）。[ QPACK ]定义了两种额外的流类型。其他流类型可以通过 HTTP/3 的扩展来定义；有关更多详细信息，请参阅第 9 节。某些流类型是保留的（第 6.2.3 节）。

HTTP/3 连接在其生命周期早期阶段的性能对单向流上数据的创建和交换很敏感。过度限制流数量或这些流的流量控制窗口的端点将增加远程对等方提前达到限制并被阻塞的机会。特别是，实现应该考虑到远程对等点可能希望使用他们被允许使用的一些单向流来执行保留的流行为（第 6.2.3 节）。

每个端点需要为 HTTP控制流创建至少一个单向流 . QPACK 需要两个额外的单向流，而其他扩展可能需要更多的流。因此，客户端和服务器发送的传输参数 必须 允许对等方创建至少三个单向流。这些传输参数 还应该 为每个单向流提供至少 1,024 字节的流量控制信用。

请注意，如果端点在创建关键单向流之前消耗了所有初始信用，则不需要授予额外信用来创建更多单向流。端点 应该 创建 HTTP 控制流以及强制扩展所需的单向流（例如 QPACK 编码器和解码器流），然后创建其对等方允许的其他流。

如果流标头指示接收者不支持的流类型，则由于语义未知，因此无法使用流的其余部分。未知流类型的接收者 必须 中止流的读取或丢弃传入数据而不进行进一步处理。如果阅读中止，接收者 应该 使用H3_STREAM_CREATION_ERROR错误代码或保留的错误代码（第 8.1 节）。接收者 不得 将未知流类型视为连接错误任何形式的。

由于某些流类型会影响连接状态，因此接收者 不应 在读取流类型之前丢弃来自传入单向流的数据。

实现 可以 在知道对等方是否支持它们之前发送流类型。然而，可以修改现有协议组件的状态或语义的流类型，包括 QPACK 或其他扩展， 在已知对等方支持它们之前不得发送。

除非另有说明，否则发送方可以关闭或重置单向流。接收方 必须 容忍单向流在接收到单向流头之前被关闭或重置。

#### 6.2.1. Control Streams

控制流由流类型 0x00 指示。此流上的数据由 HTTP/3 帧组成，如第 7.2 节中所定义。

每一方都 必须 在连接开始时启动一个控制流并发送其设置帧作为此流的第一帧。如果控制流的第一帧是任何其他帧类型，这 必须 被视为连接错误类型H3_MISSING_SETTINGS. 每个点只允许一个控制流；收到声称是控制流的第二个流 必须 被视为连接错误类型 H3_STREAM_CREATION_ERROR. 发送方 不得 关闭控制流，接收方 不得 请求发送方关闭控制流。如果任一控制流在任何时候关闭，这 必须 被视为连接错误类型H3_CLOSED_CRITICAL_STREAM. 连接错误在第 8 节中描述 。

因为控制流的内容用于管理其他流的行为，所以端点 应该 提供足够的流量控制信用以防止对等方的控制流被阻塞。

使用一对单向流而不是单个双向流。这允许任一对等方尽快发送数据。根据 QUIC 连接上 0-RTT 是否可用，客户端或服务器可能能够首先发送流数据。

#### 6.2.2. Push Streams

服务器推送是 HTTP/2 中引入的一项可选功能，它允许服务器在发出请求之前启动响应。有关详细信息，请参阅第 4.6 节。

推送流由流类型 0x01 表示，后跟推送 ID 它实现的承诺，编码为可变长度整数。此流上的剩余数据由 HTTP/3 帧组成，如 第 7.2 节中所定义，并通过零个或多个中间 HTTP 响应以及随后的单个最终 HTTP 响应来实现承诺的服务器推送，如第 4.1 节中所定义。服务器推送和推送 ID 在第 4.6 节中描述 。

只有服务器可以推送；如果服务器接收到客户端发起的推送流，则 必须 将其视为连接错误类型 H3_STREAM_CREATION_ERROR.

```
Push Stream Header {
  Stream Type (i) = 0x01,
  Push ID (i),
}
```

客户端 不应该 在读取推送流标头之前中止对推送流的读取，因为这可能导致客户端和服务器之间在推送 ID 已经被消费时产生分歧。

每个推送 ID 只能 在推送流标头中使用一次。如果客户端检测到推流头包含推送 ID 在另一个推送流标头中使用，客户端 必须 将其视为连接错误类型 H3_ID_ERROR.

#### 6.2.3. Reserved Stream Types

保留 0x1f * N + 0x21 非负整数值格式的 流类型，以执行忽略未知类型的要求。N这些流没有语义，可以在需要应用层填充时发送。它们 也可以 在当前没有数据传输的连接上发送。端点 不得 认为这些流在收到时具有任何意义。

以发送实现选择的任何方式选择流的有效负载和长度。当发送保留的流类型时，实现 可以 干净地终止流或重置它。重置流时，H3_NO_ERROR应该 使用错误代码或保留的错误代码（第 8.1 节） 。

## 7. HTTP Framing Layer

### 7.1. Frame Layout

### 7.2. Frame Definitions

### 7.2.1. DATA

### 7.2.2. HEADERS

### 7.2.3. CANCEL_PUSH

### 7.2.4. SETTINGS

### 7.2.5. PUSH_PROMISE

### 7.2.6. GOAWAY

### 7.2.7. MAX_PUSH_ID

### 7.2.8. Reserved Frame Types

## 8. Error Handling

### 8.1. HTTP/3 Error Codes

## 9. Extensions to HTTP/3

